var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/reports/diff-reports.ts
import { writeFileSync } from "fs";

// src/reports/diff.ts
function diff(a, b, removeUnchanged) {
  const out = {};
  for (const key in a) {
    if (!b.hasOwnProperty(key)) {
      out[key] = { from: a[key], to: null };
    } else {
      if (typeof a[key] === "object") {
        const tempDiff = diff(a[key], b[key], removeUnchanged);
        if (Object.keys(tempDiff).length > 0) {
          out[key] = tempDiff;
        }
      } else {
        if (b[key] === a[key]) {
          if (!removeUnchanged) out[key] = a[key];
        } else {
          out[key] = { from: a[key], to: b[key] };
        }
      }
    }
  }
  for (const key in b) {
    if (a.hasOwnProperty(key)) continue;
    out[key] = { from: null, to: b[key] };
  }
  return out;
}

// src/reports/emode.ts
import { formatUnits } from "viem";

// src/utils/storageSlots.ts
import {
  concat,
  encodeAbiParameters,
  fromHex,
  keccak256,
  pad,
  parseAbiParameters,
  toBytes,
  toHex,
  trim
} from "viem";
function getSolidityStorageSlotBytes(mappingSlot, key) {
  const slot = pad(mappingSlot, { size: 32 });
  return trim(
    keccak256(encodeAbiParameters(parseAbiParameters("bytes32, uint256"), [key, BigInt(slot)]))
  );
}
function getSolidityStorageSlotUint(mappingSlot, key) {
  return keccak256(encodeAbiParameters(parseAbiParameters("uint256, uint256"), [key, mappingSlot]));
}
function getSolidityStorageSlotAddress(mappingSlot, key) {
  return keccak256(
    encodeAbiParameters(parseAbiParameters("address, uint256"), [key, BigInt(mappingSlot)])
  );
}
function getBits(_bigIntValue, startBit, _endBit) {
  let endBit = _endBit;
  const bigIntValue = BigInt(_bigIntValue);
  if (startBit > endBit) {
    throw new Error("Invalid bit range: startBit must be less than or equal to endBit");
  }
  const bitLength = BigInt(bigIntValue.toString(2)).toString().length;
  if (endBit >= bitLength) {
    endBit = BigInt(bitLength - 1);
  }
  const mask = (1n << endBit - startBit + 1n) - 1n;
  const maskedValue = bigIntValue >> startBit & mask;
  return maskedValue.toString();
}
function setBits(_bigIntBase, startBit, endBit, _replaceValue) {
  const bigIntBase = BigInt(_bigIntBase);
  const bigIntReplaceValue = BigInt(_replaceValue);
  let mask = BigInt(0);
  for (let i = startBit; i < endBit; i++) {
    mask |= BigInt(1) << BigInt(i);
  }
  const clearedNumber = bigIntBase & ~mask;
  const result = clearedNumber | bigIntReplaceValue << BigInt(startBit);
  return result;
}
function bitMapToIndexes(bitmap) {
  const reserveIndexes = [];
  for (let i = 0; bitmap != 0n; i++) {
    if (bitmap & 0x1n) reserveIndexes.push(i);
    bitmap = bitmap >> 1n;
  }
  return reserveIndexes;
}

// src/reports/emode.ts
function renderEModeValue(key, emode, snapshot) {
  if (!emode[key]) return "-";
  if (["reserveFactor", "liquidationProtocolFee", "liquidationThreshold", "ltv"].includes(key))
    return `${formatUnits(BigInt(emode[key]), 2)} %`;
  if (key === "liquidationBonus")
    return emode[key] === 0 ? "0 %" : `${(emode[key] - 1e4) / 100} %`;
  if (key === "borrowableBitmap" || key === "collateralBitmap") {
    const indexes = bitMapToIndexes(BigInt(emode[key]));
    return indexes.map(
      (i) => snapshot.reserves[Object.keys(snapshot.reserves).find((key2) => snapshot.reserves[key2].id === i)].symbol
    ).join(", ");
  }
  return emode[key];
}
var ORDER = [
  "eModeCategory",
  "label",
  "ltv",
  "liquidationThreshold",
  "liquidationBonus",
  "priceSource"
];
function sortEmodeKeys(a, b) {
  const indexA = ORDER.indexOf(a);
  const indexB = ORDER.indexOf(b);
  if (indexA !== -1 && indexB !== -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA !== -1) return -1;
  if (indexB !== -1) return -1;
  return a.localeCompare(b);
}
var OMIT_KEYS = ["eModeCategory"];
function renderEmodeDiff(diff2, pre, post) {
  let content = "| description | value before | value after |\n| --- | --- | --- |\n";
  Object.keys(diff2).filter((key) => !OMIT_KEYS.includes(key)).sort(sortEmodeKeys).map((key) => {
    if (typeof diff2[key] === "object" && diff2[key].hasOwnProperty("from"))
      content += `| eMode.${key} | ${renderEModeValue(
        key,
        {
          ...diff2,
          [key]: diff2[key].from
        },
        pre
      )} | ${renderEModeValue(key, { ...diff2, [key]: diff2[key].to }, post)} |
`;
    else {
      const value = renderEModeValue(key, diff2, pre);
      content += `| eMode.${key} (unchanged) | ${value} | ${value} |
`;
    }
  });
  return content;
}

// src/reports/fetch-IR-strategy.ts
function getStrategyImageUrl(rate) {
  const paramsObj = {
    variableRateSlope1: rate.variableRateSlope1,
    variableRateSlope2: rate.variableRateSlope2,
    optimalUsageRatio: rate.optimalUsageRatio,
    baseVariableBorrowRate: rate.baseVariableBorrowRate,
    maxVariableBorrowRate: rate.maxVariableBorrowRate
  };
  const searchParams = new URLSearchParams(paramsObj);
  return `https://dash.onaave.com/api/static?${searchParams.toString()}`;
}

// src/reports/reserve.ts
import { formatUnits as formatUnits3 } from "viem";

// src/govv3/utils/markdownUtils.ts
import { formatUnits as formatUnits2, getContract as getContract2 } from "viem";

// src/govv3/utils/checkAddress.ts
import * as addresses from "@bgd-labs/aave-address-book";
import { IPool_ABI, IERC20Detailed_ABI } from "@bgd-labs/aave-address-book/abis";
import { findObjectPaths } from "find-object-paths";
import { getAddress, getContract } from "viem";
function isKnownAddress(value, chainId) {
  const transformedAddresses = Object.keys(addresses).reduce(
    (acc, key) => {
      if (addresses[key].CHAIN_ID === chainId) {
        const chainAddresses = { ...addresses[key] };
        if (chainAddresses.E_MODES) delete chainAddresses.E_MODES;
        acc[key] = chainAddresses;
      }
      return acc;
    },
    {}
  );
  const results = findObjectPaths(transformedAddresses, { value: getAddress(value) });
  if (typeof results === "string") return [results];
  return results;
}
function findPayloadsController(chainId) {
  const key = Object.keys(addresses).find(
    (key2) => addresses[key2].CHAIN_ID === chainId && addresses[key2].PAYLOADS_CONTROLLER
  );
  if (key) return addresses[key].PAYLOADS_CONTROLLER;
}
var assetsCache = Object.keys(addresses).reduce((acc, key) => {
  if (!addresses[key].ASSETS) return acc;
  const pool = addresses[key];
  if (!acc[pool.CHAIN_ID]) acc[pool.CHAIN_ID] = {};
  Object.keys(pool.ASSETS).map((symbol) => {
    const asset = pool.ASSETS[symbol];
    acc[pool.CHAIN_ID][asset.UNDERLYING] = { decimals: asset.decimals, symbol };
  });
  return acc;
}, {});
async function findAsset(client, address) {
  const chainId = client.chain.id;
  const asset = assetsCache[chainId][address];
  if (asset) return asset;
  const erc20Contract = getContract({ client, address, abi: IERC20Detailed_ABI });
  let symbol = "unknown";
  let decimals = 0;
  try {
    symbol = await erc20Contract.read.symbol();
  } catch (e) {
  }
  try {
    decimals = await erc20Contract.read.decimals();
  } catch (e) {
  }
  assetsCache[chainId][address] = {
    symbol,
    decimals
  };
  return assetsCache[chainId][address];
}
var cachedReservesList = {};
async function assetIndexesToAsset(client, poolAddress, indexes) {
  if (!cachedReservesList[client.chain.id])
    cachedReservesList[client.chain.id] = await getContract({
      client,
      abi: IPool_ABI,
      address: poolAddress
    }).read.getReservesList();
  const reservesList = cachedReservesList[client.chain.id];
  return await Promise.all(
    indexes.map(async (index) => {
      if (index < reservesList.length) {
        const reserve = reservesList[index];
        return `${(await findAsset(client, reserve)).symbol}(id: ${index})`;
      }
      return `unknown(id: ${index})`;
    })
  );
}

// src/govv3/utils/markdownUtils.ts
function boolToMarkdown(value) {
  if (value) return ":white_check_mark:";
  return ":sos:";
}
function toAddressLink(address, md, client) {
  if (!client) return address;
  const link = `${client.chain?.blockExplorers?.default.url}/address/${address}`;
  if (md) return toMarkdownLink(link, address);
  return link;
}
function toTxLink(txn, md, client) {
  if (!client) return txn;
  const link = `${client.chain?.blockExplorers?.default.url}/tx/${txn}`;
  if (md) return toMarkdownLink(link, txn);
  return link;
}
function toMarkdownLink(link, title) {
  return `[${title || link}](${link})`;
}
function renderCheckResult(check, result) {
  let response = `### Check: ${check.name} ${boolToMarkdown(!result.errors.length)}

`;
  if (result.errors.length) response += `#### Errors

${result.errors.join("\n")}

`;
  if (result.warnings.length) response += `#### Warnings

${result.warnings.join("\n")}

`;
  if (result.info.length) response += `#### Info

${result.info.join("\n")}

`;
  return response;
}
function renderUnixTime(time) {
  return new Date(time * 1e3).toLocaleString("en-GB", { timeZone: "UTC" });
}
function flagKnownAddress(isKnown) {
  if (isKnown === void 0 || isKnown.length === 0) return "";
  return `[:ghost:](https://github.com/bgd-labs/aave-address-book "${isKnown.join(", ")}")`;
}
function formatNumberString(x) {
  return String(x).replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",");
}
function limitDecimalsWithoutRounding(val, decimals) {
  const parts = val.split(".");
  if (parts.length != 2) return val;
  return parts[0] + "." + parts[1].substring(0, decimals);
}
function prettifyNumber({
  value,
  decimals,
  prefix,
  suffix,
  showDecimals,
  patchedValue
}) {
  const formattedNumber = limitDecimalsWithoutRounding(
    formatNumberString(formatUnits2(BigInt(patchedValue || value), decimals)),
    4
  );
  return `${prefix ? `${prefix} ` : ""}${formattedNumber}${suffix ? ` ${suffix}` : ""} [${value}${showDecimals ? `, ${decimals} decimals` : ""}]`;
}
function wrapInQuotes(name, quotes) {
  if (quotes) return "`" + name + "`";
  return name;
}
async function addAssetSymbol(client, value) {
  const asset = await findAsset(client, value);
  return `${value} (symbol: ${asset.symbol})`;
}
var CL_PROXY_ABI = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "description",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "latestAnswer",
    outputs: [{ internalType: "int256", name: "", type: "int256" }],
    stateMutability: "view",
    type: "function"
  }
];
async function addAssetPrice(client, address) {
  const clProxy = getContract2({ client, address, abi: CL_PROXY_ABI });
  let decimals, latestAnswer = 0n, description = "unknown";
  try {
    decimals = await clProxy.read.decimals();
  } catch (e) {
  }
  try {
    latestAnswer = await clProxy.read.latestAnswer();
  } catch (e) {
  }
  try {
    description = await clProxy.read.description();
  } catch (e) {
  }
  return `${address} (latestAnswer: ${decimals ? prettifyNumber({ value: latestAnswer, decimals, showDecimals: true }) : latestAnswer}, description: ${description})`;
}

// src/utils/getClient.ts
import "dotenv/config";
import { ChainList, getRPCUrl } from "@bgd-labs/rpc-env";
import { createClient, http } from "viem";
function getClient(chainId) {
  const chain = ChainList[chainId];
  if (!chain) return;
  return createClient({
    transport: http(
      getRPCUrl(chainId, {
        alchemyKey: process.env.ALCHEMY_API_KEY
      })
    ),
    chain
  });
}

// src/reports/reserve.ts
function renderReserveValue(key, reserve, chainId) {
  if (["reserveFactor", "liquidationProtocolFee", "liquidationThreshold", "ltv"].includes(key))
    return prettifyNumber({ value: reserve[key], decimals: 2, suffix: "%" });
  if (["supplyCap", "borrowCap"].includes(key))
    return `${reserve[key].toLocaleString("en-US")} ${reserve.symbol}`;
  if (["aTokenUnderlyingBalance", "virtualBalance"].includes(key))
    return prettifyNumber({
      value: reserve[key],
      decimals: reserve.decimals,
      suffix: reserve.symbol
    });
  if (key === "debtCeiling")
    return prettifyNumber({ value: reserve[key], decimals: 2, suffix: "$" });
  if (["liquidityIndex", "variableBorrowIndex"].includes(key))
    return prettifyNumber({ value: reserve[key], decimals: 27, suffix: "%" });
  if (["currentLiquidityRate", "currentVariableBorrowRate"].includes(key))
    return prettifyNumber({ value: reserve[key], decimals: 25, suffix: "%" });
  if (key === "liquidationBonus")
    return reserve[key] === 0 ? "0 %" : `${(reserve[key] - 1e4) / 100} %`;
  if (key === "interestRateStrategy")
    return toAddressLink(reserve[key], true, getClient(chainId));
  if (key === "oracleLatestAnswer" && reserve.oracleDecimals)
    return formatUnits3(BigInt(reserve[key]), reserve.oracleDecimals);
  if (typeof reserve[key] === "number") return reserve[key].toLocaleString("en-US");
  if (typeof reserve[key] === "string" && /0x.+/.test(reserve[key]))
    return toAddressLink(reserve[key], true, getClient(chainId));
  return reserve[key];
}
function renderReserveHeadline(reserve, chainId) {
  return `#### ${reserve.symbol} (${toAddressLink(reserve.underlying, true, getClient(chainId))})

`;
}
var ORDER2 = [
  "symbol",
  "decimals",
  "isActive",
  "isFrozen",
  "supplyCap",
  "borrowCap",
  "debtCeiling",
  "isSiloed",
  "isFlashloanable",
  "eModeCategory",
  "oracle",
  "oracleDecimals",
  "oracleDescription",
  "oracleName",
  "oracleLatestAnswer",
  "usageAsCollateralEnabled",
  "ltv",
  "liquidationThreshold",
  "liquidationBonus",
  "liquidationProtocolFee",
  "reserveFactor",
  "aToken",
  "aTokenImpl",
  "variableDebtToken",
  "variableDebtTokenImpl",
  "stableDebtToken",
  "stableDebtTokenImpl",
  "borrowingEnabled",
  "stableBorrowRateEnabled",
  "isBorrowableInIsolation",
  "interestRateStrategy",
  "liquidityIndex",
  "variableBorrowIndex"
];
function sortReserveKeys(a, b) {
  const indexA = ORDER2.indexOf(a);
  if (indexA === -1) return 1;
  const indexB = ORDER2.indexOf(b);
  if (indexB === -1) return -1;
  return indexA - indexB;
}
function renderReserveConfig(reserve, chainId) {
  let content = "| description | value |\n| --- | --- |\n";
  const OMIT_KEYS3 = [
    "underlying",
    // already rendered in the header
    "symbol"
    // already rendered in the header
  ];
  Object.keys(reserve).filter((key) => !OMIT_KEYS3.includes(key)).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(key, reserve, chainId)} |
`;
  });
  return content;
}
function renderReserve(reserve, chainId) {
  let content = renderReserveHeadline(reserve, chainId);
  content += renderReserveConfig(reserve, chainId);
  return content;
}
function renderReserveDiff(diff2, chainId) {
  let content = renderReserveHeadline(diff2, chainId);
  content += "| description | value before | value after |\n| --- | --- | --- |\n";
  const from = Object.keys(diff2).reduce((acc, _key) => {
    const key = _key;
    acc[key] = typeof diff2[key] === "object" ? diff2[key].from : diff2[key];
    return acc;
  }, {});
  const to = Object.keys(diff2).reduce((acc, _key) => {
    const key = _key;
    acc[key] = typeof diff2[key] === "object" ? diff2[key].to : diff2[key];
    return acc;
  }, {});
  Object.keys(diff2).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(key, from, chainId)} | ${renderReserveValue(key, to, chainId)} |
`;
  });
  return content;
}

// src/reports/strategy.ts
import { formatUnits as formatUnits4 } from "viem";
function renderStrategyValue(key, reserve) {
  if (reserve[key] === void 0 || reserve[key] === null) return "/";
  return `${formatUnits4(BigInt(reserve[key]), 25)} %`;
}
var ORDER3 = [
  "optimalUsageRatio",
  "maxVariableBorrowRate",
  "baseVariableBorrowRate",
  "variableRateSlope1",
  "variableRateSlope2"
];
function sortStrategyKeys(a, b) {
  const indexA = ORDER3.indexOf(a);
  const indexB = ORDER3.indexOf(b);
  if (indexA !== -1 && indexB !== -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA !== -1) return -1;
  if (indexB !== -1) return -1;
  return a.localeCompare(b);
}
var OMIT_KEYS2 = [
  "address"
  // already rendered in the reserve
];
function renderStrategy(strategy) {
  let content = "";
  Object.keys(strategy).filter((key) => !OMIT_KEYS2.includes(key)).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, strategy)} |
`;
  });
  return content;
}
function renderStrategyDiff(diff2) {
  let content = "";
  Object.keys(diff2).filter((key) => !OMIT_KEYS2.includes(key)).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, {
      ...diff2,
      [key]: diff2[key].from
    })} | ${renderStrategyValue(key, { ...diff2, [key]: diff2[key].to })} |
`;
  });
  return content;
}

// src/reports/code-diff.ts
import { existsSync } from "fs";
import { execSync } from "child_process";
function downloadContract(chainId, address) {
  const outPath = `/tmp/${chainId}_${address}`;
  if (existsSync(outPath)) console.log("skipped download");
  const command = `cast etherscan-source --chain ${chainId} -d ${outPath} ${address}`;
  execSync(command);
  return outPath;
}
function flatten(path) {
  const flattenCmd = `
          mkdir -p ${path}_flat
          counter=1
          for file in $(find ${path} -type f)
          do
            original_file_name="\${file##*/}"
            if [ -e ${path}_flat/\${counter}_\${original_file_name} ]
            then
              mv "$file" "${path}_flat/\${counter}_\${original_file_name}"
            else
              mv "$file" "${path}_flat/\${original_file_name}"
            fi
            ((counter++))
          done;
      `;
  execSync(flattenCmd);
  return `${path}_flat`;
}
function diffCode(fromPath, toPath) {
  fromPath = flatten(fromPath);
  toPath = flatten(toPath);
  const prettierCmd = `npx prettier ${fromPath} ${toPath} --write`;
  execSync(prettierCmd);
  const diffCmd = `
  git diff --no-index --ignore-space-at-eol ${fromPath} ${toPath} | awk '
    BEGIN { in_diff_block = 0; skip_block = 0; buffer = "" }
    /^diff --git/ {
      if (in_diff_block && skip_block == 0) { printf "%s", buffer }
      in_diff_block = 1; skip_block = 0; buffer = $0 "\\n"
    }
    /similarity index 100%/ { skip_block = 1 }
    { if (in_diff_block && !/^diff --git/) { buffer = buffer $0 "\\n" } }
    END { if (in_diff_block && skip_block == 0) { printf "%s", buffer } }
  '
  `;
  const result = execSync(diffCmd);
  return result.toString();
}

// src/reports/diff-reports.ts
function hasDiff(input) {
  if (!input) return false;
  return !!Object.keys(input).find(
    (key) => typeof input[key] === "object" && input[key] !== null && (input[key].hasOwnProperty("from") || input[key].hasOwnProperty("to"))
  );
}
async function diffReports(pre, post) {
  const chainId = pre.chainId;
  const diffResult = diff(pre, post);
  const diffResultWithoutUnchanged = diff(pre, post, true);
  let content = "";
  const reservesAdded = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].to) {
      let report = renderReserve(diffResult.reserves[reserveKey].to, chainId);
      report += renderStrategy(post.strategies[reserveKey]);
      report += `| interestRate | ![ir](${getStrategyImageUrl(post.strategies[reserveKey])}) |
`;
      return report;
    }
  }).filter((i) => i);
  const reservesRemoved = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].from) {
      return renderReserve(diffResult.reserves[reserveKey].from, chainId);
    }
  }).filter((i) => i);
  const reservesAltered = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (!diffResult.reserves[reserveKey].hasOwnProperty("from")) {
      const hasChangedReserveProperties = hasDiff(diffResult.reserves[reserveKey]);
      const preIr = getStrategyImageUrl(pre.strategies[reserveKey]);
      const postIr = getStrategyImageUrl(post.strategies[reserveKey]);
      const hasChangedIr = preIr !== postIr;
      if (!hasChangedReserveProperties && !hasChangedIr) return;
      let report = renderReserveDiff(diffResult.reserves[reserveKey], chainId);
      if (hasChangedIr) {
        report += renderStrategyDiff(
          diff(pre.strategies[reserveKey], post.strategies[reserveKey])
        );
        report += `| interestRate | ![before](${preIr}) | ![after](${postIr}) |`;
      }
      return report;
    }
  }).filter((i) => i);
  if (reservesAdded.length || reservesRemoved.length || reservesAltered.length) {
    content += "## Reserve changes\n\n";
    if (reservesAdded.length) {
      content += `### ${reservesAdded.length > 1 ? "Reserve" : "Reserves"} added

`;
      content += reservesAdded.join("\n\n");
      content += "\n\n";
    }
    if (reservesAltered.length) {
      content += `### ${reservesAltered.length > 1 ? "Reserve" : "Reserves"} altered

`;
      content += reservesAltered.join("\n\n");
      content += "\n\n";
    }
    if (reservesRemoved.length) {
      content += `### ${reservesRemoved.length > 1 ? "Reserve" : "Reserves"} removed

`;
      content += reservesRemoved.join("\n\n");
      content += "\n\n";
    }
  }
  if (diffResultWithoutUnchanged.eModes) {
    content += "## Emodes changed\n\n";
    for (const eMode of Object.keys(diffResult.eModes)) {
      const hasChanges = hasDiff(diffResult.eModes?.[eMode]);
      content += `### EMode: ${post.eModes[eMode].label}(id: ${post.eModes[eMode].eModeCategory})

`;
      if (hasChanges) {
        content += renderEmodeDiff(
          diff(pre.eModes[eMode] || {}, post.eModes[eMode] || {}),
          pre,
          post
        );
      } else if (!pre.eModes[eMode] || !post.eModes[eMode]) {
        content += renderEmodeDiff(
          diff(pre.eModes[eMode] || {}, post.eModes[eMode] || {}),
          pre,
          post
        );
      }
      content += "\n\n";
    }
  }
  try {
    if (diffResultWithoutUnchanged.poolConfig) {
      for (const key of Object.keys(diffResult.poolConfig)) {
        if (typeof diffResult.poolConfig[key] === "object" && diffResult.poolConfig[key].hasOwnProperty("from")) {
          const fromAddress = diffResult.poolConfig[key].from;
          const toAddress = diffResult.poolConfig[key].to;
          const from = downloadContract(pre.chainId, fromAddress);
          const to = downloadContract(pre.chainId, toAddress);
          const result = diffCode(from, to);
          writeFileSync(`./diffs/${pre.chainId}_${key}_${fromAddress}_${toAddress}.diff`, result);
        }
      }
    }
  } catch (e) {
  }
  content += `## Raw diff

\`\`\`json
${JSON.stringify(diffResultWithoutUnchanged, null, 2)}
\`\`\``;
  return content;
}

// src/utils/logger.ts
import chalk from "chalk";

// src/utils/constants.ts
import { GovernanceV3Ethereum } from "@bgd-labs/aave-address-book";
var EOA = "0xD73a92Be73EfbFcF3854433A5FcbAbF9c1316073";
var VERBOSE = process.env.VERBOSE;
var FORMAT = process.env.FORMAT || "raw";
var DEFAULT_GOVERNANCE = GovernanceV3Ethereum.GOVERNANCE;
var DEFAULT_GOVERNANCE_CLIENT = getClient(1);

// src/utils/logger.ts
function logVerbose(topic, text) {
  if (VERBOSE) console.log(chalk.gray(`Info[${topic}]: ${text}`));
}
function logInfo(topic, text) {
  console.log(chalk.blue(`Info[${topic}]: ${text}`));
}
function logWarning(topic, text) {
  console.log(chalk.yellow(`Warning[${topic}]: ${text}`));
}
function logError(topic, text) {
  console.log(chalk.red(`Error[${topic}]: ${text}`));
}
function logSuccess(topic, text) {
  console.log(chalk.green(`Success[${topic}]: ${text}`));
}

// src/govv3/checks/logs.ts
import { getAddress as getAddress3 } from "viem";

// src/govv3/utils/logInterpreter.ts
var tokenAmountEvents = ["Transfer", "Approval", "Burn", "Mint", "BalanceTransfer"];
var reserveEvents = ["Withdraw", "Supply", "Deposit"];
var assetFields = ["asset", "token", "reserve", "fromToken", "toToken"];
async function interpretLog(client, address, name, inputs) {
  if (inputs) {
    for (let i = 0; i < inputs.length; i++) {
      if (inputs[i].soltype?.name && assetFields.includes(inputs[i].soltype.name)) {
        inputs[i].value = await addAssetSymbol(client, inputs[i].value);
      }
    }
    if (name && tokenAmountEvents.includes(name)) {
      const decimalFieldNames = ["value", "amount", "wad"];
      for (const name2 of decimalFieldNames) {
        const valueIndex = inputs.findIndex((i) => i.soltype.name === name2);
        if (valueIndex !== -1) {
          const asset = await findAsset(client, address);
          if (asset) {
            inputs[valueIndex].value = prettifyNumber({
              showDecimals: true,
              value: inputs[valueIndex].value,
              decimals: asset.decimals
            });
          }
        }
      }
    }
    if (name && reserveEvents.includes(name)) {
      const valueIndex = inputs.findIndex((i) => i.soltype.name === "amount");
      const reserveIndex = inputs.findIndex((i) => i.soltype.name === "reserve");
      if (valueIndex !== -1 && reserveIndex !== -1) {
        const asset = await findAsset(client, inputs[reserveIndex].value);
        if (asset) {
          inputs[valueIndex].value = prettifyNumber({
            showDecimals: true,
            value: inputs[valueIndex].value,
            decimals: asset.decimals
          });
        }
      }
    }
    if (name && ["Mint", "ReserveDataUpdated", "Burn"].includes(name)) {
      const decimalFieldNames = ["liquidityIndex", "variableBorrowIndex", "index"];
      for (const name2 of decimalFieldNames) {
        const valueIndex = inputs.findIndex((i) => i.soltype.name === name2);
        if (valueIndex !== -1) {
          inputs[valueIndex].value = prettifyNumber({
            showDecimals: true,
            value: inputs[valueIndex].value,
            decimals: 27
          });
        }
      }
    }
  }
  const parsedInputs = inputs?.map(
    (i) => `${i.soltype.name}: ${typeof i.value === "object" ? JSON.stringify(i.value) : i.value}`
  ).join(", ");
  return `  - \`${name}(${parsedInputs || ""})\``;
}

// src/govv3/utils/solidityUtils.ts
import { getAddress as getAddress2 } from "viem";
function getContractName(contracts, address, chainId) {
  const isAddrKnown = isKnownAddress(address, chainId);
  const contract = contracts.find((c) => c.address.toLowerCase() === address.toLowerCase());
  if (!contract)
    return `unknown contract name at \`${getAddress2(address)}\`${flagKnownAddress(isAddrKnown)}`;
  let contractName = contract?.contract_name;
  if (contract?.token_data?.name) contractName += ` (${contract?.token_data?.name})`;
  if (contract.standards?.includes("eip1967") && contract.child_contracts?.[0].address) {
    return `${contractName} at \`${getAddress2(address)}\`${flagKnownAddress(
      isAddrKnown
    )} with implementation ${getContractName(contracts, contract.child_contracts?.[0].address, chainId)}`;
  }
  return `${contractName} at \`${getAddress2(address)}\`${flagKnownAddress(isAddrKnown)}`;
}

// src/govv3/checks/logs.ts
var checkLogs = {
  name: "Reports all events emitted from the proposal",
  async checkProposal(proposal, sim, client) {
    const info = [];
    const events = sim.transaction.transaction_info.logs?.reduce(
      (logs, log) => {
        const addr = getAddress3(log.raw.address);
        if (!logs[addr]) logs[addr] = [log];
        else logs[addr].push(log);
        return logs;
      },
      {}
    );
    if (!events || !Object.keys(events).length)
      return { info: ["No events emitted"], warnings: [], errors: [] };
    for (const [address, logs] of Object.entries(events)) {
      info.push(`- ${getContractName(sim.contracts, address, client.chain.id)}`);
      for (const log of logs) {
        if (log.name) {
          info.push(await interpretLog(client, address, log.name, log.inputs));
        } else {
          info.push(`  - Undecoded log: \`${JSON.stringify(log)}\``);
        }
      }
    }
    return { info, warnings: [], errors: [] };
  }
};

// src/govv3/checks/selfDestruct.ts
import { getBytecode, getTransactionCount } from "viem/actions";
var checkTargetsNoSelfdestruct = {
  name: "Check all targets do not contain selfdestruct",
  async checkProposal(proposal, sim, client) {
    const allTargets = proposal.payload.actions.map((action) => action.target);
    const uniqueTargets = allTargets.filter((addr, i, targets) => targets.indexOf(addr) === i);
    const { info, warn, error } = await checkNoSelfdestructs([], uniqueTargets, client);
    return { info, warnings: warn, errors: error };
  }
};
var checkTouchedContractsNoSelfdestruct = {
  name: "Check all touched contracts do not contain selfdestruct",
  async checkProposal(proposal, sim, client) {
    const { info, warn, error } = await checkNoSelfdestructs([], sim.transaction.addresses, client);
    return { info, warnings: warn, errors: error };
  }
};
async function checkNoSelfdestructs(trustedAddrs, addresses2, client) {
  const info = [];
  const warn = [];
  const error = [];
  for (const addr of addresses2) {
    const status = await checkNoSelfdestruct(trustedAddrs, addr, client);
    const isAddrKnown = isKnownAddress(addr, client.chain.id);
    const address = toAddressLink(addr, true, client);
    if (status === "eoa") info.push(`- ${address}: EOA${flagKnownAddress(isAddrKnown)}`);
    else if (status === "empty")
      warn.push(`- ${address}: EOA (may have code later)${flagKnownAddress(isAddrKnown)}`);
    else if (status === "safe")
      info.push(`- ${address}: Contract (looks safe)${flagKnownAddress(isAddrKnown)}`);
    else if (status === "delegatecall")
      warn.push(`- ${address}: Contract (with DELEGATECALL)${flagKnownAddress(isAddrKnown)}`);
    else if (status === "trusted")
      info.push(`- ${address}: Trusted contract (not checked)${flagKnownAddress(isAddrKnown)}`);
    else error.push(`- ${address}: Contract (with SELFDESTRUCT)${flagKnownAddress(isAddrKnown)}`);
  }
  return { info, warn, error };
}
var STOP = 0;
var JUMPDEST = 91;
var PUSH1 = 96;
var PUSH32 = 127;
var RETURN = 243;
var REVERT = 253;
var INVALID = 254;
var SELFDESTRUCT = 255;
var DELEGATECALL = 244;
var isHalting = (opcode) => [STOP, RETURN, REVERT, INVALID, SELFDESTRUCT].includes(opcode);
var isPUSH = (opcode) => opcode >= PUSH1 && opcode <= PUSH32;
async function checkNoSelfdestruct(trustedAddrs, addr, client) {
  if (trustedAddrs.map((addr2) => addr2.toLowerCase()).includes(addr.toLowerCase())) return "trusted";
  const [code, nonce] = await Promise.all([
    getBytecode(client, { address: addr }),
    getTransactionCount(client, { address: addr })
  ]);
  if (!code) return nonce > 0 ? "eoa" : "empty";
  const bytecode = Buffer.from(code.substring(2), "hex");
  let halted = false;
  let delegatecall = false;
  for (let index = 0; index < bytecode.length; index++) {
    const opcode = bytecode[index];
    if (opcode === SELFDESTRUCT && !halted) {
      return "selfdestruct";
    }
    if (opcode === DELEGATECALL && !halted) {
      delegatecall = true;
    } else if (opcode === JUMPDEST) {
      halted = false;
    } else if (isHalting(opcode)) {
      halted = true;
    } else if (isPUSH(opcode)) {
      index += opcode - PUSH1 + 1;
    }
  }
  return delegatecall ? "delegatecall" : "safe";
}

// src/govv3/checks/state.ts
import { getAddress as getAddress4 } from "viem";

// src/govv3/utils/reserveConfigurationInterpreter.ts
import * as pools from "@bgd-labs/aave-address-book";
function getDecodedReserveData(contractAddress, data) {
  if (!data) return data;
  if ([
    pools.AaveV2EthereumAMM.POOL,
    pools.AaveV2Ethereum.POOL,
    pools.AaveV2Polygon.POOL,
    pools.AaveV2Avalanche.POOL
  ].map((address) => address.toLowerCase()).includes(contractAddress.toLowerCase()))
    return decodeReserveDataV2(data);
  return decodeReserveDataV3(data);
}
function decodeReserveDataV2(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const reserveFactor = getBits(data, 64n, 79n);
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableBorrowingEnabled: !!stableBorrowingEnabled,
    reserveFactor
  };
}
function decodeReserveDataV3(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableRateBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const paused = Number(getBits(data, 60n, 60n));
  const borrowingInIsolation = Number(getBits(data, 61n, 61n));
  const siloedBorrowingEnabled = Number(getBits(data, 62n, 62n));
  const flashloaningEnabled = Number(getBits(data, 63n, 63n));
  const reserveFactor = getBits(data, 64n, 79n);
  const borrowCap = getBits(data, 80n, 115n);
  const supplyCap = getBits(data, 116n, 151n);
  const liquidationProtocolFee = getBits(data, 152n, 167n);
  const eModeCategory = getBits(data, 168n, 175n);
  const unbackedMintCap = getBits(data, 176n, 211n);
  const debtCeiling = getBits(data, 212n, 251n);
  const virtualAccountingEnabled = Number(getBits(data, 252n, 252n));
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableRateBorrowingEnabled,
    paused,
    borrowingInIsolation,
    reserveFactor,
    borrowCap,
    supplyCap,
    liquidationProtocolFee,
    eModeCategory,
    unbackedMintCap,
    debtCeiling,
    siloedBorrowingEnabled: !!siloedBorrowingEnabled,
    flashloaningEnabled: !!flashloaningEnabled,
    virtualAccountingEnabled: !!virtualAccountingEnabled
  };
}

// src/govv3/checks/state.ts
function resolveChain(chain) {
  return chain.join(".");
}
function getContractChanges(diffs) {
  const changes = [];
  for (const diff2 of diffs) {
    if (!diff2.soltype) {
      for (const w of diff2.raw) {
        const oldVal = JSON.stringify(w.original);
        const newVal = JSON.stringify(w.dirty);
        changes.push({ before: oldVal, after: newVal, name: `Slot \`${w.key}\`` });
      }
    } else if (diff2.soltype.simple_type) {
      changes.push({
        before: diff2.original,
        after: diff2.dirty,
        name: diff2.soltype.name,
        type: diff2.soltype?.name
      });
    } else if (diff2.soltype.type.startsWith("mapping")) {
      const keys = Object.keys(diff2.original);
      const original = diff2.original;
      const dirty = diff2.dirty;
      for (const k of keys) {
        changes.push({ before: original[k], after: dirty[k], name: k, type: diff2.soltype?.name });
      }
    } else {
      for (const w of diff2.raw) {
        const oldVal = JSON.stringify(w.original);
        const newVal = JSON.stringify(w.dirty);
        changes.push({ before: oldVal, after: newVal, name: `Slot \`${w.key}\`` });
        console.log(
          `Could not parse state: add support for formatting type ${diff2.soltype?.type} (slot ${w.key})
`
        );
      }
    }
  }
  return changes;
}
async function renderContractChanges(simulation, client, address, changes) {
  let stateChanges = `
${getContractName(simulation.contracts, address, client.chain.id)}
\`\`\`diff
`;
  for (const change of changes) {
    stateChanges += await deepDiff({
      client,
      address,
      before: change.before,
      after: change.after,
      accessChain: [change.name],
      type: change.type
    });
  }
  stateChanges += "```\n";
  return stateChanges;
}
async function deepDiff({
  client,
  address,
  before,
  after,
  accessChain,
  type
}) {
  if (type && accessChain.length === 1 && ["_reserves", "assets", "assetsSources"].includes(type)) {
    accessChain[0] = await addAssetSymbol(client, accessChain[0]);
  }
  if (typeof before !== "object" || typeof after !== "object") {
    return `@@ ${type ? `${wrapInQuotes(type, true)} key ` : ""}${wrapInQuotes(
      resolveChain(accessChain),
      !!type
    )} @@
- ${await enhanceValue({ client, address, value: before, type, accessChain })}
+ ${await enhanceValue(
      {
        client,
        address,
        value: after,
        type,
        accessChain
      }
    )}
`;
  }
  let result = "";
  if (type === "_reserves" && (before.configuration?.data || after.configuration?.data)) {
    before.configuration.data_decoded = getDecodedReserveData(address, before.configuration.data);
    after.configuration.data_decoded = getDecodedReserveData(address, after.configuration.data);
  }
  if (type === "_eModeCategories") {
    if (before.collateralBitmap !== void 0) {
      before.collateralBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(before.collateralBitmap || 0))
      )).toString();
      before.collateralBitmap = toBinaryString(BigInt(before.collateralBitmap || 0));
      after.collateralBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(after.collateralBitmap || 0))
      )).toString();
      after.collateralBitmap = toBinaryString(BigInt(after.collateralBitmap || 0));
    }
    if (before.borrowableBitmap !== void 0) {
      before.borrowableBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(before.borrowableBitmap || 0))
      )).toString();
      before.borrowableBitmap = toBinaryString(BigInt(before.borrowableBitmap || 0));
      after.borrowableBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(after.borrowableBitmap || 0))
      )).toString();
      after.borrowableBitmap = toBinaryString(BigInt(after.borrowableBitmap || 0));
    }
  }
  if (type === "_streams") {
    const asset = await findAsset(client, after.tokenAddress);
    after.ratePerSecond = prettifyNumber({
      decimals: asset.decimals,
      value: after.ratePerSecond,
      showDecimals: true
    });
    after.remainingBalance = prettifyNumber({
      showDecimals: true,
      decimals: asset.decimals,
      value: after.remainingBalance
    });
  }
  for (const key of Object.keys(before)) {
    if (before[key] === after[key]) continue;
    const newAccessChain = [...accessChain];
    newAccessChain.push(key);
    if (typeof before[key] === "object") {
      result += await deepDiff({
        client,
        address,
        before: before[key],
        after: after[key],
        accessChain: newAccessChain,
        type
      });
    } else
      result += `@@ ${type ? `${wrapInQuotes(type, true)} key ` : ""}${wrapInQuotes(
        resolveChain([...accessChain, key]),
        !!type
      )} @@
- ${await enhanceValue({
        client,
        address,
        value: before[key],
        type,
        accessChain: newAccessChain
      })}
+ ${await enhanceValue({
        client,
        address,
        value: after[key],
        type,
        accessChain: newAccessChain
      })}
`;
  }
  return result;
}
async function enhanceValue({
  client,
  address,
  value,
  type,
  accessChain
}) {
  const key = accessChain[accessChain?.length - 1];
  if (key === "tokenAddress") {
    return addAssetSymbol(client, value);
  }
  if (type) {
    if (type === "assetsSources") {
      return addAssetPrice(client, value);
    }
    if ([
      "_balances",
      "balanceOf",
      "balances",
      "allowed",
      "_allowances",
      "allowance",
      "_totalSupply"
    ].includes(type)) {
      const asset = await findAsset(client, address);
      if (asset) return prettifyNumber({ decimals: asset.decimals, value, showDecimals: true });
    }
    if (key && ["_reserves", "_eModeCategories"].includes(type)) {
      if (["liquidityIndex", "variableBorrowIndex"].includes(key))
        return prettifyNumber({ decimals: 27, value, showDecimals: true });
      if (["liquidationThreshold", "reserveFactor", "liquidationProtocolFee", "ltv"].includes(key))
        return prettifyNumber({ decimals: 2, value, suffix: "%", showDecimals: true });
      if (["currentLiquidityRate", "currentVariableBorrowRate", "currentStableBorrowRate"].includes(
        key
      ))
        return prettifyNumber({ decimals: 25, value, suffix: "%", showDecimals: true });
      if (["liquidationBonus"].includes(key))
        return prettifyNumber({
          decimals: 2,
          value,
          suffix: "%",
          showDecimals: true,
          patchedValue: BigInt(value) == 0n ? 0n : BigInt(value) - BigInt(1e4)
        });
    }
  }
  return value;
}
var checkStateChanges = {
  name: "Reports all state changes",
  async checkProposal(proposal, simulation, client) {
    const info = [];
    const warnings = [];
    const errors = [];
    if (!simulation.transaction.status) {
      const txInfo = simulation.transaction.transaction_info;
      const reason = txInfo.stack_trace ? txInfo.stack_trace[0].error_reason : "unknown error";
      errors.push(`Transaction reverted with reason: ${reason}`);
    } else {
      const stateDiffs = simulation.transaction.transaction_info.state_diff.reduce(
        (diffs, diff2) => {
          if (!diff2.raw?.[0]) return diffs;
          const addr = getAddress4(diff2.raw[0].address);
          if (!diffs[addr]) diffs[addr] = [diff2];
          else diffs[addr].push(diff2);
          return diffs;
        },
        {}
      );
      if (!Object.keys(stateDiffs).length) {
        warnings.push("No state changes detected");
      } else {
        let stateChanges = "";
        const warnings2 = "";
        for (const [address, diffs] of Object.entries(stateDiffs)) {
          const changes = getContractChanges(diffs);
          stateChanges += await renderContractChanges(simulation, client, address, changes);
        }
        info.push(stateChanges);
      }
    }
    return { info, warnings, errors };
  }
};
function toBinaryString(value) {
  return `0b` + value.toString(2);
}

// src/govv3/checks/targetsVerified.ts
import { getBytecode as getBytecode2 } from "viem/actions";
var checkTargetsVerifiedEtherscan = {
  name: "Check all targets are verified on Etherscan",
  async checkProposal(proposal, sim, client) {
    const allTargets = proposal.payload.actions.map((action) => action.target);
    const uniqueTargets = allTargets.filter((addr, i, targets) => targets.indexOf(addr) === i);
    const info = await checkVerificationStatuses(sim, uniqueTargets, client);
    return { info, warnings: [], errors: [] };
  }
};
var checkTouchedContractsVerifiedEtherscan = {
  name: "Check all touched contracts are verified on Etherscan",
  async checkProposal(proposal, sim, client) {
    const info = await checkVerificationStatuses(sim, sim.transaction.addresses, client);
    return { info, warnings: [], errors: [] };
  }
};
async function checkVerificationStatuses(sim, addresses2, client) {
  const info = [];
  for (const addr of addresses2) {
    const isAddrKnown = isKnownAddress(addr, client.chain.id);
    const status = await checkVerificationStatus(sim, addr, client);
    if (status === "eoa") {
      info.push(`- ${addr}: EOA (verification not applicable)`);
    } else if (status === "verified") {
      const contract = getContract3(sim, addr);
      info.push(
        `- ${addr}: Contract (verified) (${contract?.contract_name}) ${flagKnownAddress(isAddrKnown)}`
      );
    } else {
      info.push(`- ${addr}: Contract (not verified) ${flagKnownAddress(isAddrKnown)}`);
    }
  }
  return info;
}
async function checkVerificationStatus(sim, addr, client) {
  const contract = getContract3(sim, addr);
  if (contract) return "verified";
  const stateDiff = getStateDiff(sim, addr);
  if (stateDiff) return "unverified";
  const code = await getBytecode2(client, { address: addr });
  return code === void 0 ? "eoa" : "unverified";
}
function getContract3(sim, addr) {
  return sim.contracts.find((item) => item.address === addr);
}
function getStateDiff(sim, addr) {
  return sim.transaction.transaction_info.state_diff?.find(
    (diff2) => diff2.raw?.[0]?.address.toLowerCase() === addr.toLowerCase()
  );
}

// src/govv3/payloadsController.ts
import { IPayloadsControllerCore_ABI } from "@bgd-labs/aave-address-book/abis";
import {
  encodeFunctionData,
  encodePacked,
  getContract as getContract4
} from "viem";
import { getBlock as getBlock2, getTransaction } from "viem/actions";

// src/utils/tenderlyClient.ts
import {
  http as http2,
  createClient as createClient2,
  fromHex as fromHex2,
  getContractAddress,
  pad as pad2,
  parseEther,
  toHex as toHex2
} from "viem";
import { deployContract, getBlock, getTransactionReceipt, sendTransaction } from "viem/actions";
var Tenderly = class {
  TENDERLY_BASE = "https://api.tenderly.co/api/v1";
  ACCESS_TOKEN;
  ACCOUNT;
  PROJECT;
  constructor(accessToken, account, project) {
    this.ACCESS_TOKEN = accessToken;
    this.ACCOUNT = account;
    this.PROJECT = project;
  }
  trace = async (chainId, txHash) => {
    const response = await fetch(
      `${this.TENDERLY_BASE}/public-contract/${chainId}/trace/${txHash}`,
      {
        method: "GET",
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
    const result = await response.json();
    return result;
  };
  simulate = async (request, client) => {
    if (!request.state_objects) {
      request.state_objects = {};
    }
    if (!request.state_objects[request.from]) {
      request.state_objects[request.from] = {
        balance: String(parseEther("3"))
      };
    } else {
      request.state_objects[request.from].balance = String(parseEther("3"));
    }
    let apiUrl = `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/simulate`;
    if (client) {
      const url = client.transport.url;
      const tenderlyForkRegex = new RegExp(/https:\/\/rpc.tenderly.co\/fork\/(.*)/);
      if (tenderlyForkRegex.test(url)) {
        const matches = url.match(tenderlyForkRegex);
        if (matches) {
          const fork = await this.getForkInfo(matches[1]);
          request.root = fork.global_head;
          delete request.network_id;
          apiUrl = `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/fork/${matches[1]}/simulate`;
        }
      }
    }
    const fullRequest = JSON.stringify({
      generate_access_list: true,
      save: true,
      gas_price: "0",
      gas: 3e7,
      force_import_contracts: true,
      ...request
    });
    logInfo("tenderly", `request: ${JSON.stringify(fullRequest)}`);
    const response = await fetch(apiUrl, {
      method: "POST",
      body: fullRequest,
      headers: new Headers({
        "Content-Type": "application/json",
        "X-Access-Key": this.ACCESS_TOKEN
      })
    });
    if (response.status !== 200) {
      console.log(await response.text());
      throw new Error(`TenderlyError: ${response.statusText}`);
    }
    return await response.json();
  };
  /**
   * Fork api to get fork information from an existing fork id
   * @param project name of the Tenderly project where the fork was created
   * @param forkId id of the fork created in tenderly
   * @returns fork object
   */
  getForkInfo = async (forkId, project) => {
    const response = await fetch(
      `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${project || this.PROJECT}/fork/${forkId}`,
      {
        method: "GET",
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
    if (response.status >= 400) {
      console.log(await response.text());
      throw new Error(`TenderlyError: ${response.statusText}`);
    }
    const result = await response.json();
    const fork = {
      id: result.simulation_fork.id,
      chainId: result.simulation_fork.network_id,
      block_number: result.simulation_fork.block_number,
      forkNetworkId: result.simulation_fork.chain_config.chain_id,
      forkUrl: `https://rpc.tenderly.co/fork/${result.simulation_fork.id}`,
      global_head: result.simulation_fork.global_head
    };
    return fork;
  };
  /**
   * Trace api lacks most information we need, so simulateTx uses the simulation api to replicate the trace.
   * @param chainId
   * @param tx
   * @returns
   */
  simulateTx = async (chainId, tx) => {
    const simulationPayload = {
      network_id: String(chainId),
      from: tx.from,
      to: tx.to,
      block_number: Number(tx.blockNumber),
      input: tx.input
    };
    return this.simulate(simulationPayload);
  };
  fork = async ({
    chainId,
    blockNumber,
    alias,
    forkChainId = 3030
  }) => {
    const forkingPoint = {
      network_id: chainId,
      chain_config: { chain_id: forkChainId }
    };
    if (blockNumber) forkingPoint.block_number = blockNumber;
    if (alias) forkingPoint.alias = alias;
    const response = await fetch(
      `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/fork`,
      {
        method: "POST",
        body: JSON.stringify(forkingPoint),
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
    const result = await response.json();
    if (result.error) {
      logError("tenderly", "fork could not be created");
      throw new Error(result.error.message);
    }
    const fork = {
      id: result.simulation_fork.id,
      chainId: result.simulation_fork.network_id,
      block_number: result.simulation_fork.block_number,
      forkNetworkId: result.simulation_fork.chain_config.chain_id,
      forkUrl: `https://rpc.tenderly.co/fork/${result.simulation_fork.id}`,
      global_head: result.simulation_fork.global_head
    };
    logSuccess(
      "tenderly",
      `Fork created! To use in aave interface you need to run the following commands:

---
localStorage.setItem('forkEnabled', 'true');
localStorage.setItem('forkBaseChainId', ${fork.chainId});
localStorage.setItem('forkNetworkId', ${fork.forkNetworkId});
localStorage.setItem("forkRPCUrl", "${fork.forkUrl}");
---
`
    );
    return fork;
  };
  deployCode = async (fork, filePath, from) => {
    const walletProvider = createClient2({
      account: from || EOA,
      chain: { id: fork.forkNetworkId, name: "tenderly" },
      transport: http2(fork.forkUrl)
    });
    const artifact = __require(filePath);
    logInfo("tenderly", `deploying ${filePath}`);
    const hash = await deployContract(walletProvider, {
      abi: artifact.abi,
      bytecode: artifact.bytecode.object,
      account: walletProvider.account
    });
    const receipt = await getTransactionReceipt(walletProvider, { hash });
    return getContractAddress({ from: receipt.from, nonce: receipt.nonce });
  };
  warpTime = async (fork, timestamp) => {
    const client = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    const currentBlock = await getBlock(client);
    if (timestamp > currentBlock.timestamp) {
      logInfo("tenderly", `warping time from ${currentBlock.timestamp} to ${timestamp}`);
      await client.request({
        method: "evm_increaseTime",
        params: [toHex2(timestamp - currentBlock.timestamp)]
      });
    } else {
      logWarning(
        "tenderly",
        `skipping time warp as tenderly forks do not support traveling back in time (from ${currentBlock.timestamp} to ${timestamp})`
      );
    }
  };
  warpBlocks = async (fork, blockNumber) => {
    const client = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    const currentBlock = await getBlock(client);
    if (blockNumber > currentBlock.number) {
      logInfo("tenderly", `warping blocks from ${currentBlock.number} to ${blockNumber}`);
      await client.request({
        method: "evm_increaseBlocks",
        params: [toHex2(blockNumber - currentBlock.number)]
      });
    } else {
      logWarning(
        "tenderly",
        "skipping block warp as tenderly forks do not support traveling back in time"
      );
    }
  };
  unwrapAndExecuteSimulationPayloadOnFork = async (fork, request) => {
    await this.fundAccount(fork, request.from);
    const publicProvider = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    if (request.state_objects) {
      logInfo("tenderly", "setting storage");
      for (const address of Object.keys(request.state_objects)) {
        if (request.state_objects[address].storage) {
          for (const slot of Object.keys(request.state_objects[address].storage)) {
            await publicProvider.request({
              method: "tenderly_setStorageAt",
              params: [
                address,
                pad2(slot, { size: 32 }),
                pad2(request.state_objects[address].storage[slot], {
                  size: 32
                })
              ]
            });
          }
        }
      }
    }
    if (request.block_header?.timestamp) {
      await this.warpTime(fork, fromHex2(request.block_header?.timestamp, "bigint"));
    }
    if (request.block_header?.number) {
      await this.warpBlocks(fork, fromHex2(request.block_header?.number, "bigint"));
    }
    if (request.input) {
      logInfo("tenderly", "execute transaction");
      const walletProvider = createClient2({
        account: request.from,
        chain: { id: fork.forkNetworkId, name: "tenderly" },
        transport: http2(fork.forkUrl)
      });
      const hash = await sendTransaction(walletProvider, {
        data: request.input,
        to: request.to,
        value: request.value || 0n
      });
      const receipt = await getTransactionReceipt(walletProvider, { hash });
      if (receipt.status === "success") {
        logSuccess("tenderly", "transaction successfully executed");
      } else {
        logError("tenderly", "transaction reverted");
      }
      return hash;
    }
  };
  fundAccount = (fork, address) => {
    logInfo("tenderly", "fund account");
    return fetch(
      `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/fork/${fork.id}/balance`,
      {
        method: "POST",
        body: JSON.stringify({ accounts: [address], amount: 1e3 }),
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
  };
  replaceCode = (fork, address, code) => {
    const publicProvider = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    return publicProvider.request({
      method: "tenderly_setCode",
      params: [address, code]
    });
  };
};
var tenderly = new Tenderly(
  process.env.TENDERLY_ACCESS_TOKEN,
  process.env.TENDERLY_ACCOUNT,
  process.env.TENDERLY_PROJECT_SLUG
);

// src/govv3/payloadsController.ts
import { PayloadState } from "@bgd-labs/aave-v3-governance-cache";
var HUMAN_READABLE_PAYLOAD_STATE = {
  [PayloadState.None]: "None",
  [PayloadState.Created]: "Created",
  [PayloadState.Queued]: "Queued",
  [PayloadState.Executed]: "Executed",
  [PayloadState.Cancelled]: "Cancelled",
  [PayloadState.Expired]: "Expired"
};
var SLOTS = {
  PAYLOADS_MAPPING: 3n
};
var getPayloadsController = (address, client) => {
  const controllerContract = getContract4({
    abi: IPayloadsControllerCore_ABI,
    address,
    client
  });
  const getSimulationPayloadForExecution = async (id) => {
    const payload = await controllerContract.read.getPayloadById([id]);
    const currentBlock = await getBlock2(client);
    const simulationPayload = {
      network_id: String(client.chain.id),
      from: EOA,
      to: controllerContract.address,
      input: encodeFunctionData({
        abi: IPayloadsControllerCore_ABI,
        functionName: "executePayload",
        args: [id]
      }),
      block_number: -2,
      state_objects: {
        [controllerContract.address]: {
          storage: {
            [getSolidityStorageSlotUint(SLOTS.PAYLOADS_MAPPING, BigInt(id))]: encodePacked(
              ["uint40", "uint40", "uint8", "uint8", "address"],
              [
                // we subtract 240n(4min), as tenderly might have been fallen behind
                // therefore using block_number -1 (latest on tenderly) and a 4min margin should give a save margin
                Number(currentBlock.timestamp - BigInt(payload.delay) - 1n - 240n),
                // altering queued time so can be executed in current block
                payload.createdAt,
                PayloadState.Queued,
                payload.maximumAccessLevelRequired,
                payload.creator
              ]
            )
          }
        }
      }
    };
    return simulationPayload;
  };
  return {
    controllerContract,
    getSimulationPayloadForExecution,
    simulatePayloadExecutionOnTenderly: async (id, { executedLog }) => {
      if (executedLog) {
        const tx = await getTransaction(client, {
          hash: executedLog.transactionHash
        });
        return tenderly.simulateTx(client.chain.id, tx);
      }
      const payload = await getSimulationPayloadForExecution(id);
      return tenderly.simulate(payload, client);
    }
  };
};

// src/govv3/generatePayloadReport.ts
async function generateReport({
  payloadId,
  payloadInfo,
  simulation,
  client
}) {
  const {
    payload,
    logs: { executedLog, queuedLog, createdLog }
  } = payloadInfo;
  let report = `## Payload ${payloadId} on ${client.chain.name}

- Simulation: [https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id}](https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id})
- creator: ${payload.creator}
- maximumAccessLevelRequired: ${payload.maximumAccessLevelRequired}
- state: ${payload.state}(${HUMAN_READABLE_PAYLOAD_STATE[payload.state]})
- actions: ${JSON.stringify(payload.actions, (key, value) => typeof value === "bigint" ? value.toString() : value)}
- createdAt: [${renderUnixTime(payload.createdAt)}](${toTxLink(createdLog.transactionHash, false, client)})
`;
  if (queuedLog) {
    report += `- queuedAt: [${renderUnixTime(payload.queuedAt)}](${toTxLink(
      queuedLog.transactionHash,
      false,
      client
    )})
`;
    if (executedLog) {
      report += `- executedAt: [${renderUnixTime(payload.executedAt)}, timestamp: ${executedLog.timestamp}, block: ${executedLog.blockNumber}](${toTxLink(
        executedLog.transactionHash,
        false,
        client
      )})
`;
    } else {
      report += `- earliest execution at: [${renderUnixTime(
        payload.queuedAt + payload.delay
      )}](https://www.epochconverter.com/countdown?q=${payload.queuedAt + payload.delay})
`;
      const timestamp = Math.floor(new Date(simulation.transaction.timestamp).getTime() / 1e3);
      report += `- simulatedExecutionAt: ${renderUnixTime(
        timestamp
      )}, timestamp: ${timestamp}, block: ${simulation.transaction.block_number}`;
    }
  }
  report += "\n";
  const checks = [
    checkStateChanges,
    checkLogs,
    checkTargetsVerifiedEtherscan,
    checkTouchedContractsVerifiedEtherscan,
    checkTargetsNoSelfdestruct,
    checkTouchedContractsNoSelfdestruct
  ];
  for (const check of checks) {
    const result = await check.checkProposal(payloadInfo, simulation, client);
    report += renderCheckResult(check, result);
  }
  return report;
}

// src/govv3/governance.ts
import { AaveSafetyModule as AaveSafetyModule2, AaveV3Ethereum as AaveV3Ethereum2, GovernanceV3Ethereum as GovernanceV3Ethereum3 } from "@bgd-labs/aave-address-book";
import { IGovernanceCore_ABI } from "@bgd-labs/aave-address-book/abis";
import merge from "deepmerge";
import {
  encodeFunctionData as encodeFunctionData2,
  fromHex as fromHex3,
  getContract as getContract5,
  toHex as toHex4
} from "viem";
import { getBlock as getBlock4, getStorageAt, getTransaction as getTransaction2 } from "viem/actions";

// src/govv3/proofs.ts
import { AaveSafetyModule, AaveV3Ethereum, GovernanceV3Ethereum as GovernanceV3Ethereum2 } from "@bgd-labs/aave-address-book";
import {
  fromRlp,
  toHex as toHex3,
  toRlp
} from "viem";
import { getBlock as getBlock3, getProof as viemGetProof } from "viem/actions";
var WAREHOUSE_SLOTS = {
  [AaveSafetyModule.STK_AAVE]: {
    exchangeRate: 81n
    // exchangeRate
  }
};
var VOTING_SLOTS = {
  [AaveSafetyModule.STK_AAVE]: { balance: 0n },
  // balance
  [AaveV3Ethereum.ASSETS.AAVE.A_TOKEN]: {
    balance: 52n,
    // balance
    delegation: 64n
  },
  // delegation
  [AaveV3Ethereum.ASSETS.AAVE.UNDERLYING]: { balance: 0n },
  // balance
  [GovernanceV3Ethereum2.GOVERNANCE]: { representative: 9n }
  // representative
};
async function getProof(client, address, slots, blockHash) {
  const block = await getBlock3(client, { blockHash });
  return viemGetProof(client, {
    address,
    storageKeys: slots.map((slot) => slot),
    blockNumber: block.number
  });
}
var getAccountRPL = (proof) => {
  return toRlp(proof.map((rpl) => fromRlp(rpl, "hex")));
};

// src/govv3/governance.ts
import { ProposalState } from "@bgd-labs/aave-v3-governance-cache";
var SLOTS2 = {
  PROPOSALS_MAPPING: 7n
};
var HUMAN_READABLE_STATE = {
  [ProposalState.Null]: "Null",
  [ProposalState.Created]: "Created",
  [ProposalState.Active]: "Active",
  [ProposalState.Queued]: "Queued",
  [ProposalState.Executed]: "Executed",
  [ProposalState.Failed]: "Failed",
  [ProposalState.Cancelled]: "Cancelled",
  [ProposalState.Expired]: "Expired"
};
var getGovernance = ({ address, client }) => {
  const governanceContract = getContract5({
    abi: IGovernanceCore_ABI,
    address,
    client
  });
  async function getProposal(proposalId) {
    return governanceContract.read.getProposal([proposalId]);
  }
  async function getSimulationPayloadForExecution(proposalId) {
    const currentBlock = await getBlock4(client);
    const proposalSlot = getSolidityStorageSlotUint(SLOTS2.PROPOSALS_MAPPING, proposalId);
    const data = await getStorageAt(client, {
      address: governanceContract.address,
      slot: proposalSlot
    });
    let proposalSlot1 = fromHex3(data, { to: "bigint" });
    proposalSlot1 = setBits(proposalSlot1, 0n, 8n, ProposalState.Queued);
    proposalSlot1 = setBits(
      proposalSlot1,
      16n,
      56n,
      currentBlock.timestamp - await governanceContract.read.PROPOSAL_EXPIRATION_TIME()
    );
    const simulationPayload = {
      network_id: String(client.chain.id),
      from: EOA,
      to: governanceContract.address,
      input: encodeFunctionData2({
        abi: IGovernanceCore_ABI,
        functionName: "executeProposal",
        args: [proposalId]
      }),
      // value: parseEther('0.5').toString(),
      block_number: -2,
      state_objects: {
        [governanceContract.address]: {
          storage: {
            [proposalSlot]: toHex4(proposalSlot1, { size: 32 })
            // state & time
            // [toHex(fromHex(proposalSlot, { to: 'bigint' }) + 5n)]: toHex(parseUnits('340000000', 18), {
            //   size: 32,
            // }), // votes (not needed as there's no validation for this at this point)
          }
        }
      }
    };
    return simulationPayload;
  }
  return {
    governanceContract,
    getSimulationPayloadForExecution,
    async simulateProposalExecutionOnTenderly(proposalId, { executedLog }) {
      if (executedLog) {
        const tx = await getTransaction2(client, {
          hash: executedLog.transactionHash
        });
        return tenderly.simulateTx(client.chain.id, tx);
      }
      const payload = await getSimulationPayloadForExecution(proposalId);
      return tenderly.simulate(payload, client);
    },
    async getVotingProofs(proposalId, voter, votingChainId) {
      const proposal = await getProposal(proposalId);
      const [stkAaveProof, aaveProof, aAaveProof, representativeProof] = await Promise.all([
        getProof(
          client,
          AaveSafetyModule2.STK_AAVE,
          [getSolidityStorageSlotAddress(VOTING_SLOTS[AaveSafetyModule2.STK_AAVE].balance, voter)],
          proposal.snapshotBlockHash
        ),
        getProof(
          client,
          AaveV3Ethereum2.ASSETS.AAVE.UNDERLYING,
          [
            getSolidityStorageSlotAddress(
              VOTING_SLOTS[AaveV3Ethereum2.ASSETS.AAVE.UNDERLYING].balance,
              voter
            )
          ],
          proposal.snapshotBlockHash
        ),
        getProof(
          client,
          AaveV3Ethereum2.ASSETS.AAVE.A_TOKEN,
          [
            getSolidityStorageSlotAddress(
              VOTING_SLOTS[AaveV3Ethereum2.ASSETS.AAVE.A_TOKEN].balance,
              voter
            ),
            getSolidityStorageSlotAddress(
              VOTING_SLOTS[AaveV3Ethereum2.ASSETS.AAVE.A_TOKEN].delegation,
              voter
            )
          ],
          proposal.snapshotBlockHash
        ),
        getProof(
          client,
          GovernanceV3Ethereum3.GOVERNANCE,
          [
            getSolidityStorageSlotBytes(
              getSolidityStorageSlotAddress(
                VOTING_SLOTS[GovernanceV3Ethereum3.GOVERNANCE].representative,
                voter
              ),
              toHex4(votingChainId, { size: 32 })
            )
          ],
          proposal.snapshotBlockHash
        )
      ]);
      return [
        { proof: stkAaveProof, slots: [0n] },
        { proof: aaveProof, slots: [0n] },
        { proof: aAaveProof, slots: [52n, 64n] },
        { proof: representativeProof, slots: [9n] }
      ].flatMap(({ proof, slots }) => {
        return slots.filter((slot, ix) => {
          const shouldSubmitProof = proof.storageProof[ix].value !== 0n;
          if (!shouldSubmitProof)
            logInfo(
              "Proof",
              `Skipping slot ${slot} on ${proof.address} as value is zero for voter ${voter}`
            );
          return shouldSubmitProof;
        }).map((slot, ix) => ({
          underlyingAsset: proof.address,
          slot,
          proof: getAccountRPL(proof.storageProof[ix].proof)
        }));
      });
    },
    async getStorageRoots(proposalId) {
      const proposal = await getProposal(proposalId);
      const addresses2 = merge(VOTING_SLOTS, WAREHOUSE_SLOTS);
      const proofs = await Promise.all(
        Object.keys(addresses2).map(
          (address2) => getProof(
            client,
            address2,
            Object.keys(addresses2[address2]).map(
              (slotKey) => toHex4(addresses2[address2][slotKey])
            ),
            proposal.snapshotBlockHash
          )
        )
      );
      return proofs;
    }
  };
};

// src/govv3/generateProposalReport.ts
async function generateProposalReport({
  proposalId,
  proposalInfo,
  simulation,
  client,
  formattedPayloads
}) {
  const {
    proposal,
    logs: { executedLog, queuedLog, createdLog, payloadSentLog, votingActivatedLog },
    ipfs
  } = proposalInfo;
  let report = `## Proposal ${proposalId}

- Simulation: [https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id}](https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id})
- state: ${HUMAN_READABLE_STATE[proposal.state]}
- creator: ${proposal.creator}
- maximumAccessLevelRequired: ${proposal.accessLevel}
- payloads: 
  ${formattedPayloads ? formattedPayloads.map((payload) => `  - ${payload}
`).join() : JSON.stringify(
    proposal.payloads,
    (key, value) => typeof value === "bigint" ? value.toString() : value
  )}
- createdAt: [${renderUnixTime(proposal.creationTime)}](${toTxLink(createdLog.transactionHash, false, client)})
`;
  if (queuedLog) {
    report += `- queuedAt: [${renderUnixTime(proposal.queuingTime)}](${toTxLink(
      queuedLog.transactionHash,
      false,
      client
    )})
`;
  }
  if (executedLog) {
    report += `- executedAt: [${renderUnixTime(executedLog.timestamp)}, timestamp: ${executedLog.timestamp}, block: ${executedLog.blockNumber}](${toTxLink(
      executedLog.transactionHash,
      false,
      client
    )})
`;
  } else {
    const timestamp = Math.floor(new Date(simulation.transaction.timestamp).getTime() / 1e3);
    report += `- simulatedExecutionAt: ${renderUnixTime(
      timestamp
    )}, timestamp: ${timestamp}, block: ${simulation.transaction.block_number}`;
  }
  report += "\n";
  report += `### Ipfs

<details>
  <summary>${ipfs?.title || "problem fetching ipfs metadata"}</summary>
  
  ${ipfs?.description || "problem fetching ipfs metadata"}
</details>

`;
  const checks = [
    checkStateChanges,
    checkLogs,
    checkTouchedContractsVerifiedEtherscan,
    checkTouchedContractsNoSelfdestruct
  ];
  for (const check of checks) {
    const result = await check.checkProposal(proposalInfo, simulation, client);
    report += renderCheckResult(check, result);
  }
  return report;
}

// src/govv3/simulate.ts
import { refreshCache } from "@bgd-labs/aave-v3-governance-cache/refreshCache";
import { customStorageProvider } from "@bgd-labs/aave-v3-governance-cache/customStorageProvider";
import { fileSystemStorageAdapter } from "@bgd-labs/aave-v3-governance-cache/fileSystemStorageAdapter";
var localCacheAdapter = customStorageProvider(fileSystemStorageAdapter);
async function simulateProposal(governanceAddress, client, proposalId) {
  logInfo("General", `Running simulation for ${proposalId}`);
  const governance = getGovernance({ address: governanceAddress, client });
  await refreshCache(localCacheAdapter);
  const proposal = await localCacheAdapter.getProposal({
    chainId: client.chain.id,
    governance: governanceAddress,
    proposalId
  });
  const result = await governance.simulateProposalExecutionOnTenderly(proposalId, proposal.logs);
  console.log(
    await generateProposalReport({
      simulation: result,
      proposalId,
      proposalInfo: proposal,
      client
    })
  );
  const payloads = [];
  for (const payload of proposal.proposal.payloads) {
    const client2 = getClient(Number(payload.chain));
    const controllerContract = getPayloadsController(payload.payloadsController, client2);
    const cache = await localCacheAdapter.getPayload({
      payloadId: payload.payloadId,
      chainId: Number(payload.chain),
      payloadsController: payload.payloadsController
    });
    try {
      const result2 = await controllerContract.simulatePayloadExecutionOnTenderly(
        payload.payloadId,
        cache.logs
      );
      console.log(
        await generateReport({
          simulation: result2,
          payloadId: payload.payloadId,
          payloadInfo: cache,
          client: getClient(Number(payload.chain))
        })
      );
      payloads.push({ payload: cache, simulation: result2 });
    } catch (e) {
      console.log("error simulating payload");
      console.log(e);
    }
  }
  return { proposal, payloads };
}
export {
  HUMAN_READABLE_PAYLOAD_STATE,
  HUMAN_READABLE_STATE,
  assetIndexesToAsset,
  diffReports,
  findAsset,
  findPayloadsController,
  generateProposalReport,
  generateReport,
  getGovernance,
  getPayloadsController,
  isKnownAddress,
  logError,
  logInfo,
  logSuccess,
  logVerbose,
  logWarning,
  simulateProposal,
  tenderly
};
/**
 * Highly inspired by - reimplemented a bit simpler & added types
 * @license MIT https://github.com/omgaz/diffler
 * Author: Gary Chisholm @omgaz
 */
//# sourceMappingURL=index.js.map