#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports, module) {
    "use strict";
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// src/cli.ts
import { Command, Option } from "@commander-js/extra-typings";
import "dotenv/config";

// package.json
var package_default = {
  name: "@bgd-labs/aave-cli",
  version: "1.1.12",
  description: "A cli to perform various aave governance related tasks",
  private: false,
  sideEffects: false,
  files: [
    "dist"
  ],
  scripts: {
    start: "bun src/cli.ts",
    build: "tsup",
    test: "vitest",
    "lint:fix": "bunx prettier . --write",
    lint: "bunx prettier . --check",
    prepublishOnly: "npm run build"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/bgd-labs/report-engine.git"
  },
  author: "BGD labs",
  license: "MIT",
  bugs: {
    url: "https://github.com/bgd-labs/report-engine/issues"
  },
  homepage: "https://github.com/bgd-labs/report-engine#readme",
  devDependencies: {
    "@types/object-hash": "^3.0.6",
    prettier: "^3.2.5",
    "prettier-plugin-solidity": "^1.4.1",
    tsup: "^8.3.5",
    typescript: "^5.4.5",
    vitest: "^2.1.5"
  },
  type: "module",
  main: "./dist/index.js",
  module: "./dist/index.js",
  exports: {
    ".": {
      require: {
        types: "./dist/index.d.cts",
        default: "./dist/index.cjs"
      },
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      types: "./dist/index.d.cts",
      default: "./dist/index.cjs"
    }
  },
  bin: {
    "aave-cli": "dist/cli.js"
  },
  publishConfig: {
    access: "public"
  },
  dependencies: {
    "@bgd-labs/aave-address-book": "^4.5.1",
    "@bgd-labs/aave-v3-governance-cache": "^1.0.8",
    "@bgd-labs/js-utils": "^1.4.6",
    "@bgd-labs/rpc-env": "^2.1.1",
    "@commander-js/extra-typings": "^12.1.0",
    "@inquirer/prompts": "^7.1.0",
    "blockstore-core": "^5.0.2",
    chalk: "^4.1.2",
    commander: "^12.1.0",
    deepmerge: "^4.3.1",
    dotenv: "^16.4.1",
    "find-object-paths": "^1.1.0",
    "gray-matter": "^4.0.3",
    "ipfs-unixfs-importer": "^15.3.1",
    "json-bigint": "^1.0.0",
    viem: "^2.21.48",
    zod: "^3.23.8"
  }
};

// src/commands/diffSnaphots.ts
import fs2 from "node:fs";
import path2 from "node:path";
import { compareStorageLayouts } from "@bgd-labs/js-utils";

// src/reports/diff.ts
function diff(a, b, removeUnchanged) {
  const out = {};
  for (const key in a) {
    if (!b.hasOwnProperty(key)) {
      out[key] = { from: a[key], to: null };
    } else {
      if (typeof a[key] === "object") {
        const tempDiff = diff(a[key], b[key], removeUnchanged);
        if (Object.keys(tempDiff).length > 0) {
          out[key] = tempDiff;
        }
      } else {
        if (b[key] === a[key]) {
          if (!removeUnchanged) out[key] = a[key];
        } else {
          out[key] = { from: a[key], to: b[key] };
        }
      }
    }
  }
  for (const key in b) {
    if (a.hasOwnProperty(key)) continue;
    out[key] = { from: null, to: b[key] };
  }
  return out;
}

// src/reports/adi-diff-reports.ts
async function adiDiffReports(pre, post) {
  const chainId = pre.chainId;
  const diffResult = diff(pre, post);
  let content = "";
  content += `## Raw diff

\`\`\`json
${JSON.stringify(diff(pre, post, true), null, 2)}
\`\`\``;
  return content;
}

// src/reports/diff-reports.ts
import { writeFileSync } from "fs";

// src/reports/emode.ts
import { formatUnits } from "viem";

// src/utils/storageSlots.ts
import {
  concat,
  encodeAbiParameters,
  fromHex,
  keccak256,
  pad,
  parseAbiParameters,
  toBytes,
  toHex,
  trim
} from "viem";
function getSolidityStorageSlotBytes(mappingSlot, key) {
  const slot = pad(mappingSlot, { size: 32 });
  return trim(
    keccak256(encodeAbiParameters(parseAbiParameters("bytes32, uint256"), [key, BigInt(slot)]))
  );
}
function getSolidityStorageSlotUint(mappingSlot, key) {
  return keccak256(encodeAbiParameters(parseAbiParameters("uint256, uint256"), [key, mappingSlot]));
}
function getSolidityStorageSlotAddress(mappingSlot, key) {
  return keccak256(
    encodeAbiParameters(parseAbiParameters("address, uint256"), [key, BigInt(mappingSlot)])
  );
}
function getBits(_bigIntValue, startBit, _endBit) {
  let endBit = _endBit;
  const bigIntValue = BigInt(_bigIntValue);
  if (startBit > endBit) {
    throw new Error("Invalid bit range: startBit must be less than or equal to endBit");
  }
  const bitLength = BigInt(bigIntValue.toString(2)).toString().length;
  if (endBit >= bitLength) {
    endBit = BigInt(bitLength - 1);
  }
  const mask = (1n << endBit - startBit + 1n) - 1n;
  const maskedValue = bigIntValue >> startBit & mask;
  return maskedValue.toString();
}
function setBits(_bigIntBase, startBit, endBit, _replaceValue) {
  const bigIntBase = BigInt(_bigIntBase);
  const bigIntReplaceValue = BigInt(_replaceValue);
  let mask = BigInt(0);
  for (let i = startBit; i < endBit; i++) {
    mask |= BigInt(1) << BigInt(i);
  }
  const clearedNumber = bigIntBase & ~mask;
  const result = clearedNumber | bigIntReplaceValue << BigInt(startBit);
  return result;
}
function bitMapToIndexes(bitmap) {
  const reserveIndexes = [];
  for (let i = 0; bitmap != 0n; i++) {
    if (bitmap & 0x1n) reserveIndexes.push(i);
    bitmap = bitmap >> 1n;
  }
  return reserveIndexes;
}

// src/reports/emode.ts
function renderEModeValue(key, emode, snapshot) {
  if (!emode[key]) return "-";
  if (["reserveFactor", "liquidationProtocolFee", "liquidationThreshold", "ltv"].includes(key))
    return `${formatUnits(BigInt(emode[key]), 2)} %`;
  if (key === "liquidationBonus")
    return emode[key] === 0 ? "0 %" : `${(emode[key] - 1e4) / 100} %`;
  if (key === "borrowableBitmap" || key === "collateralBitmap") {
    const indexes = bitMapToIndexes(BigInt(emode[key]));
    return indexes.map(
      (i) => snapshot.reserves[Object.keys(snapshot.reserves).find((key2) => snapshot.reserves[key2].id === i)].symbol
    ).join(", ");
  }
  return emode[key];
}
var ORDER = [
  "eModeCategory",
  "label",
  "ltv",
  "liquidationThreshold",
  "liquidationBonus",
  "priceSource"
];
function sortEmodeKeys(a, b) {
  const indexA = ORDER.indexOf(a);
  const indexB = ORDER.indexOf(b);
  if (indexA !== -1 && indexB !== -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA !== -1) return -1;
  if (indexB !== -1) return -1;
  return a.localeCompare(b);
}
var OMIT_KEYS = ["eModeCategory"];
function renderEmodeDiff(diff2, pre, post) {
  let content = "| description | value before | value after |\n| --- | --- | --- |\n";
  Object.keys(diff2).filter((key) => !OMIT_KEYS.includes(key)).sort(sortEmodeKeys).map((key) => {
    if (typeof diff2[key] === "object" && diff2[key].hasOwnProperty("from"))
      content += `| eMode.${key} | ${renderEModeValue(
        key,
        {
          ...diff2,
          [key]: diff2[key].from
        },
        pre
      )} | ${renderEModeValue(key, { ...diff2, [key]: diff2[key].to }, post)} |
`;
    else {
      const value = renderEModeValue(key, diff2, pre);
      content += `| eMode.${key} (unchanged) | ${value} | ${value} |
`;
    }
  });
  return content;
}

// src/reports/fetch-IR-strategy.ts
function getStrategyImageUrl(rate) {
  const paramsObj = {
    variableRateSlope1: rate.variableRateSlope1,
    variableRateSlope2: rate.variableRateSlope2,
    optimalUsageRatio: rate.optimalUsageRatio,
    baseVariableBorrowRate: rate.baseVariableBorrowRate,
    maxVariableBorrowRate: rate.maxVariableBorrowRate
  };
  const searchParams = new URLSearchParams(paramsObj);
  return `https://dash.onaave.com/api/static?${searchParams.toString()}`;
}

// src/reports/reserve.ts
import { formatUnits as formatUnits3 } from "viem";

// src/govv3/utils/markdownUtils.ts
import { formatUnits as formatUnits2, getContract as getContract2 } from "viem";

// src/govv3/utils/checkAddress.ts
import * as addresses from "@bgd-labs/aave-address-book";
import { IPool_ABI, IERC20Detailed_ABI } from "@bgd-labs/aave-address-book/abis";
import { findObjectPaths } from "find-object-paths";
import { getAddress, getContract } from "viem";
function isKnownAddress(value, chainId) {
  const transformedAddresses = Object.keys(addresses).reduce(
    (acc, key) => {
      if (addresses[key].CHAIN_ID === chainId) {
        const chainAddresses = { ...addresses[key] };
        if (chainAddresses.E_MODES) delete chainAddresses.E_MODES;
        acc[key] = chainAddresses;
      }
      return acc;
    },
    {}
  );
  const results = findObjectPaths(transformedAddresses, { value: getAddress(value) });
  if (typeof results === "string") return [results];
  return results;
}
function findPayloadsController(chainId) {
  const key = Object.keys(addresses).find(
    (key2) => addresses[key2].CHAIN_ID === chainId && addresses[key2].PAYLOADS_CONTROLLER
  );
  if (key) return addresses[key].PAYLOADS_CONTROLLER;
}
var assetsCache = Object.keys(addresses).reduce((acc, key) => {
  if (!addresses[key].ASSETS) return acc;
  const pool = addresses[key];
  if (!acc[pool.CHAIN_ID]) acc[pool.CHAIN_ID] = {};
  Object.keys(pool.ASSETS).map((symbol) => {
    const asset = pool.ASSETS[symbol];
    acc[pool.CHAIN_ID][asset.UNDERLYING] = { decimals: asset.decimals, symbol };
  });
  return acc;
}, {});
async function findAsset(client, address) {
  const chainId = client.chain.id;
  const asset = assetsCache[chainId][address];
  if (asset) return asset;
  const erc20Contract = getContract({ client, address, abi: IERC20Detailed_ABI });
  let symbol = "unknown";
  let decimals = 0;
  try {
    symbol = await erc20Contract.read.symbol();
  } catch (e) {
  }
  try {
    decimals = await erc20Contract.read.decimals();
  } catch (e) {
  }
  assetsCache[chainId][address] = {
    symbol,
    decimals
  };
  return assetsCache[chainId][address];
}
var cachedReservesList = {};
async function assetIndexesToAsset(client, poolAddress, indexes) {
  if (!cachedReservesList[client.chain.id])
    cachedReservesList[client.chain.id] = await getContract({
      client,
      abi: IPool_ABI,
      address: poolAddress
    }).read.getReservesList();
  const reservesList = cachedReservesList[client.chain.id];
  return await Promise.all(
    indexes.map(async (index) => {
      if (index < reservesList.length) {
        const reserve = reservesList[index];
        return `${(await findAsset(client, reserve)).symbol}(id: ${index})`;
      }
      return `unknown(id: ${index})`;
    })
  );
}

// src/govv3/utils/markdownUtils.ts
function boolToMarkdown(value) {
  if (value) return ":white_check_mark:";
  return ":sos:";
}
function toAddressLink(address, md, client) {
  if (!client) return address;
  const link = `${client.chain?.blockExplorers?.default.url}/address/${address}`;
  if (md) return toMarkdownLink(link, address);
  return link;
}
function toTxLink(txn, md, client) {
  if (!client) return txn;
  const link = `${client.chain?.blockExplorers?.default.url}/tx/${txn}`;
  if (md) return toMarkdownLink(link, txn);
  return link;
}
function toMarkdownLink(link, title) {
  return `[${title || link}](${link})`;
}
function renderCheckResult(check, result) {
  let response = `### Check: ${check.name} ${boolToMarkdown(!result.errors.length)}

`;
  if (result.errors.length) response += `#### Errors

${result.errors.join("\n")}

`;
  if (result.warnings.length) response += `#### Warnings

${result.warnings.join("\n")}

`;
  if (result.info.length) response += `#### Info

${result.info.join("\n")}

`;
  return response;
}
function renderUnixTime(time) {
  return new Date(time * 1e3).toLocaleString("en-GB", { timeZone: "UTC" });
}
function flagKnownAddress(isKnown) {
  if (isKnown === void 0 || isKnown.length === 0) return "";
  return `[:ghost:](https://github.com/bgd-labs/aave-address-book "${isKnown.join(", ")}")`;
}
function formatNumberString(x) {
  return String(x).replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",");
}
function limitDecimalsWithoutRounding(val, decimals) {
  const parts = val.split(".");
  if (parts.length != 2) return val;
  return parts[0] + "." + parts[1].substring(0, decimals);
}
function prettifyNumber({
  value,
  decimals,
  prefix,
  suffix,
  showDecimals,
  patchedValue
}) {
  const formattedNumber = limitDecimalsWithoutRounding(
    formatNumberString(formatUnits2(BigInt(patchedValue || value), decimals)),
    4
  );
  return `${prefix ? `${prefix} ` : ""}${formattedNumber}${suffix ? ` ${suffix}` : ""} [${value}${showDecimals ? `, ${decimals} decimals` : ""}]`;
}
function wrapInQuotes(name, quotes) {
  if (quotes) return "`" + name + "`";
  return name;
}
async function addAssetSymbol(client, value) {
  const asset = await findAsset(client, value);
  return `${value} (symbol: ${asset.symbol})`;
}
var CL_PROXY_ABI = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "description",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "latestAnswer",
    outputs: [{ internalType: "int256", name: "", type: "int256" }],
    stateMutability: "view",
    type: "function"
  }
];
async function addAssetPrice(client, address) {
  const clProxy = getContract2({ client, address, abi: CL_PROXY_ABI });
  let decimals, latestAnswer = 0n, description = "unknown";
  try {
    decimals = await clProxy.read.decimals();
  } catch (e) {
  }
  try {
    latestAnswer = await clProxy.read.latestAnswer();
  } catch (e) {
  }
  try {
    description = await clProxy.read.description();
  } catch (e) {
  }
  return `${address} (latestAnswer: ${decimals ? prettifyNumber({ value: latestAnswer, decimals, showDecimals: true }) : latestAnswer}, description: ${description})`;
}

// src/utils/getClient.ts
import "dotenv/config";
import { ChainList, getRPCUrl } from "@bgd-labs/rpc-env";
import { createClient, http } from "viem";
function getClient(chainId) {
  const chain = ChainList[chainId];
  if (!chain) return;
  return createClient({
    transport: http(
      getRPCUrl(chainId, {
        alchemyKey: process.env.ALCHEMY_API_KEY
      })
    ),
    chain
  });
}

// src/reports/reserve.ts
function renderReserveValue(key, reserve, chainId) {
  if (["reserveFactor", "liquidationProtocolFee", "liquidationThreshold", "ltv"].includes(key))
    return prettifyNumber({ value: reserve[key], decimals: 2, suffix: "%" });
  if (["supplyCap", "borrowCap"].includes(key))
    return `${reserve[key].toLocaleString("en-US")} ${reserve.symbol}`;
  if (["aTokenUnderlyingBalance", "virtualBalance"].includes(key))
    return prettifyNumber({
      value: reserve[key],
      decimals: reserve.decimals,
      suffix: reserve.symbol
    });
  if (key === "debtCeiling")
    return prettifyNumber({ value: reserve[key], decimals: 2, suffix: "$" });
  if (["liquidityIndex", "variableBorrowIndex"].includes(key))
    return prettifyNumber({ value: reserve[key], decimals: 27, suffix: "%" });
  if (["currentLiquidityRate", "currentVariableBorrowRate"].includes(key))
    return prettifyNumber({ value: reserve[key], decimals: 25, suffix: "%" });
  if (key === "liquidationBonus")
    return reserve[key] === 0 ? "0 %" : `${(reserve[key] - 1e4) / 100} %`;
  if (key === "interestRateStrategy")
    return toAddressLink(reserve[key], true, getClient(chainId));
  if (key === "oracleLatestAnswer" && reserve.oracleDecimals)
    return formatUnits3(BigInt(reserve[key]), reserve.oracleDecimals);
  if (typeof reserve[key] === "number") return reserve[key].toLocaleString("en-US");
  if (typeof reserve[key] === "string" && /0x.+/.test(reserve[key]))
    return toAddressLink(reserve[key], true, getClient(chainId));
  return reserve[key];
}
function renderReserveHeadline(reserve, chainId) {
  return `#### ${reserve.symbol} (${toAddressLink(reserve.underlying, true, getClient(chainId))})

`;
}
var ORDER2 = [
  "symbol",
  "decimals",
  "isActive",
  "isFrozen",
  "supplyCap",
  "borrowCap",
  "debtCeiling",
  "isSiloed",
  "isFlashloanable",
  "eModeCategory",
  "oracle",
  "oracleDecimals",
  "oracleDescription",
  "oracleName",
  "oracleLatestAnswer",
  "usageAsCollateralEnabled",
  "ltv",
  "liquidationThreshold",
  "liquidationBonus",
  "liquidationProtocolFee",
  "reserveFactor",
  "aToken",
  "aTokenImpl",
  "variableDebtToken",
  "variableDebtTokenImpl",
  "stableDebtToken",
  "stableDebtTokenImpl",
  "borrowingEnabled",
  "stableBorrowRateEnabled",
  "isBorrowableInIsolation",
  "interestRateStrategy",
  "liquidityIndex",
  "variableBorrowIndex"
];
function sortReserveKeys(a, b) {
  const indexA = ORDER2.indexOf(a);
  if (indexA === -1) return 1;
  const indexB = ORDER2.indexOf(b);
  if (indexB === -1) return -1;
  return indexA - indexB;
}
function renderReserveConfig(reserve, chainId) {
  let content = "| description | value |\n| --- | --- |\n";
  const OMIT_KEYS3 = [
    "underlying",
    // already rendered in the header
    "symbol"
    // already rendered in the header
  ];
  Object.keys(reserve).filter((key) => !OMIT_KEYS3.includes(key)).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(key, reserve, chainId)} |
`;
  });
  return content;
}
function renderReserve(reserve, chainId) {
  let content = renderReserveHeadline(reserve, chainId);
  content += renderReserveConfig(reserve, chainId);
  return content;
}
function renderReserveDiff(diff2, chainId) {
  let content = renderReserveHeadline(diff2, chainId);
  content += "| description | value before | value after |\n| --- | --- | --- |\n";
  const from = Object.keys(diff2).reduce((acc, _key) => {
    const key = _key;
    acc[key] = typeof diff2[key] === "object" ? diff2[key].from : diff2[key];
    return acc;
  }, {});
  const to = Object.keys(diff2).reduce((acc, _key) => {
    const key = _key;
    acc[key] = typeof diff2[key] === "object" ? diff2[key].to : diff2[key];
    return acc;
  }, {});
  Object.keys(diff2).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(key, from, chainId)} | ${renderReserveValue(key, to, chainId)} |
`;
  });
  return content;
}

// src/reports/strategy.ts
import { formatUnits as formatUnits4 } from "viem";
function renderStrategyValue(key, reserve) {
  if (reserve[key] === void 0 || reserve[key] === null) return "/";
  return `${formatUnits4(BigInt(reserve[key]), 25)} %`;
}
var ORDER3 = [
  "optimalUsageRatio",
  "maxVariableBorrowRate",
  "baseVariableBorrowRate",
  "variableRateSlope1",
  "variableRateSlope2"
];
function sortStrategyKeys(a, b) {
  const indexA = ORDER3.indexOf(a);
  const indexB = ORDER3.indexOf(b);
  if (indexA !== -1 && indexB !== -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA !== -1) return -1;
  if (indexB !== -1) return -1;
  return a.localeCompare(b);
}
var OMIT_KEYS2 = [
  "address"
  // already rendered in the reserve
];
function renderStrategy(strategy) {
  let content = "";
  Object.keys(strategy).filter((key) => !OMIT_KEYS2.includes(key)).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, strategy)} |
`;
  });
  return content;
}
function renderStrategyDiff(diff2) {
  let content = "";
  Object.keys(diff2).filter((key) => !OMIT_KEYS2.includes(key)).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, {
      ...diff2,
      [key]: diff2[key].from
    })} | ${renderStrategyValue(key, { ...diff2, [key]: diff2[key].to })} |
`;
  });
  return content;
}

// src/reports/code-diff.ts
import { existsSync } from "fs";
import { execSync } from "child_process";
function downloadContract(chainId, address) {
  const outPath = `/tmp/${chainId}_${address}`;
  if (existsSync(outPath)) console.log("skipped download");
  const command = `cast etherscan-source --chain ${chainId} -d ${outPath} ${address}`;
  execSync(command);
  return outPath;
}
function flatten(path5) {
  const flattenCmd = `
          mkdir -p ${path5}_flat
          counter=1
          for file in $(find ${path5} -type f)
          do
            original_file_name="\${file##*/}"
            if [ -e ${path5}_flat/\${counter}_\${original_file_name} ]
            then
              mv "$file" "${path5}_flat/\${counter}_\${original_file_name}"
            else
              mv "$file" "${path5}_flat/\${original_file_name}"
            fi
            ((counter++))
          done;
      `;
  execSync(flattenCmd);
  return `${path5}_flat`;
}
function diffCode(fromPath, toPath) {
  fromPath = flatten(fromPath);
  toPath = flatten(toPath);
  const prettierCmd = `npx prettier ${fromPath} ${toPath} --write`;
  execSync(prettierCmd);
  const diffCmd = `
  git diff --no-index --ignore-space-at-eol ${fromPath} ${toPath} | awk '
    BEGIN { in_diff_block = 0; skip_block = 0; buffer = "" }
    /^diff --git/ {
      if (in_diff_block && skip_block == 0) { printf "%s", buffer }
      in_diff_block = 1; skip_block = 0; buffer = $0 "\\n"
    }
    /similarity index 100%/ { skip_block = 1 }
    { if (in_diff_block && !/^diff --git/) { buffer = buffer $0 "\\n" } }
    END { if (in_diff_block && skip_block == 0) { printf "%s", buffer } }
  '
  `;
  const result = execSync(diffCmd);
  return result.toString();
}

// src/reports/diff-reports.ts
function hasDiff(input2) {
  if (!input2) return false;
  return !!Object.keys(input2).find(
    (key) => typeof input2[key] === "object" && input2[key] !== null && (input2[key].hasOwnProperty("from") || input2[key].hasOwnProperty("to"))
  );
}
async function diffReports(pre, post) {
  const chainId = pre.chainId;
  const diffResult = diff(pre, post);
  const diffResultWithoutUnchanged = diff(pre, post, true);
  let content = "";
  const reservesAdded = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].to) {
      let report = renderReserve(diffResult.reserves[reserveKey].to, chainId);
      report += renderStrategy(post.strategies[reserveKey]);
      report += `| interestRate | ![ir](${getStrategyImageUrl(post.strategies[reserveKey])}) |
`;
      return report;
    }
  }).filter((i) => i);
  const reservesRemoved = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].from) {
      return renderReserve(diffResult.reserves[reserveKey].from, chainId);
    }
  }).filter((i) => i);
  const reservesAltered = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (!diffResult.reserves[reserveKey].hasOwnProperty("from")) {
      const hasChangedReserveProperties = hasDiff(diffResult.reserves[reserveKey]);
      const preIr = getStrategyImageUrl(pre.strategies[reserveKey]);
      const postIr = getStrategyImageUrl(post.strategies[reserveKey]);
      const hasChangedIr = preIr !== postIr;
      if (!hasChangedReserveProperties && !hasChangedIr) return;
      let report = renderReserveDiff(diffResult.reserves[reserveKey], chainId);
      if (hasChangedIr) {
        report += renderStrategyDiff(
          diff(pre.strategies[reserveKey], post.strategies[reserveKey])
        );
        report += `| interestRate | ![before](${preIr}) | ![after](${postIr}) |`;
      }
      return report;
    }
  }).filter((i) => i);
  if (reservesAdded.length || reservesRemoved.length || reservesAltered.length) {
    content += "## Reserve changes\n\n";
    if (reservesAdded.length) {
      content += `### ${reservesAdded.length > 1 ? "Reserve" : "Reserves"} added

`;
      content += reservesAdded.join("\n\n");
      content += "\n\n";
    }
    if (reservesAltered.length) {
      content += `### ${reservesAltered.length > 1 ? "Reserve" : "Reserves"} altered

`;
      content += reservesAltered.join("\n\n");
      content += "\n\n";
    }
    if (reservesRemoved.length) {
      content += `### ${reservesRemoved.length > 1 ? "Reserve" : "Reserves"} removed

`;
      content += reservesRemoved.join("\n\n");
      content += "\n\n";
    }
  }
  if (diffResultWithoutUnchanged.eModes) {
    content += "## Emodes changed\n\n";
    for (const eMode of Object.keys(diffResult.eModes)) {
      const hasChanges = hasDiff(diffResult.eModes?.[eMode]);
      content += `### EMode: ${post.eModes[eMode].label}(id: ${post.eModes[eMode].eModeCategory})

`;
      if (hasChanges) {
        content += renderEmodeDiff(
          diff(pre.eModes[eMode] || {}, post.eModes[eMode] || {}),
          pre,
          post
        );
      } else if (!pre.eModes[eMode] || !post.eModes[eMode]) {
        content += renderEmodeDiff(
          diff(pre.eModes[eMode] || {}, post.eModes[eMode] || {}),
          pre,
          post
        );
      }
      content += "\n\n";
    }
  }
  try {
    if (diffResultWithoutUnchanged.poolConfig) {
      for (const key of Object.keys(diffResult.poolConfig)) {
        if (typeof diffResult.poolConfig[key] === "object" && diffResult.poolConfig[key].hasOwnProperty("from")) {
          const fromAddress = diffResult.poolConfig[key].from;
          const toAddress = diffResult.poolConfig[key].to;
          const from = downloadContract(pre.chainId, fromAddress);
          const to = downloadContract(pre.chainId, toAddress);
          const result = diffCode(from, to);
          writeFileSync(`./diffs/${pre.chainId}_${key}_${fromAddress}_${toAddress}.diff`, result);
        }
      }
    }
  } catch (e) {
  }
  content += `## Raw diff

\`\`\`json
${JSON.stringify(diffResultWithoutUnchanged, null, 2)}
\`\`\``;
  return content;
}

// src/utils/json.ts
import fs from "node:fs";
import path from "node:path";
import JSONbig from "json-bigint";
function readJsonString(content) {
  return JSON.parse(JSON.stringify(JSONbig({ storeAsString: true }).parse(content)));
}
function readJsonFile(filePath) {
  const content = fs.readFileSync(path.join(process.cwd(), filePath), "utf8");
  return readJsonString(content);
}

// src/commands/diffSnaphots.ts
function addCommand(program2) {
  program2.command("diff-snapshots").description("generate a snapshot diff report").argument("<from>").argument("<to>").option("-o, --out <string>", "output path").option("--stringMode", "expects input to be a string, not paths").action(async (_from, _to, options) => {
    const from = options.stringMode ? readJsonString(_from) : readJsonFile(_from);
    const to = options.stringMode ? readJsonString(_to) : readJsonFile(_to);
    const content = await diffReports(from, to);
    if (options.out) {
      fs2.mkdirSync(path2.dirname(options.out), { recursive: true });
      fs2.writeFileSync(options.out, content);
    } else {
      console.log(content);
    }
  });
  program2.command("adi-diff-snapshots").description("generate a aDI snapshot diff report").argument("<from>").argument("<to>").option("-o, --out <string>", "output path").option("--stringMode", "expects input to be a string, not paths").action(async (_from, _to, options) => {
    const from = options.stringMode ? readJsonString(_from) : readJsonFile(_from);
    const to = options.stringMode ? readJsonString(_to) : readJsonFile(_to);
    const content = await adiDiffReports(from, to);
    if (options.out) {
      fs2.mkdirSync(path2.dirname(options.out), { recursive: true });
      fs2.writeFileSync(options.out, content);
    } else {
      console.log(content);
    }
  });
  program2.command("diff-storage").description("generate a storage diff").argument("<from>").argument("<to>").option("-o, --out <string>", "output path").action(async (_from, _to, options) => {
    const from = readJsonFile(_from);
    const to = readJsonFile(_to);
    const content = await compareStorageLayouts(from, to);
    if (options.out) {
      fs2.mkdirSync(path2.dirname(options.out), { recursive: true });
      fs2.writeFileSync(options.out, content);
    } else {
      console.log(content);
    }
  });
}

// src/commands/fork.ts
import path3 from "node:path";
import { http as http3, createWalletClient } from "viem";

// src/govv3/governance.ts
import { AaveSafetyModule as AaveSafetyModule2, AaveV3Ethereum as AaveV3Ethereum2, GovernanceV3Ethereum as GovernanceV3Ethereum3 } from "@bgd-labs/aave-address-book";
import { IGovernanceCore_ABI } from "@bgd-labs/aave-address-book/abis";
import merge from "deepmerge";
import {
  encodeFunctionData,
  fromHex as fromHex3,
  getContract as getContract3,
  toHex as toHex4
} from "viem";
import { getBlock as getBlock3, getStorageAt, getTransaction } from "viem/actions";

// src/utils/constants.ts
import { GovernanceV3Ethereum } from "@bgd-labs/aave-address-book";
var EOA = "0xD73a92Be73EfbFcF3854433A5FcbAbF9c1316073";
var VERBOSE = process.env.VERBOSE;
var FORMAT = process.env.FORMAT || "raw";
var DEFAULT_GOVERNANCE = GovernanceV3Ethereum.GOVERNANCE;
var DEFAULT_GOVERNANCE_CLIENT = getClient(1);

// src/utils/logger.ts
import chalk from "chalk";
function logInfo(topic, text) {
  console.log(chalk.blue(`Info[${topic}]: ${text}`));
}
function logWarning(topic, text) {
  console.log(chalk.yellow(`Warning[${topic}]: ${text}`));
}
function logError(topic, text) {
  console.log(chalk.red(`Error[${topic}]: ${text}`));
}
function logSuccess(topic, text) {
  console.log(chalk.green(`Success[${topic}]: ${text}`));
}

// src/utils/tenderlyClient.ts
import {
  http as http2,
  createClient as createClient2,
  fromHex as fromHex2,
  getContractAddress,
  pad as pad2,
  parseEther,
  toHex as toHex2
} from "viem";
import { deployContract, getBlock, getTransactionReceipt, sendTransaction } from "viem/actions";
var Tenderly = class {
  TENDERLY_BASE = "https://api.tenderly.co/api/v1";
  ACCESS_TOKEN;
  ACCOUNT;
  PROJECT;
  constructor(accessToken, account, project) {
    this.ACCESS_TOKEN = accessToken;
    this.ACCOUNT = account;
    this.PROJECT = project;
  }
  trace = async (chainId, txHash) => {
    const response = await fetch(
      `${this.TENDERLY_BASE}/public-contract/${chainId}/trace/${txHash}`,
      {
        method: "GET",
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
    const result = await response.json();
    return result;
  };
  simulate = async (request, client) => {
    if (!request.state_objects) {
      request.state_objects = {};
    }
    if (!request.state_objects[request.from]) {
      request.state_objects[request.from] = {
        balance: String(parseEther("3"))
      };
    } else {
      request.state_objects[request.from].balance = String(parseEther("3"));
    }
    let apiUrl = `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/simulate`;
    if (client) {
      const url = client.transport.url;
      const tenderlyForkRegex = new RegExp(/https:\/\/rpc.tenderly.co\/fork\/(.*)/);
      if (tenderlyForkRegex.test(url)) {
        const matches = url.match(tenderlyForkRegex);
        if (matches) {
          const fork = await this.getForkInfo(matches[1]);
          request.root = fork.global_head;
          delete request.network_id;
          apiUrl = `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/fork/${matches[1]}/simulate`;
        }
      }
    }
    const fullRequest = JSON.stringify({
      generate_access_list: true,
      save: true,
      gas_price: "0",
      gas: 3e7,
      force_import_contracts: true,
      ...request
    });
    logInfo("tenderly", `request: ${JSON.stringify(fullRequest)}`);
    const response = await fetch(apiUrl, {
      method: "POST",
      body: fullRequest,
      headers: new Headers({
        "Content-Type": "application/json",
        "X-Access-Key": this.ACCESS_TOKEN
      })
    });
    if (response.status !== 200) {
      console.log(await response.text());
      throw new Error(`TenderlyError: ${response.statusText}`);
    }
    return await response.json();
  };
  /**
   * Fork api to get fork information from an existing fork id
   * @param project name of the Tenderly project where the fork was created
   * @param forkId id of the fork created in tenderly
   * @returns fork object
   */
  getForkInfo = async (forkId, project) => {
    const response = await fetch(
      `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${project || this.PROJECT}/fork/${forkId}`,
      {
        method: "GET",
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
    if (response.status >= 400) {
      console.log(await response.text());
      throw new Error(`TenderlyError: ${response.statusText}`);
    }
    const result = await response.json();
    const fork = {
      id: result.simulation_fork.id,
      chainId: result.simulation_fork.network_id,
      block_number: result.simulation_fork.block_number,
      forkNetworkId: result.simulation_fork.chain_config.chain_id,
      forkUrl: `https://rpc.tenderly.co/fork/${result.simulation_fork.id}`,
      global_head: result.simulation_fork.global_head
    };
    return fork;
  };
  /**
   * Trace api lacks most information we need, so simulateTx uses the simulation api to replicate the trace.
   * @param chainId
   * @param tx
   * @returns
   */
  simulateTx = async (chainId, tx) => {
    const simulationPayload = {
      network_id: String(chainId),
      from: tx.from,
      to: tx.to,
      block_number: Number(tx.blockNumber),
      input: tx.input
    };
    return this.simulate(simulationPayload);
  };
  fork = async ({
    chainId,
    blockNumber,
    alias,
    forkChainId = 3030
  }) => {
    const forkingPoint = {
      network_id: chainId,
      chain_config: { chain_id: forkChainId }
    };
    if (blockNumber) forkingPoint.block_number = blockNumber;
    if (alias) forkingPoint.alias = alias;
    const response = await fetch(
      `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/fork`,
      {
        method: "POST",
        body: JSON.stringify(forkingPoint),
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
    const result = await response.json();
    if (result.error) {
      logError("tenderly", "fork could not be created");
      throw new Error(result.error.message);
    }
    const fork = {
      id: result.simulation_fork.id,
      chainId: result.simulation_fork.network_id,
      block_number: result.simulation_fork.block_number,
      forkNetworkId: result.simulation_fork.chain_config.chain_id,
      forkUrl: `https://rpc.tenderly.co/fork/${result.simulation_fork.id}`,
      global_head: result.simulation_fork.global_head
    };
    logSuccess(
      "tenderly",
      `Fork created! To use in aave interface you need to run the following commands:

---
localStorage.setItem('forkEnabled', 'true');
localStorage.setItem('forkBaseChainId', ${fork.chainId});
localStorage.setItem('forkNetworkId', ${fork.forkNetworkId});
localStorage.setItem("forkRPCUrl", "${fork.forkUrl}");
---
`
    );
    return fork;
  };
  deployCode = async (fork, filePath, from) => {
    const walletProvider = createClient2({
      account: from || EOA,
      chain: { id: fork.forkNetworkId, name: "tenderly" },
      transport: http2(fork.forkUrl)
    });
    const artifact = __require(filePath);
    logInfo("tenderly", `deploying ${filePath}`);
    const hash = await deployContract(walletProvider, {
      abi: artifact.abi,
      bytecode: artifact.bytecode.object,
      account: walletProvider.account
    });
    const receipt = await getTransactionReceipt(walletProvider, { hash });
    return getContractAddress({ from: receipt.from, nonce: receipt.nonce });
  };
  warpTime = async (fork, timestamp) => {
    const client = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    const currentBlock = await getBlock(client);
    if (timestamp > currentBlock.timestamp) {
      logInfo("tenderly", `warping time from ${currentBlock.timestamp} to ${timestamp}`);
      await client.request({
        method: "evm_increaseTime",
        params: [toHex2(timestamp - currentBlock.timestamp)]
      });
    } else {
      logWarning(
        "tenderly",
        `skipping time warp as tenderly forks do not support traveling back in time (from ${currentBlock.timestamp} to ${timestamp})`
      );
    }
  };
  warpBlocks = async (fork, blockNumber) => {
    const client = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    const currentBlock = await getBlock(client);
    if (blockNumber > currentBlock.number) {
      logInfo("tenderly", `warping blocks from ${currentBlock.number} to ${blockNumber}`);
      await client.request({
        method: "evm_increaseBlocks",
        params: [toHex2(blockNumber - currentBlock.number)]
      });
    } else {
      logWarning(
        "tenderly",
        "skipping block warp as tenderly forks do not support traveling back in time"
      );
    }
  };
  unwrapAndExecuteSimulationPayloadOnFork = async (fork, request) => {
    await this.fundAccount(fork, request.from);
    const publicProvider = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    if (request.state_objects) {
      logInfo("tenderly", "setting storage");
      for (const address of Object.keys(request.state_objects)) {
        if (request.state_objects[address].storage) {
          for (const slot of Object.keys(request.state_objects[address].storage)) {
            await publicProvider.request({
              method: "tenderly_setStorageAt",
              params: [
                address,
                pad2(slot, { size: 32 }),
                pad2(request.state_objects[address].storage[slot], {
                  size: 32
                })
              ]
            });
          }
        }
      }
    }
    if (request.block_header?.timestamp) {
      await this.warpTime(fork, fromHex2(request.block_header?.timestamp, "bigint"));
    }
    if (request.block_header?.number) {
      await this.warpBlocks(fork, fromHex2(request.block_header?.number, "bigint"));
    }
    if (request.input) {
      logInfo("tenderly", "execute transaction");
      const walletProvider = createClient2({
        account: request.from,
        chain: { id: fork.forkNetworkId, name: "tenderly" },
        transport: http2(fork.forkUrl)
      });
      const hash = await sendTransaction(walletProvider, {
        data: request.input,
        to: request.to,
        value: request.value || 0n
      });
      const receipt = await getTransactionReceipt(walletProvider, { hash });
      if (receipt.status === "success") {
        logSuccess("tenderly", "transaction successfully executed");
      } else {
        logError("tenderly", "transaction reverted");
      }
      return hash;
    }
  };
  fundAccount = (fork, address) => {
    logInfo("tenderly", "fund account");
    return fetch(
      `${this.TENDERLY_BASE}/account/${this.ACCOUNT}/project/${this.PROJECT}/fork/${fork.id}/balance`,
      {
        method: "POST",
        body: JSON.stringify({ accounts: [address], amount: 1e3 }),
        headers: new Headers({
          "Content-Type": "application/json",
          "X-Access-Key": this.ACCESS_TOKEN
        })
      }
    );
  };
  replaceCode = (fork, address, code) => {
    const publicProvider = createClient2({
      chain: { id: fork.forkNetworkId },
      transport: http2(fork.forkUrl)
    });
    return publicProvider.request({
      method: "tenderly_setCode",
      params: [address, code]
    });
  };
};
var tenderly = new Tenderly(
  process.env.TENDERLY_ACCESS_TOKEN,
  process.env.TENDERLY_ACCOUNT,
  process.env.TENDERLY_PROJECT_SLUG
);

// src/govv3/proofs.ts
import { AaveSafetyModule, AaveV3Ethereum, GovernanceV3Ethereum as GovernanceV3Ethereum2 } from "@bgd-labs/aave-address-book";
import {
  fromRlp,
  toHex as toHex3,
  toRlp
} from "viem";
import { getBlock as getBlock2, getProof as viemGetProof } from "viem/actions";
var WAREHOUSE_SLOTS = {
  [AaveSafetyModule.STK_AAVE]: {
    exchangeRate: 81n
    // exchangeRate
  }
};
var VOTING_SLOTS = {
  [AaveSafetyModule.STK_AAVE]: { balance: 0n },
  // balance
  [AaveV3Ethereum.ASSETS.AAVE.A_TOKEN]: {
    balance: 52n,
    // balance
    delegation: 64n
  },
  // delegation
  [AaveV3Ethereum.ASSETS.AAVE.UNDERLYING]: { balance: 0n },
  // balance
  [GovernanceV3Ethereum2.GOVERNANCE]: { representative: 9n }
  // representative
};
async function getProof(client, address, slots, blockHash) {
  const block = await getBlock2(client, { blockHash });
  return viemGetProof(client, {
    address,
    storageKeys: slots.map((slot) => slot),
    blockNumber: block.number
  });
}
var getBlockRLP = (rawBlock) => {
  const rawData = [
    rawBlock.parentHash,
    rawBlock.sha3Uncles,
    rawBlock.miner,
    rawBlock.stateRoot,
    rawBlock.transactionsRoot,
    rawBlock.receiptsRoot,
    rawBlock.logsBloom,
    "0x0",
    //toHex(rawBlock.difficulty),
    toHex3(rawBlock.number || 0),
    // 0 to account for type null
    toHex3(rawBlock.gasLimit),
    toHex3(rawBlock.gasUsed),
    toHex3(rawBlock.timestamp),
    rawBlock.extraData,
    rawBlock.mixHash,
    rawBlock.nonce,
    toHex3(rawBlock.baseFeePerGas || 0),
    // 0 to account for type null
    // @ts-ignore looks like this field is not yet added into the type
    rawBlock.withdrawalsRoot
  ];
  return toRlp(rawData);
};
var getAccountRPL = (proof) => {
  return toRlp(proof.map((rpl) => fromRlp(rpl, "hex")));
};

// src/govv3/governance.ts
import { ProposalState } from "@bgd-labs/aave-v3-governance-cache";
var SLOTS = {
  PROPOSALS_MAPPING: 7n
};
var HUMAN_READABLE_STATE = {
  [ProposalState.Null]: "Null",
  [ProposalState.Created]: "Created",
  [ProposalState.Active]: "Active",
  [ProposalState.Queued]: "Queued",
  [ProposalState.Executed]: "Executed",
  [ProposalState.Failed]: "Failed",
  [ProposalState.Cancelled]: "Cancelled",
  [ProposalState.Expired]: "Expired"
};
var getGovernance = ({ address, client }) => {
  const governanceContract = getContract3({
    abi: IGovernanceCore_ABI,
    address,
    client
  });
  async function getProposal(proposalId) {
    return governanceContract.read.getProposal([proposalId]);
  }
  async function getSimulationPayloadForExecution(proposalId) {
    const currentBlock = await getBlock3(client);
    const proposalSlot = getSolidityStorageSlotUint(SLOTS.PROPOSALS_MAPPING, proposalId);
    const data = await getStorageAt(client, {
      address: governanceContract.address,
      slot: proposalSlot
    });
    let proposalSlot1 = fromHex3(data, { to: "bigint" });
    proposalSlot1 = setBits(proposalSlot1, 0n, 8n, ProposalState.Queued);
    proposalSlot1 = setBits(
      proposalSlot1,
      16n,
      56n,
      currentBlock.timestamp - await governanceContract.read.PROPOSAL_EXPIRATION_TIME()
    );
    const simulationPayload = {
      network_id: String(client.chain.id),
      from: EOA,
      to: governanceContract.address,
      input: encodeFunctionData({
        abi: IGovernanceCore_ABI,
        functionName: "executeProposal",
        args: [proposalId]
      }),
      // value: parseEther('0.5').toString(),
      block_number: -2,
      state_objects: {
        [governanceContract.address]: {
          storage: {
            [proposalSlot]: toHex4(proposalSlot1, { size: 32 })
            // state & time
            // [toHex(fromHex(proposalSlot, { to: 'bigint' }) + 5n)]: toHex(parseUnits('340000000', 18), {
            //   size: 32,
            // }), // votes (not needed as there's no validation for this at this point)
          }
        }
      }
    };
    return simulationPayload;
  }
  return {
    governanceContract,
    getSimulationPayloadForExecution,
    async simulateProposalExecutionOnTenderly(proposalId, { executedLog }) {
      if (executedLog) {
        const tx = await getTransaction(client, {
          hash: executedLog.transactionHash
        });
        return tenderly.simulateTx(client.chain.id, tx);
      }
      const payload = await getSimulationPayloadForExecution(proposalId);
      return tenderly.simulate(payload, client);
    },
    async getVotingProofs(proposalId, voter, votingChainId) {
      const proposal = await getProposal(proposalId);
      const [stkAaveProof, aaveProof, aAaveProof, representativeProof] = await Promise.all([
        getProof(
          client,
          AaveSafetyModule2.STK_AAVE,
          [getSolidityStorageSlotAddress(VOTING_SLOTS[AaveSafetyModule2.STK_AAVE].balance, voter)],
          proposal.snapshotBlockHash
        ),
        getProof(
          client,
          AaveV3Ethereum2.ASSETS.AAVE.UNDERLYING,
          [
            getSolidityStorageSlotAddress(
              VOTING_SLOTS[AaveV3Ethereum2.ASSETS.AAVE.UNDERLYING].balance,
              voter
            )
          ],
          proposal.snapshotBlockHash
        ),
        getProof(
          client,
          AaveV3Ethereum2.ASSETS.AAVE.A_TOKEN,
          [
            getSolidityStorageSlotAddress(
              VOTING_SLOTS[AaveV3Ethereum2.ASSETS.AAVE.A_TOKEN].balance,
              voter
            ),
            getSolidityStorageSlotAddress(
              VOTING_SLOTS[AaveV3Ethereum2.ASSETS.AAVE.A_TOKEN].delegation,
              voter
            )
          ],
          proposal.snapshotBlockHash
        ),
        getProof(
          client,
          GovernanceV3Ethereum3.GOVERNANCE,
          [
            getSolidityStorageSlotBytes(
              getSolidityStorageSlotAddress(
                VOTING_SLOTS[GovernanceV3Ethereum3.GOVERNANCE].representative,
                voter
              ),
              toHex4(votingChainId, { size: 32 })
            )
          ],
          proposal.snapshotBlockHash
        )
      ]);
      return [
        { proof: stkAaveProof, slots: [0n] },
        { proof: aaveProof, slots: [0n] },
        { proof: aAaveProof, slots: [52n, 64n] },
        { proof: representativeProof, slots: [9n] }
      ].flatMap(({ proof, slots }) => {
        return slots.filter((slot, ix) => {
          const shouldSubmitProof = proof.storageProof[ix].value !== 0n;
          if (!shouldSubmitProof)
            logInfo(
              "Proof",
              `Skipping slot ${slot} on ${proof.address} as value is zero for voter ${voter}`
            );
          return shouldSubmitProof;
        }).map((slot, ix) => ({
          underlyingAsset: proof.address,
          slot,
          proof: getAccountRPL(proof.storageProof[ix].proof)
        }));
      });
    },
    async getStorageRoots(proposalId) {
      const proposal = await getProposal(proposalId);
      const addresses2 = merge(VOTING_SLOTS, WAREHOUSE_SLOTS);
      const proofs = await Promise.all(
        Object.keys(addresses2).map(
          (address2) => getProof(
            client,
            address2,
            Object.keys(addresses2[address2]).map(
              (slotKey) => toHex4(addresses2[address2][slotKey])
            ),
            proposal.snapshotBlockHash
          )
        )
      );
      return proofs;
    }
  };
};

// src/govv3/payloadsController.ts
import { IPayloadsControllerCore_ABI } from "@bgd-labs/aave-address-book/abis";
import {
  encodeFunctionData as encodeFunctionData2,
  encodePacked,
  getContract as getContract4
} from "viem";
import { getBlock as getBlock4, getTransaction as getTransaction2 } from "viem/actions";
import { PayloadState } from "@bgd-labs/aave-v3-governance-cache";
var HUMAN_READABLE_PAYLOAD_STATE = {
  [PayloadState.None]: "None",
  [PayloadState.Created]: "Created",
  [PayloadState.Queued]: "Queued",
  [PayloadState.Executed]: "Executed",
  [PayloadState.Cancelled]: "Cancelled",
  [PayloadState.Expired]: "Expired"
};
var SLOTS2 = {
  PAYLOADS_MAPPING: 3n
};
var getPayloadsController = (address, client) => {
  const controllerContract = getContract4({
    abi: IPayloadsControllerCore_ABI,
    address,
    client
  });
  const getSimulationPayloadForExecution = async (id) => {
    const payload = await controllerContract.read.getPayloadById([id]);
    const currentBlock = await getBlock4(client);
    const simulationPayload = {
      network_id: String(client.chain.id),
      from: EOA,
      to: controllerContract.address,
      input: encodeFunctionData2({
        abi: IPayloadsControllerCore_ABI,
        functionName: "executePayload",
        args: [id]
      }),
      block_number: -2,
      state_objects: {
        [controllerContract.address]: {
          storage: {
            [getSolidityStorageSlotUint(SLOTS2.PAYLOADS_MAPPING, BigInt(id))]: encodePacked(
              ["uint40", "uint40", "uint8", "uint8", "address"],
              [
                // we subtract 240n(4min), as tenderly might have been fallen behind
                // therefore using block_number -1 (latest on tenderly) and a 4min margin should give a save margin
                Number(currentBlock.timestamp - BigInt(payload.delay) - 1n - 240n),
                // altering queued time so can be executed in current block
                payload.createdAt,
                PayloadState.Queued,
                payload.maximumAccessLevelRequired,
                payload.creator
              ]
            )
          }
        }
      }
    };
    return simulationPayload;
  };
  return {
    controllerContract,
    getSimulationPayloadForExecution,
    simulatePayloadExecutionOnTenderly: async (id, { executedLog }) => {
      if (executedLog) {
        const tx = await getTransaction2(client, {
          hash: executedLog.transactionHash
        });
        return tenderly.simulateTx(client.chain.id, tx);
      }
      const payload = await getSimulationPayloadForExecution(id);
      return tenderly.simulate(payload, client);
    }
  };
};

// src/commands/fork.ts
function addCommand2(program2) {
  program2.command("fork").description("generates a fork (optionally with a proposal executeds").requiredOption("--chainId <number>", "the chainId to fork offs").option("--blockNumber <number>", "the blocknumber to fork of (latest if omitted)").option("--alias <string>", "Set a custom alias").option("--proposalId <number>", "ProposalId to execute").option("--payloadId <number>", "PayloadId to execute").option("--payloadAddress <string>", "Payload address").option("--artifactPath <string>", "path to the local payload").action(async (options) => {
    const { chainId, blockNumber, alias, payloadId, proposalId, artifactPath, payloadAddress } = options;
    function getAlias() {
      const unix = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      if (alias) {
        return `${unix}-${alias}`;
      }
      if (options.proposalId) {
        return `${unix}-proposalId-${options.proposalId}`;
      }
      if (options.payloadId) {
        return `${unix}-payloadId-${options.payloadId}`;
      }
      return "vanilla-fork";
    }
    const forkConfig = {
      chainId: Number(chainId),
      alias: getAlias(),
      blockNumber: Number(blockNumber)
    };
    if (proposalId) {
      const governance = getGovernance({
        address: DEFAULT_GOVERNANCE,
        client: DEFAULT_GOVERNANCE_CLIENT
      });
      const payload = await governance.getSimulationPayloadForExecution(BigInt(proposalId));
      const fork = await tenderly.fork({
        ...forkConfig,
        blockNumber: forkConfig.blockNumber || payload.block_number
      });
      await tenderly.unwrapAndExecuteSimulationPayloadOnFork(fork, payload);
      return;
    }
    const payloadsControllerAddress = findPayloadsController(forkConfig.chainId);
    if (!payloadsControllerAddress)
      throw new Error("payloadscontroller not found on specified chain");
    if (artifactPath) {
      const fork = await tenderly.fork({
        ...forkConfig,
        blockNumber: forkConfig.blockNumber
      });
      const payload = await tenderly.deployCode(fork, path3.join(process.cwd(), artifactPath));
      const walletProvider = createWalletClient({
        account: EOA,
        chain: { id: fork.forkNetworkId, name: "tenderly" },
        transport: http3(fork.forkUrl)
      });
      const payloadsController = getPayloadsController(
        payloadsControllerAddress,
        walletProvider
      );
      await payloadsController.controllerContract.write.createPayload(
        [
          [
            {
              target: payload,
              withDelegateCall: true,
              accessLevel: 1,
              value: 0n,
              signature: "execute()",
              callData: "0x0"
            }
          ]
        ],
        {}
      );
      const tenderlyPayload = await payloadsController.getSimulationPayloadForExecution(
        Number(await payloadsController.controllerContract.read.getPayloadsCount() - 1)
      );
      await tenderly.unwrapAndExecuteSimulationPayloadOnFork(fork, tenderlyPayload);
      return;
    }
    if (payloadId) {
      const payloadsController = getPayloadsController(
        payloadsControllerAddress,
        getClient(Number(chainId))
      );
      const payload = await payloadsController.getSimulationPayloadForExecution(
        Number(payloadId)
      );
      const fork = await tenderly.fork({
        ...forkConfig,
        blockNumber: forkConfig.blockNumber || payload.block_number
      });
      await tenderly.unwrapAndExecuteSimulationPayloadOnFork(fork, payload);
      return;
    }
    if (payloadAddress) {
      const fork = await tenderly.fork({
        ...forkConfig,
        blockNumber: forkConfig.blockNumber
      });
      const walletProvider = createWalletClient({
        account: EOA,
        chain: { id: fork.forkNetworkId, name: "tenderly" },
        transport: http3(fork.forkUrl)
      });
      const payloadsController = getPayloadsController(
        payloadsControllerAddress,
        walletProvider
      );
      await payloadsController.controllerContract.write.createPayload(
        [
          [
            {
              target: payloadAddress,
              withDelegateCall: true,
              accessLevel: 1,
              value: 0n,
              signature: "execute()",
              callData: "0x0"
            }
          ]
        ],
        {}
      );
      const tenderlyPayload = await payloadsController.getSimulationPayloadForExecution(
        Number(await payloadsController.controllerContract.read.getPayloadsCount() - 1)
      );
      await tenderly.unwrapAndExecuteSimulationPayloadOnFork(fork, tenderlyPayload);
    }
  });
}

// src/commands/governance.ts
import {
  IDataWarehouse_ABI,
  IVotingMachineWithProofs_ABI,
  IVotingPortal_ABI
} from "@bgd-labs/aave-address-book/abis";
import { confirm, input, select } from "@inquirer/prompts";
import { encodeAbiParameters as encodeAbiParameters2, encodeFunctionData as encodeFunctionData3, getContract as getContract6 } from "viem";

// src/govv3/checks/logs.ts
import { getAddress as getAddress3 } from "viem";

// src/govv3/utils/logInterpreter.ts
var tokenAmountEvents = ["Transfer", "Approval", "Burn", "Mint", "BalanceTransfer"];
var reserveEvents = ["Withdraw", "Supply", "Deposit"];
var assetFields = ["asset", "token", "reserve", "fromToken", "toToken"];
async function interpretLog(client, address, name, inputs) {
  if (inputs) {
    for (let i = 0; i < inputs.length; i++) {
      if (inputs[i].soltype?.name && assetFields.includes(inputs[i].soltype.name)) {
        inputs[i].value = await addAssetSymbol(client, inputs[i].value);
      }
    }
    if (name && tokenAmountEvents.includes(name)) {
      const decimalFieldNames = ["value", "amount", "wad"];
      for (const name2 of decimalFieldNames) {
        const valueIndex = inputs.findIndex((i) => i.soltype.name === name2);
        if (valueIndex !== -1) {
          const asset = await findAsset(client, address);
          if (asset) {
            inputs[valueIndex].value = prettifyNumber({
              showDecimals: true,
              value: inputs[valueIndex].value,
              decimals: asset.decimals
            });
          }
        }
      }
    }
    if (name && reserveEvents.includes(name)) {
      const valueIndex = inputs.findIndex((i) => i.soltype.name === "amount");
      const reserveIndex = inputs.findIndex((i) => i.soltype.name === "reserve");
      if (valueIndex !== -1 && reserveIndex !== -1) {
        const asset = await findAsset(client, inputs[reserveIndex].value);
        if (asset) {
          inputs[valueIndex].value = prettifyNumber({
            showDecimals: true,
            value: inputs[valueIndex].value,
            decimals: asset.decimals
          });
        }
      }
    }
    if (name && ["Mint", "ReserveDataUpdated", "Burn"].includes(name)) {
      const decimalFieldNames = ["liquidityIndex", "variableBorrowIndex", "index"];
      for (const name2 of decimalFieldNames) {
        const valueIndex = inputs.findIndex((i) => i.soltype.name === name2);
        if (valueIndex !== -1) {
          inputs[valueIndex].value = prettifyNumber({
            showDecimals: true,
            value: inputs[valueIndex].value,
            decimals: 27
          });
        }
      }
    }
  }
  const parsedInputs = inputs?.map(
    (i) => `${i.soltype.name}: ${typeof i.value === "object" ? JSON.stringify(i.value) : i.value}`
  ).join(", ");
  return `  - \`${name}(${parsedInputs || ""})\``;
}

// src/govv3/utils/solidityUtils.ts
import { getAddress as getAddress2 } from "viem";
function getContractName(contracts, address, chainId) {
  const isAddrKnown = isKnownAddress(address, chainId);
  const contract = contracts.find((c) => c.address.toLowerCase() === address.toLowerCase());
  if (!contract)
    return `unknown contract name at \`${getAddress2(address)}\`${flagKnownAddress(isAddrKnown)}`;
  let contractName = contract?.contract_name;
  if (contract?.token_data?.name) contractName += ` (${contract?.token_data?.name})`;
  if (contract.standards?.includes("eip1967") && contract.child_contracts?.[0].address) {
    return `${contractName} at \`${getAddress2(address)}\`${flagKnownAddress(
      isAddrKnown
    )} with implementation ${getContractName(contracts, contract.child_contracts?.[0].address, chainId)}`;
  }
  return `${contractName} at \`${getAddress2(address)}\`${flagKnownAddress(isAddrKnown)}`;
}

// src/govv3/checks/logs.ts
var checkLogs = {
  name: "Reports all events emitted from the proposal",
  async checkProposal(proposal, sim, client) {
    const info = [];
    const events = sim.transaction.transaction_info.logs?.reduce(
      (logs, log) => {
        const addr = getAddress3(log.raw.address);
        if (!logs[addr]) logs[addr] = [log];
        else logs[addr].push(log);
        return logs;
      },
      {}
    );
    if (!events || !Object.keys(events).length)
      return { info: ["No events emitted"], warnings: [], errors: [] };
    for (const [address, logs] of Object.entries(events)) {
      info.push(`- ${getContractName(sim.contracts, address, client.chain.id)}`);
      for (const log of logs) {
        if (log.name) {
          info.push(await interpretLog(client, address, log.name, log.inputs));
        } else {
          info.push(`  - Undecoded log: \`${JSON.stringify(log)}\``);
        }
      }
    }
    return { info, warnings: [], errors: [] };
  }
};

// src/govv3/checks/selfDestruct.ts
import { getBytecode, getTransactionCount } from "viem/actions";
var checkTargetsNoSelfdestruct = {
  name: "Check all targets do not contain selfdestruct",
  async checkProposal(proposal, sim, client) {
    const allTargets = proposal.payload.actions.map((action) => action.target);
    const uniqueTargets = allTargets.filter((addr, i, targets) => targets.indexOf(addr) === i);
    const { info, warn, error } = await checkNoSelfdestructs([], uniqueTargets, client);
    return { info, warnings: warn, errors: error };
  }
};
var checkTouchedContractsNoSelfdestruct = {
  name: "Check all touched contracts do not contain selfdestruct",
  async checkProposal(proposal, sim, client) {
    const { info, warn, error } = await checkNoSelfdestructs([], sim.transaction.addresses, client);
    return { info, warnings: warn, errors: error };
  }
};
async function checkNoSelfdestructs(trustedAddrs, addresses2, client) {
  const info = [];
  const warn = [];
  const error = [];
  for (const addr of addresses2) {
    const status = await checkNoSelfdestruct(trustedAddrs, addr, client);
    const isAddrKnown = isKnownAddress(addr, client.chain.id);
    const address = toAddressLink(addr, true, client);
    if (status === "eoa") info.push(`- ${address}: EOA${flagKnownAddress(isAddrKnown)}`);
    else if (status === "empty")
      warn.push(`- ${address}: EOA (may have code later)${flagKnownAddress(isAddrKnown)}`);
    else if (status === "safe")
      info.push(`- ${address}: Contract (looks safe)${flagKnownAddress(isAddrKnown)}`);
    else if (status === "delegatecall")
      warn.push(`- ${address}: Contract (with DELEGATECALL)${flagKnownAddress(isAddrKnown)}`);
    else if (status === "trusted")
      info.push(`- ${address}: Trusted contract (not checked)${flagKnownAddress(isAddrKnown)}`);
    else error.push(`- ${address}: Contract (with SELFDESTRUCT)${flagKnownAddress(isAddrKnown)}`);
  }
  return { info, warn, error };
}
var STOP = 0;
var JUMPDEST = 91;
var PUSH1 = 96;
var PUSH32 = 127;
var RETURN = 243;
var REVERT = 253;
var INVALID = 254;
var SELFDESTRUCT = 255;
var DELEGATECALL = 244;
var isHalting = (opcode) => [STOP, RETURN, REVERT, INVALID, SELFDESTRUCT].includes(opcode);
var isPUSH = (opcode) => opcode >= PUSH1 && opcode <= PUSH32;
async function checkNoSelfdestruct(trustedAddrs, addr, client) {
  if (trustedAddrs.map((addr2) => addr2.toLowerCase()).includes(addr.toLowerCase())) return "trusted";
  const [code, nonce] = await Promise.all([
    getBytecode(client, { address: addr }),
    getTransactionCount(client, { address: addr })
  ]);
  if (!code) return nonce > 0 ? "eoa" : "empty";
  const bytecode = Buffer.from(code.substring(2), "hex");
  let halted = false;
  let delegatecall = false;
  for (let index = 0; index < bytecode.length; index++) {
    const opcode = bytecode[index];
    if (opcode === SELFDESTRUCT && !halted) {
      return "selfdestruct";
    }
    if (opcode === DELEGATECALL && !halted) {
      delegatecall = true;
    } else if (opcode === JUMPDEST) {
      halted = false;
    } else if (isHalting(opcode)) {
      halted = true;
    } else if (isPUSH(opcode)) {
      index += opcode - PUSH1 + 1;
    }
  }
  return delegatecall ? "delegatecall" : "safe";
}

// src/govv3/checks/state.ts
import { getAddress as getAddress4 } from "viem";

// src/govv3/utils/reserveConfigurationInterpreter.ts
import * as pools from "@bgd-labs/aave-address-book";
function getDecodedReserveData(contractAddress, data) {
  if (!data) return data;
  if ([
    pools.AaveV2EthereumAMM.POOL,
    pools.AaveV2Ethereum.POOL,
    pools.AaveV2Polygon.POOL,
    pools.AaveV2Avalanche.POOL
  ].map((address) => address.toLowerCase()).includes(contractAddress.toLowerCase()))
    return decodeReserveDataV2(data);
  return decodeReserveDataV3(data);
}
function decodeReserveDataV2(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const reserveFactor = getBits(data, 64n, 79n);
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableBorrowingEnabled: !!stableBorrowingEnabled,
    reserveFactor
  };
}
function decodeReserveDataV3(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableRateBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const paused = Number(getBits(data, 60n, 60n));
  const borrowingInIsolation = Number(getBits(data, 61n, 61n));
  const siloedBorrowingEnabled = Number(getBits(data, 62n, 62n));
  const flashloaningEnabled = Number(getBits(data, 63n, 63n));
  const reserveFactor = getBits(data, 64n, 79n);
  const borrowCap = getBits(data, 80n, 115n);
  const supplyCap = getBits(data, 116n, 151n);
  const liquidationProtocolFee = getBits(data, 152n, 167n);
  const eModeCategory = getBits(data, 168n, 175n);
  const unbackedMintCap = getBits(data, 176n, 211n);
  const debtCeiling = getBits(data, 212n, 251n);
  const virtualAccountingEnabled = Number(getBits(data, 252n, 252n));
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableRateBorrowingEnabled,
    paused,
    borrowingInIsolation,
    reserveFactor,
    borrowCap,
    supplyCap,
    liquidationProtocolFee,
    eModeCategory,
    unbackedMintCap,
    debtCeiling,
    siloedBorrowingEnabled: !!siloedBorrowingEnabled,
    flashloaningEnabled: !!flashloaningEnabled,
    virtualAccountingEnabled: !!virtualAccountingEnabled
  };
}

// src/govv3/checks/state.ts
function resolveChain(chain) {
  return chain.join(".");
}
function getContractChanges(diffs) {
  const changes = [];
  for (const diff2 of diffs) {
    if (!diff2.soltype) {
      for (const w of diff2.raw) {
        const oldVal = JSON.stringify(w.original);
        const newVal = JSON.stringify(w.dirty);
        changes.push({ before: oldVal, after: newVal, name: `Slot \`${w.key}\`` });
      }
    } else if (diff2.soltype.simple_type) {
      changes.push({
        before: diff2.original,
        after: diff2.dirty,
        name: diff2.soltype.name,
        type: diff2.soltype?.name
      });
    } else if (diff2.soltype.type.startsWith("mapping")) {
      const keys = Object.keys(diff2.original);
      const original = diff2.original;
      const dirty = diff2.dirty;
      for (const k of keys) {
        changes.push({ before: original[k], after: dirty[k], name: k, type: diff2.soltype?.name });
      }
    } else {
      for (const w of diff2.raw) {
        const oldVal = JSON.stringify(w.original);
        const newVal = JSON.stringify(w.dirty);
        changes.push({ before: oldVal, after: newVal, name: `Slot \`${w.key}\`` });
        console.log(
          `Could not parse state: add support for formatting type ${diff2.soltype?.type} (slot ${w.key})
`
        );
      }
    }
  }
  return changes;
}
async function renderContractChanges(simulation, client, address, changes) {
  let stateChanges = `
${getContractName(simulation.contracts, address, client.chain.id)}
\`\`\`diff
`;
  for (const change of changes) {
    stateChanges += await deepDiff({
      client,
      address,
      before: change.before,
      after: change.after,
      accessChain: [change.name],
      type: change.type
    });
  }
  stateChanges += "```\n";
  return stateChanges;
}
async function deepDiff({
  client,
  address,
  before,
  after,
  accessChain,
  type
}) {
  if (type && accessChain.length === 1 && ["_reserves", "assets", "assetsSources"].includes(type)) {
    accessChain[0] = await addAssetSymbol(client, accessChain[0]);
  }
  if (typeof before !== "object" || typeof after !== "object") {
    return `@@ ${type ? `${wrapInQuotes(type, true)} key ` : ""}${wrapInQuotes(
      resolveChain(accessChain),
      !!type
    )} @@
- ${await enhanceValue({ client, address, value: before, type, accessChain })}
+ ${await enhanceValue(
      {
        client,
        address,
        value: after,
        type,
        accessChain
      }
    )}
`;
  }
  let result = "";
  if (type === "_reserves" && (before.configuration?.data || after.configuration?.data)) {
    before.configuration.data_decoded = getDecodedReserveData(address, before.configuration.data);
    after.configuration.data_decoded = getDecodedReserveData(address, after.configuration.data);
  }
  if (type === "_eModeCategories") {
    if (before.collateralBitmap !== void 0) {
      before.collateralBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(before.collateralBitmap || 0))
      )).toString();
      before.collateralBitmap = toBinaryString(BigInt(before.collateralBitmap || 0));
      after.collateralBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(after.collateralBitmap || 0))
      )).toString();
      after.collateralBitmap = toBinaryString(BigInt(after.collateralBitmap || 0));
    }
    if (before.borrowableBitmap !== void 0) {
      before.borrowableBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(before.borrowableBitmap || 0))
      )).toString();
      before.borrowableBitmap = toBinaryString(BigInt(before.borrowableBitmap || 0));
      after.borrowableBitmap_decoded = (await assetIndexesToAsset(
        client,
        address,
        bitMapToIndexes(BigInt(after.borrowableBitmap || 0))
      )).toString();
      after.borrowableBitmap = toBinaryString(BigInt(after.borrowableBitmap || 0));
    }
  }
  if (type === "_streams") {
    const asset = await findAsset(client, after.tokenAddress);
    after.ratePerSecond = prettifyNumber({
      decimals: asset.decimals,
      value: after.ratePerSecond,
      showDecimals: true
    });
    after.remainingBalance = prettifyNumber({
      showDecimals: true,
      decimals: asset.decimals,
      value: after.remainingBalance
    });
  }
  for (const key of Object.keys(before)) {
    if (before[key] === after[key]) continue;
    const newAccessChain = [...accessChain];
    newAccessChain.push(key);
    if (typeof before[key] === "object") {
      result += await deepDiff({
        client,
        address,
        before: before[key],
        after: after[key],
        accessChain: newAccessChain,
        type
      });
    } else
      result += `@@ ${type ? `${wrapInQuotes(type, true)} key ` : ""}${wrapInQuotes(
        resolveChain([...accessChain, key]),
        !!type
      )} @@
- ${await enhanceValue({
        client,
        address,
        value: before[key],
        type,
        accessChain: newAccessChain
      })}
+ ${await enhanceValue({
        client,
        address,
        value: after[key],
        type,
        accessChain: newAccessChain
      })}
`;
  }
  return result;
}
async function enhanceValue({
  client,
  address,
  value,
  type,
  accessChain
}) {
  const key = accessChain[accessChain?.length - 1];
  if (key === "tokenAddress") {
    return addAssetSymbol(client, value);
  }
  if (type) {
    if (type === "assetsSources") {
      return addAssetPrice(client, value);
    }
    if ([
      "_balances",
      "balanceOf",
      "balances",
      "allowed",
      "_allowances",
      "allowance",
      "_totalSupply"
    ].includes(type)) {
      const asset = await findAsset(client, address);
      if (asset) return prettifyNumber({ decimals: asset.decimals, value, showDecimals: true });
    }
    if (key && ["_reserves", "_eModeCategories"].includes(type)) {
      if (["liquidityIndex", "variableBorrowIndex"].includes(key))
        return prettifyNumber({ decimals: 27, value, showDecimals: true });
      if (["liquidationThreshold", "reserveFactor", "liquidationProtocolFee", "ltv"].includes(key))
        return prettifyNumber({ decimals: 2, value, suffix: "%", showDecimals: true });
      if (["currentLiquidityRate", "currentVariableBorrowRate", "currentStableBorrowRate"].includes(
        key
      ))
        return prettifyNumber({ decimals: 25, value, suffix: "%", showDecimals: true });
      if (["liquidationBonus"].includes(key))
        return prettifyNumber({
          decimals: 2,
          value,
          suffix: "%",
          showDecimals: true,
          patchedValue: BigInt(value) == 0n ? 0n : BigInt(value) - BigInt(1e4)
        });
    }
  }
  return value;
}
var checkStateChanges = {
  name: "Reports all state changes",
  async checkProposal(proposal, simulation, client) {
    const info = [];
    const warnings = [];
    const errors = [];
    if (!simulation.transaction.status) {
      const txInfo = simulation.transaction.transaction_info;
      const reason = txInfo.stack_trace ? txInfo.stack_trace[0].error_reason : "unknown error";
      errors.push(`Transaction reverted with reason: ${reason}`);
    } else {
      const stateDiffs = simulation.transaction.transaction_info.state_diff.reduce(
        (diffs, diff2) => {
          if (!diff2.raw?.[0]) return diffs;
          const addr = getAddress4(diff2.raw[0].address);
          if (!diffs[addr]) diffs[addr] = [diff2];
          else diffs[addr].push(diff2);
          return diffs;
        },
        {}
      );
      if (!Object.keys(stateDiffs).length) {
        warnings.push("No state changes detected");
      } else {
        let stateChanges = "";
        const warnings2 = "";
        for (const [address, diffs] of Object.entries(stateDiffs)) {
          const changes = getContractChanges(diffs);
          stateChanges += await renderContractChanges(simulation, client, address, changes);
        }
        info.push(stateChanges);
      }
    }
    return { info, warnings, errors };
  }
};
function toBinaryString(value) {
  return `0b` + value.toString(2);
}

// src/govv3/checks/targetsVerified.ts
import { getBytecode as getBytecode2 } from "viem/actions";
var checkTargetsVerifiedEtherscan = {
  name: "Check all targets are verified on Etherscan",
  async checkProposal(proposal, sim, client) {
    const allTargets = proposal.payload.actions.map((action) => action.target);
    const uniqueTargets = allTargets.filter((addr, i, targets) => targets.indexOf(addr) === i);
    const info = await checkVerificationStatuses(sim, uniqueTargets, client);
    return { info, warnings: [], errors: [] };
  }
};
var checkTouchedContractsVerifiedEtherscan = {
  name: "Check all touched contracts are verified on Etherscan",
  async checkProposal(proposal, sim, client) {
    const info = await checkVerificationStatuses(sim, sim.transaction.addresses, client);
    return { info, warnings: [], errors: [] };
  }
};
async function checkVerificationStatuses(sim, addresses2, client) {
  const info = [];
  for (const addr of addresses2) {
    const isAddrKnown = isKnownAddress(addr, client.chain.id);
    const status = await checkVerificationStatus(sim, addr, client);
    if (status === "eoa") {
      info.push(`- ${addr}: EOA (verification not applicable)`);
    } else if (status === "verified") {
      const contract = getContract5(sim, addr);
      info.push(
        `- ${addr}: Contract (verified) (${contract?.contract_name}) ${flagKnownAddress(isAddrKnown)}`
      );
    } else {
      info.push(`- ${addr}: Contract (not verified) ${flagKnownAddress(isAddrKnown)}`);
    }
  }
  return info;
}
async function checkVerificationStatus(sim, addr, client) {
  const contract = getContract5(sim, addr);
  if (contract) return "verified";
  const stateDiff = getStateDiff(sim, addr);
  if (stateDiff) return "unverified";
  const code = await getBytecode2(client, { address: addr });
  return code === void 0 ? "eoa" : "unverified";
}
function getContract5(sim, addr) {
  return sim.contracts.find((item) => item.address === addr);
}
function getStateDiff(sim, addr) {
  return sim.transaction.transaction_info.state_diff?.find(
    (diff2) => diff2.raw?.[0]?.address.toLowerCase() === addr.toLowerCase()
  );
}

// src/govv3/generatePayloadReport.ts
async function generateReport({
  payloadId,
  payloadInfo,
  simulation,
  client
}) {
  const {
    payload,
    logs: { executedLog, queuedLog, createdLog }
  } = payloadInfo;
  let report = `## Payload ${payloadId} on ${client.chain.name}

- Simulation: [https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id}](https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id})
- creator: ${payload.creator}
- maximumAccessLevelRequired: ${payload.maximumAccessLevelRequired}
- state: ${payload.state}(${HUMAN_READABLE_PAYLOAD_STATE[payload.state]})
- actions: ${JSON.stringify(payload.actions, (key, value) => typeof value === "bigint" ? value.toString() : value)}
- createdAt: [${renderUnixTime(payload.createdAt)}](${toTxLink(createdLog.transactionHash, false, client)})
`;
  if (queuedLog) {
    report += `- queuedAt: [${renderUnixTime(payload.queuedAt)}](${toTxLink(
      queuedLog.transactionHash,
      false,
      client
    )})
`;
    if (executedLog) {
      report += `- executedAt: [${renderUnixTime(payload.executedAt)}, timestamp: ${executedLog.timestamp}, block: ${executedLog.blockNumber}](${toTxLink(
        executedLog.transactionHash,
        false,
        client
      )})
`;
    } else {
      report += `- earliest execution at: [${renderUnixTime(
        payload.queuedAt + payload.delay
      )}](https://www.epochconverter.com/countdown?q=${payload.queuedAt + payload.delay})
`;
      const timestamp = Math.floor(new Date(simulation.transaction.timestamp).getTime() / 1e3);
      report += `- simulatedExecutionAt: ${renderUnixTime(
        timestamp
      )}, timestamp: ${timestamp}, block: ${simulation.transaction.block_number}`;
    }
  }
  report += "\n";
  const checks = [
    checkStateChanges,
    checkLogs,
    checkTargetsVerifiedEtherscan,
    checkTouchedContractsVerifiedEtherscan,
    checkTargetsNoSelfdestruct,
    checkTouchedContractsNoSelfdestruct
  ];
  for (const check of checks) {
    const result = await check.checkProposal(payloadInfo, simulation, client);
    report += renderCheckResult(check, result);
  }
  return report;
}

// src/govv3/generateProposalReport.ts
async function generateProposalReport({
  proposalId,
  proposalInfo,
  simulation,
  client,
  formattedPayloads
}) {
  const {
    proposal,
    logs: { executedLog, queuedLog, createdLog, payloadSentLog, votingActivatedLog },
    ipfs
  } = proposalInfo;
  let report = `## Proposal ${proposalId}

- Simulation: [https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id}](https://dashboard.tenderly.co/me/simulator/${simulation.simulation.id})
- state: ${HUMAN_READABLE_STATE[proposal.state]}
- creator: ${proposal.creator}
- maximumAccessLevelRequired: ${proposal.accessLevel}
- payloads: 
  ${formattedPayloads ? formattedPayloads.map((payload) => `  - ${payload}
`).join() : JSON.stringify(
    proposal.payloads,
    (key, value) => typeof value === "bigint" ? value.toString() : value
  )}
- createdAt: [${renderUnixTime(proposal.creationTime)}](${toTxLink(createdLog.transactionHash, false, client)})
`;
  if (queuedLog) {
    report += `- queuedAt: [${renderUnixTime(proposal.queuingTime)}](${toTxLink(
      queuedLog.transactionHash,
      false,
      client
    )})
`;
  }
  if (executedLog) {
    report += `- executedAt: [${renderUnixTime(executedLog.timestamp)}, timestamp: ${executedLog.timestamp}, block: ${executedLog.blockNumber}](${toTxLink(
      executedLog.transactionHash,
      false,
      client
    )})
`;
  } else {
    const timestamp = Math.floor(new Date(simulation.transaction.timestamp).getTime() / 1e3);
    report += `- simulatedExecutionAt: ${renderUnixTime(
      timestamp
    )}, timestamp: ${timestamp}, block: ${simulation.transaction.block_number}`;
  }
  report += "\n";
  report += `### Ipfs

<details>
  <summary>${ipfs?.title || "problem fetching ipfs metadata"}</summary>
  
  ${ipfs?.description || "problem fetching ipfs metadata"}
</details>

`;
  const checks = [
    checkStateChanges,
    checkLogs,
    checkTouchedContractsVerifiedEtherscan,
    checkTouchedContractsNoSelfdestruct
  ];
  for (const check of checks) {
    const result = await check.checkProposal(proposalInfo, simulation, client);
    report += renderCheckResult(check, result);
  }
  return report;
}

// src/govv3/simulate.ts
import { refreshCache } from "@bgd-labs/aave-v3-governance-cache/refreshCache";
import { customStorageProvider } from "@bgd-labs/aave-v3-governance-cache/customStorageProvider";
import { fileSystemStorageAdapter } from "@bgd-labs/aave-v3-governance-cache/fileSystemStorageAdapter";
var localCacheAdapter = customStorageProvider(fileSystemStorageAdapter);
async function simulateProposal(governanceAddress, client, proposalId) {
  logInfo("General", `Running simulation for ${proposalId}`);
  const governance = getGovernance({ address: governanceAddress, client });
  await refreshCache(localCacheAdapter);
  const proposal = await localCacheAdapter.getProposal({
    chainId: client.chain.id,
    governance: governanceAddress,
    proposalId
  });
  const result = await governance.simulateProposalExecutionOnTenderly(proposalId, proposal.logs);
  console.log(
    await generateProposalReport({
      simulation: result,
      proposalId,
      proposalInfo: proposal,
      client
    })
  );
  const payloads = [];
  for (const payload of proposal.proposal.payloads) {
    const client2 = getClient(Number(payload.chain));
    const controllerContract = getPayloadsController(payload.payloadsController, client2);
    const cache = await localCacheAdapter.getPayload({
      payloadId: payload.payloadId,
      chainId: Number(payload.chain),
      payloadsController: payload.payloadsController
    });
    try {
      const result2 = await controllerContract.simulatePayloadExecutionOnTenderly(
        payload.payloadId,
        cache.logs
      );
      console.log(
        await generateReport({
          simulation: result2,
          payloadId: payload.payloadId,
          payloadInfo: cache,
          client: getClient(Number(payload.chain))
        })
      );
      payloads.push({ payload: cache, simulation: result2 });
    } catch (e) {
      console.log("error simulating payload");
      console.log(e);
    }
  }
  return { proposal, payloads };
}

// src/commands/governance.ts
import { getBlock as getBlock5 } from "viem/actions";
import { customStorageProvider as customStorageProvider2 } from "@bgd-labs/aave-v3-governance-cache/customStorageProvider";
import { fileSystemStorageAdapter as fileSystemStorageAdapter2 } from "@bgd-labs/aave-v3-governance-cache/fileSystemStorageAdapter";
import { refreshCache as refreshCache2 } from "@bgd-labs/aave-v3-governance-cache/refreshCache";
var localCacheAdapter2 = customStorageProvider2(fileSystemStorageAdapter2);
function addCommand3(program2) {
  const govV3 = program2.command("governance").description("interact with governance v3 contracts");
  govV3.command("simulate").description("simulates a proposal on tenderly").requiredOption("--proposalId <number>", "proposalId to simulate via tenderly").action(async (name, options) => {
    const proposalId = BigInt(options.getOptionValue("proposalId"));
    await simulateProposal(DEFAULT_GOVERNANCE, DEFAULT_GOVERNANCE_CLIENT, proposalId);
  });
  govV3.command("simulate-payload").description("simulates a payloadId on tenderly").requiredOption("--chainId <number>", "the chainId to fork of").requiredOption("--payloadId <number>", "payloadId to simulate via tenderly").action(async ({ payloadId: _payloadId, chainId }, options) => {
    await refreshCache2(localCacheAdapter2);
    const payloadId = Number(_payloadId);
    const client = getClient(Number(chainId));
    const payloadsControllerAddress = findPayloadsController(Number(chainId));
    const payloadsController = getPayloadsController(payloadsControllerAddress, client);
    const cache = await localCacheAdapter2.getPayload({
      chainId: Number(chainId),
      payloadsController: payloadsControllerAddress,
      payloadId: Number(payloadId)
    });
    const result = await payloadsController.simulatePayloadExecutionOnTenderly(
      Number(payloadId),
      cache.logs
    );
    console.log(
      await generateReport({
        simulation: result,
        payloadId,
        payloadInfo: cache,
        client
      })
    );
  });
  govV3.command("view").description("shows all the proposals & state").action(async (opts) => {
    await refreshCache2(localCacheAdapter2);
    const governance = getGovernance({
      address: DEFAULT_GOVERNANCE,
      client: DEFAULT_GOVERNANCE_CLIENT
    });
    const count = await governance.governanceContract.read.getProposalsCount();
    const proposalIds = [...Array(Number(count)).keys()].reverse();
    const selectedProposalId = BigInt(
      await select({
        message: "Select a proposal to get more information",
        choices: await Promise.all(
          proposalIds.map(async (id) => {
            const proposalCache = await localCacheAdapter2.getProposal({
              chainId: DEFAULT_GOVERNANCE_CLIENT.chain.id,
              governance: DEFAULT_GOVERNANCE,
              proposalId: BigInt(id)
            });
            const title = `${id} - ${HUMAN_READABLE_STATE[proposalCache.proposal.state]} | ${proposalCache.ipfs?.title || "problems fetching ipfs meta"}`;
            return { name: title, value: id };
          })
        )
      })
    );
    const cache = await localCacheAdapter2.getProposal({
      chainId: DEFAULT_GOVERNANCE_CLIENT.chain.id,
      governance: DEFAULT_GOVERNANCE,
      proposalId: selectedProposalId
    });
    let exitLvl2 = false;
    while (!exitLvl2) {
      const moreInfo = await select({
        message: "What do you want to do?",
        choices: [
          {
            name: "Show details",
            value: 0 /* DETAILS */
          },
          {
            name: "Show ipfs details",
            value: 1 /* IPFS_TEXT */
          },
          {
            name: "Show transactions",
            value: 2 /* TRANSACTIONS */
          },
          {
            name: "Show me How to vote",
            value: 3 /* HOW_TO_VOTE */
          },
          {
            name: "Show me How to register storage roots",
            value: 4 /* HOW_TO_REGISTER_STORAGE_ROOTS */
          },
          {
            name: "Exit",
            value: 5 /* EXIT */
          }
        ]
      });
      if (moreInfo === 5 /* EXIT */) {
        exitLvl2 = true;
        process.exit(0);
      }
      if (moreInfo === 1 /* IPFS_TEXT */) {
        logInfo("title", cache.ipfs?.title || "problem fetching ipfs metadata");
        logInfo("author", cache.ipfs?.author || "problem fetching ipfs metadata");
        logInfo("discussion", cache.ipfs?.discussions || "problem fetching ipfs metadata");
        logInfo("description", cache.ipfs?.description || "problem fetching ipfs metadata");
      }
      if (moreInfo === 2 /* TRANSACTIONS */) {
        logInfo(
          "CreatedLog",
          toTxLink(cache.logs.createdLog.transactionHash, false, DEFAULT_GOVERNANCE_CLIENT)
        );
        if (cache.logs.votingActivatedLog)
          logInfo(
            "VotingActivated",
            toTxLink(
              cache.logs.votingActivatedLog.transactionHash,
              false,
              DEFAULT_GOVERNANCE_CLIENT
            )
          );
        if (cache.logs.queuedLog)
          logInfo(
            "QueuedLog",
            toTxLink(cache.logs.queuedLog.transactionHash, false, DEFAULT_GOVERNANCE_CLIENT)
          );
        if (cache.logs.executedLog)
          logInfo(
            "ExecutedLog",
            toTxLink(cache.logs.executedLog.transactionHash, false, DEFAULT_GOVERNANCE_CLIENT)
          );
      }
      if (moreInfo === 0 /* DETAILS */) {
        logInfo("Creator", cache.proposal.creator);
        logInfo("ForVotes", cache.proposal.forVotes);
        logInfo("AgainstVotes", cache.proposal.againstVotes);
        logInfo("AccessLevel", cache.proposal.accessLevel);
        logInfo("VotingPortal", cache.proposal.votingPortal);
        cache.proposal.payloads.map((payload, ix) => {
          logInfo(`Payload.${ix}.accessLevel`, payload.accessLevel);
          logInfo(`Payload.${ix}.chain`, getClient(Number(payload.chain)).chain.name);
          logInfo(`Payload.${ix}.payloadId`, payload.payloadId);
          logInfo(`Payload.${ix}.payloadsController`, payload.payloadsController);
        });
      }
      if (moreInfo === 3 /* HOW_TO_VOTE */) {
        const address = await input({
          message: "Enter the address you would like to vote with"
        });
        const support = await confirm({
          message: "Are you in Support of the proposal?"
        });
        const portal = getContract6({
          address: cache.proposal.votingPortal,
          abi: IVotingPortal_ABI,
          client: DEFAULT_GOVERNANCE_CLIENT
        });
        const [machine, chainId] = await Promise.all([
          portal.read.VOTING_MACHINE(),
          portal.read.VOTING_MACHINE_CHAIN_ID()
        ]);
        const proofs = await governance.getVotingProofs(selectedProposalId, address, chainId);
        if (proofs.length === 0) logError("Voting Error", "You need voting power to vote");
        else {
          logSuccess("VotingMachine", toAddressLink(machine, false, getClient(Number(chainId))));
          if (FORMAT === "raw") {
            logSuccess("Method", "submitVote");
            logSuccess("parameter proposalId", selectedProposalId);
            logSuccess("parameter support", String(support));
            logSuccess(
              "parameter votingBalanceProofs",
              JSON.stringify(proofs.map((p) => [p.underlyingAsset, p.slot.toString(), p.proof]))
            );
          } else {
            logSuccess(
              "encoded calldata",
              encodeFunctionData3({
                abi: IVotingMachineWithProofs_ABI,
                functionName: "submitVote",
                args: [selectedProposalId, support, proofs]
              })
            );
          }
        }
      }
      if (moreInfo === 4 /* HOW_TO_REGISTER_STORAGE_ROOTS */) {
        const portalContract = getContract6({
          address: cache.proposal.votingPortal,
          abi: IVotingPortal_ABI,
          client: DEFAULT_GOVERNANCE_CLIENT
        });
        const [machine, chainId] = await Promise.all([
          portalContract.read.VOTING_MACHINE(),
          portalContract.read.VOTING_MACHINE_CHAIN_ID()
        ]);
        const machineContract = getContract6({
          address: machine,
          abi: IVotingMachineWithProofs_ABI,
          client: getClient(Number(chainId))
        });
        const dataWarehouse = await machineContract.read.DATA_WAREHOUSE();
        const roots = await governance.getStorageRoots(selectedProposalId);
        logSuccess(
          "DataWarehouse",
          toAddressLink(dataWarehouse, false, getClient(Number(chainId)))
        );
        const block = await getBlock5(DEFAULT_GOVERNANCE_CLIENT, {
          blockHash: cache.proposal.snapshotBlockHash
        });
        const blockRPL = getBlockRLP(block);
        console.log(FORMAT);
        if (FORMAT === "raw") {
          logSuccess("Method", "processStorageRoot");
          roots.map((root, ix) => {
            const accountRPL = getAccountRPL(root.accountProof);
            logSuccess(`account.${ix}`, root.address);
            logSuccess(`blockHash.${ix}`, cache.proposal.snapshotBlockHash);
            logSuccess(`blockHeaderRPL.${ix}`, blockRPL);
            logSuccess(`accountStateProofRPL.${ix}`, accountRPL);
          });
        } else {
          roots.map((root, ix) => {
            const accountRPL = getAccountRPL(root.accountProof);
            logSuccess(
              "Encoded callData",
              encodeFunctionData3({
                abi: IDataWarehouse_ABI,
                functionName: "processStorageRoot",
                args: [root.address, cache.proposal.snapshotBlockHash, blockRPL, accountRPL]
              })
            );
          });
        }
      }
    }
  });
  govV3.command("getStorageRoots").description("generate the storage roots for the warehouse").requiredOption("--proposalId <number>", "proposalId to generate the proof for").action(async (name, options) => {
    const governance = getGovernance({
      address: DEFAULT_GOVERNANCE,
      client: DEFAULT_GOVERNANCE_CLIENT
    });
    const proposalId = BigInt(options.getOptionValue("proposalId"));
    const proposal = await governance.governanceContract.read.getProposal([proposalId]);
    const roots = await governance.getStorageRoots(proposalId);
    const block = await getBlock5(DEFAULT_GOVERNANCE_CLIENT, {
      blockHash: proposal.snapshotBlockHash
    });
    const blockRPL = getBlockRLP(block);
    const params = roots.map((root) => {
      const accountRPL = getAccountRPL(root.accountProof);
      return {
        account: root.address,
        blockHash: proposal.snapshotBlockHash,
        blockHeaderRPL: blockRPL,
        accountStateProofRPL: accountRPL
      };
    });
    console.log(
      encodeAbiParameters2(
        [
          {
            name: "params",
            type: "tuple[]",
            components: [
              { name: "account", type: "address" },
              { name: "blockHash", type: "bytes32" },
              { name: "blockHeaderRPL", type: "bytes" },
              { name: "accountStateProofRPL", type: "bytes" }
            ]
          }
        ],
        [params]
      )
    );
  });
  govV3.command("getVotingProofs").description("generates the proofs for voting").requiredOption("--proposalId <number>", "proposalId to generate the proof for").requiredOption("--voter <string>", "the address to vote").action(async (name, options) => {
    const governance = getGovernance({
      address: DEFAULT_GOVERNANCE,
      client: DEFAULT_GOVERNANCE_CLIENT
    });
    const proposalId = BigInt(options.getOptionValue("proposalId"));
    const voter = options.getOptionValue("voter");
    const proposal = await governance.governanceContract.read.getProposal([proposalId]);
    const portal = getContract6({
      address: proposal.votingPortal,
      abi: IVotingPortal_ABI,
      client: DEFAULT_GOVERNANCE_CLIENT
    });
    const chainId = await portal.read.VOTING_MACHINE_CHAIN_ID();
    const proofs = await governance.getVotingProofs(proposalId, voter, chainId);
    console.log(
      encodeAbiParameters2(
        [
          {
            name: "proofs",
            type: "tuple[]",
            components: [
              { name: "underlyingAsset", type: "address" },
              { name: "slot", type: "uint128" },
              { name: "proof", type: "bytes" }
            ]
          }
        ],
        [proofs]
      )
    );
  });
}

// src/commands/ipfsUpload.ts
var import_bs58 = __toESM(require_bs58(), 1);
import fs3 from "node:fs";
import path4 from "node:path";

// src/ipfs/aipValidation.ts
import matter from "gray-matter";
import { z } from "zod";
var aipType = z.object({
  discussions: z.string(),
  title: z.string(),
  author: z.string(),
  snapshot: z.string().optional()
});
function validateAIPHeader(content) {
  const fm = matter(content);
  try {
    aipType.parse(fm.data);
  } catch (e) {
    logError("AIP", "AIP validation failed");
    e.issues.map(
      (issue) => logError(
        "AIP",
        `On field ${issue.path[0]} received ${issue.received} but expected ${issue.expected}`
      )
    );
    throw e;
  }
  return fm.data.title;
}

// src/ipfs/onlyHash.ts
import { importer } from "ipfs-unixfs-importer";
import { MemoryBlockstore } from "blockstore-core";
var Hash = {
  of: async (content, options = {}) => {
    options = options || {};
    if (typeof content === "string") {
      content = new TextEncoder().encode(content);
    }
    let lastCid;
    for await (const { cid } of importer([{ content }], new MemoryBlockstore(), {
      cidVersion: 0,
      rawLeaves: false
    })) {
      lastCid = cid;
    }
    return `${lastCid}`;
  }
};

// src/commands/ipfsUpload.ts
async function getHash(data) {
  return Hash.of(data);
}
async function uploadToPinata(source) {
  const PINATA_KEY = process.env.PINATA_KEY;
  if (!PINATA_KEY) throw new Error("PINATA_KEY env must be set");
  const PINATA_SECRET = process.env.PINATA_SECRET;
  if (!PINATA_SECRET) throw new Error("PINATA_SECRET env must be set");
  const data = new FormData();
  data.append("file", new Blob([source]));
  const res = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
    method: "POST",
    body: data,
    headers: {
      pinata_api_key: PINATA_KEY,
      pinata_secret_api_key: PINATA_SECRET
    }
  });
  if (!res.ok) {
    throw Error(await res.text());
  }
  const result = await res.json();
  if (result.error) throw { message: result.error };
  return result;
}
async function uploadToTheGraph(source) {
  const data = new FormData();
  data.append("file", new Blob([source]));
  const res = await fetch("https://api.thegraph.com/ipfs/api/v0/add", {
    method: "POST",
    body: data
  });
  return await res.json();
}
function addCommand4(program2) {
  program2.command("ipfs").description("generates the ipfs hash for specified source").argument("<source>").option("-u, --upload").option("--verbose").action(async (source, { upload, verbose }) => {
    const filePath = path4.join(process.cwd(), source);
    if (!fs3.existsSync(filePath)) {
      logError("Upload", `Cannot find file at: ${filePath}`);
      throw new Error("FILE_NOT_FOUND");
    }
    const content = fs3.readFileSync(filePath, "utf8");
    validateAIPHeader(content);
    const hash = await getHash(content);
    const bs58Hash = `0x${Buffer.from(import_bs58.default.decode(hash)).slice(2).toString("hex")}`;
    if (upload) {
      const [pinata, thegraph] = await Promise.all([
        uploadToPinata(content),
        uploadToTheGraph(content)
      ]);
      if (verbose) {
        console.log("pinata response", pinata);
        console.log("thegraph response", thegraph);
      }
    }
    console.log(bs58Hash);
  });
}

// src/commands/capo.ts
import fs4 from "node:fs";

// src/reports/capo-report.ts
import { formatUnits as formatUnits5 } from "viem";
async function generateCapoReport(snapshot) {
  let prices = [];
  let maxDayToDayGrowth = 0;
  let maxSmoothedGrowth = 0;
  for (const key in snapshot.prices) {
    const price = snapshot.prices[key];
    const sourcePrice = formatUnits5(BigInt(price.sourcePrice), snapshot.decimals);
    const referencePrice = formatUnits5(BigInt(price.referencePrice), snapshot.decimals);
    const dayToDayGrowth = (price.dayToDayGrowth / 100).toFixed(2);
    const smoothedGrowth = (price.smoothedGrowth / 100).toFixed(2);
    const diff2 = (100 * (Number(sourcePrice) - Number(referencePrice)) / ((Number(sourcePrice) + Number(referencePrice)) / 2)).toFixed(2);
    const formattedDate = formatTimestamp(price.timestamp);
    prices.push({
      sourcePrice,
      referencePrice,
      diff: diff2,
      dayToDayGrowth,
      smoothedGrowth,
      date: formattedDate
    });
    maxDayToDayGrowth = Math.max(maxDayToDayGrowth, price.dayToDayGrowth);
    maxSmoothedGrowth = Math.max(maxSmoothedGrowth, price.smoothedGrowth);
  }
  prices = prices.slice(snapshot.minSnapshotDelay);
  let content = "";
  content += `# Capo Report

`;
  content += `| ${snapshot.source} | ${snapshot.reference} | Diff | Date | ${snapshot.minSnapshotDelay}-day growth in yearly % |
`;
  content += `| --- | --- | --- | --- | --- |
`;
  prices.forEach((price) => {
    content += `| ${price.sourcePrice} | ${price.referencePrice} | ${price.diff}% | ${price.date} | ${price.smoothedGrowth}% |
`;
  });
  content += `

`;
  content += `* ${snapshot.minSnapshotDelay}-day growth is calculated as an annualized percentage relative to the value of the rate ${snapshot.minSnapshotDelay} days prior. 
`;
  const maxYearlyGrowthPercent = (snapshot.maxYearlyGrowthPercent / 100).toFixed(2);
  const maxDayToDayGrowthPercent = (maxDayToDayGrowth / 100).toFixed(2);
  const maxSmoothedGrowthPercent = (maxSmoothedGrowth / 100).toFixed(2);
  content += `

`;
  content += `| Max Yearly % | Max Day-to-day yearly % | Max ${snapshot.minSnapshotDelay}-day yearly % | 
`;
  content += `| --- | --- | --- |
`;
  content += `| ${maxYearlyGrowthPercent}% | ${maxDayToDayGrowthPercent}% | ${maxSmoothedGrowthPercent}% | 
`;
  content += `

`;
  content += `* Max day-to-day yearly % indicates the maximum growth between two emissions as an annualized percentage. 
`;
  return content;
}
function formatTimestamp(timestampInSec) {
  const date = new Date(timestampInSec * 1e3);
  return new Intl.DateTimeFormat("en-GB", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    timeZone: "GMT"
  }).format(date);
}

// src/commands/capo.ts
function addCommand5(program2) {
  program2.command("capo-report").description("generate a capo report").argument("<source>").option("-o, --out <string>", "output path").option("--stringMode", "expects input to be a string, not paths").action(async (_source, options) => {
    const source = options.stringMode ? readJsonString(_source) : readJsonFile(_source);
    const content = await generateCapoReport(source);
    if (options.out) {
      fs4.writeFileSync(options.out, content);
    } else {
      console.log(content);
    }
  });
}

// src/cli.ts
var program = new Command();
program.name("aave-cli").description("CLI to interact with the aave ecosystem").option("-v, --verbose", "Showing logs for all the taken steps").on("option:verbose", () => {
  process.env.VERBOSE = "true";
}).addOption(
  new Option("--format <format>", "Set preferred output format").default("raw").choices(["raw", "encoded"])
).on("option:format", (format) => {
  process.env.FORMAT = format;
}).version(package_default.version).showHelpAfterError();
addCommand3(program);
addCommand(program);
addCommand2(program);
addCommand4(program);
addCommand5(program);
program.parse();
/**
 * Highly inspired by - reimplemented a bit simpler & added types
 * @license MIT https://github.com/omgaz/diffler
 * Author: Gary Chisholm @omgaz
 */
//# sourceMappingURL=cli.js.map