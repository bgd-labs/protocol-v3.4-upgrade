import { z } from 'zod';
import * as _bgd_labs_aave_v3_governance_cache_customStorageProvider from '@bgd-labs/aave-v3-governance-cache/customStorageProvider';
import * as viem from 'viem';
import { Hex, Client, GetTransactionReturnType, Chain, Address, GetContractReturnType } from 'viem';
import { GetPayloadReturnType, ProposalExecutedEvent, GetProposalReturnType } from '@bgd-labs/aave-v3-governance-cache';
import { IGovernanceCore_ABI, IPayloadsControllerCore_ABI } from '@bgd-labs/aave-address-book/abis';
import { GetProofReturnType } from 'viem/actions';

declare const aaveV3SnapshotSchema: z.ZodObject<{
    reserves: z.ZodRecord<z.ZodString, z.ZodObject<{
        id: z.ZodNumber;
        isBorrowableInIsolation: z.ZodBoolean;
        borrowCap: z.ZodNumber;
        liquidationBonus: z.ZodNumber;
        underlying: z.ZodString;
        isFrozen: z.ZodBoolean;
        stableDebtToken: z.ZodString;
        variableDebtToken: z.ZodString;
        reserveFactor: z.ZodNumber;
        liquidationProtocolFee: z.ZodNumber;
        usageAsCollateralEnabled: z.ZodBoolean;
        ltv: z.ZodNumber;
        supplyCap: z.ZodNumber;
        debtCeiling: z.ZodNumber;
        borrowingEnabled: z.ZodBoolean;
        isActive: z.ZodBoolean;
        eModeCategory: z.ZodNumber;
        symbol: z.ZodString;
        stableBorrowRateEnabled: z.ZodBoolean;
        isFlashloanable: z.ZodBoolean;
        aToken: z.ZodString;
        liquidationThreshold: z.ZodNumber;
        aTokenImpl: z.ZodString;
        stableDebtTokenImpl: z.ZodString;
        interestRateStrategy: z.ZodString;
        variableDebtTokenImpl: z.ZodString;
        oracleLatestAnswer: z.ZodString;
        oracle: z.ZodString;
        oracleDecimals: z.ZodNumber;
        oracleName: z.ZodString;
        oracleDescription: z.ZodString;
        decimals: z.ZodNumber;
        isSiloed: z.ZodBoolean;
        liquidityIndex: z.ZodNumber;
        variableBorrowIndex: z.ZodNumber;
        currentLiquidityRate: z.ZodNumber;
        currentVariableBorrowRate: z.ZodNumber;
        aTokenUnderlyingBalance: z.ZodString;
        virtualAccountingActive: z.ZodBoolean;
        virtualBalance: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        symbol: string;
        oracle: string;
        id: number;
        isBorrowableInIsolation: boolean;
        borrowCap: number;
        liquidationBonus: number;
        underlying: string;
        isFrozen: boolean;
        stableDebtToken: string;
        variableDebtToken: string;
        reserveFactor: number;
        liquidationProtocolFee: number;
        usageAsCollateralEnabled: boolean;
        ltv: number;
        supplyCap: number;
        debtCeiling: number;
        borrowingEnabled: boolean;
        isActive: boolean;
        eModeCategory: number;
        stableBorrowRateEnabled: boolean;
        isFlashloanable: boolean;
        aToken: string;
        liquidationThreshold: number;
        aTokenImpl: string;
        stableDebtTokenImpl: string;
        interestRateStrategy: string;
        variableDebtTokenImpl: string;
        oracleLatestAnswer: string;
        oracleDecimals: number;
        oracleName: string;
        oracleDescription: string;
        decimals: number;
        isSiloed: boolean;
        liquidityIndex: number;
        variableBorrowIndex: number;
        currentLiquidityRate: number;
        currentVariableBorrowRate: number;
        aTokenUnderlyingBalance: string;
        virtualAccountingActive: boolean;
        virtualBalance: string;
    }, {
        symbol: string;
        oracle: string;
        id: number;
        isBorrowableInIsolation: boolean;
        borrowCap: number;
        liquidationBonus: number;
        underlying: string;
        isFrozen: boolean;
        stableDebtToken: string;
        variableDebtToken: string;
        reserveFactor: number;
        liquidationProtocolFee: number;
        usageAsCollateralEnabled: boolean;
        ltv: number;
        supplyCap: number;
        debtCeiling: number;
        borrowingEnabled: boolean;
        isActive: boolean;
        eModeCategory: number;
        stableBorrowRateEnabled: boolean;
        isFlashloanable: boolean;
        aToken: string;
        liquidationThreshold: number;
        aTokenImpl: string;
        stableDebtTokenImpl: string;
        interestRateStrategy: string;
        variableDebtTokenImpl: string;
        oracleLatestAnswer: string;
        oracleDecimals: number;
        oracleName: string;
        oracleDescription: string;
        decimals: number;
        isSiloed: boolean;
        liquidityIndex: number;
        variableBorrowIndex: number;
        currentLiquidityRate: number;
        currentVariableBorrowRate: number;
        aTokenUnderlyingBalance: string;
        virtualAccountingActive: boolean;
        virtualBalance: string;
    }>>;
    strategies: z.ZodRecord<z.ZodString, z.ZodObject<{
        address: z.ZodString;
        baseVariableBorrowRate: z.ZodString;
        optimalUsageRatio: z.ZodString;
        variableRateSlope1: z.ZodString;
        variableRateSlope2: z.ZodString;
        maxVariableBorrowRate: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        address: string;
        baseVariableBorrowRate: string;
        optimalUsageRatio: string;
        variableRateSlope1: string;
        variableRateSlope2: string;
        maxVariableBorrowRate: string;
    }, {
        address: string;
        baseVariableBorrowRate: string;
        optimalUsageRatio: string;
        variableRateSlope1: string;
        variableRateSlope2: string;
        maxVariableBorrowRate: string;
    }>>;
    eModes: z.ZodRecord<z.ZodString, z.ZodObject<{
        eModeCategory: z.ZodNumber;
        liquidationBonus: z.ZodNumber;
        label: z.ZodString;
        liquidationThreshold: z.ZodNumber;
        priceSource: z.ZodString;
        ltv: z.ZodNumber;
        borrowableBitmap: z.ZodString;
        collateralBitmap: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        liquidationBonus: number;
        ltv: number;
        eModeCategory: number;
        liquidationThreshold: number;
        label: string;
        priceSource: string;
        borrowableBitmap: string;
        collateralBitmap: string;
    }, {
        liquidationBonus: number;
        ltv: number;
        eModeCategory: number;
        liquidationThreshold: number;
        label: string;
        priceSource: string;
        borrowableBitmap: string;
        collateralBitmap: string;
    }>>;
    poolConfig: z.ZodObject<{
        oracle: z.ZodString;
        pool: z.ZodString;
        poolAddressesProvider: z.ZodString;
        poolConfigurator: z.ZodString;
        poolConfiguratorImpl: z.ZodString;
        poolImpl: z.ZodString;
        protocolDataProvider: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        oracle: string;
        pool: string;
        poolAddressesProvider: string;
        poolConfigurator: string;
        poolConfiguratorImpl: string;
        poolImpl: string;
        protocolDataProvider: string;
    }, {
        oracle: string;
        pool: string;
        poolAddressesProvider: string;
        poolConfigurator: string;
        poolConfiguratorImpl: string;
        poolImpl: string;
        protocolDataProvider: string;
    }>;
    chainId: z.ZodNativeEnum<{
        readonly MAINNET: 1;
        readonly OPTIMISM: 10;
        readonly POLYGON: 137;
        readonly FANTOM: 250;
        readonly ARBITRUM: 42161;
        readonly AVALANCHE: 43114;
        readonly METIS: 1088;
        readonly BASE: 8453;
        readonly SCROLL: 534352;
        readonly BNB: 56;
        readonly GNOSIS: 100;
        readonly CELO: 42220;
        readonly ZKSYNC: 324;
    }>;
}, "strip", z.ZodTypeAny, {
    reserves: Record<string, {
        symbol: string;
        oracle: string;
        id: number;
        isBorrowableInIsolation: boolean;
        borrowCap: number;
        liquidationBonus: number;
        underlying: string;
        isFrozen: boolean;
        stableDebtToken: string;
        variableDebtToken: string;
        reserveFactor: number;
        liquidationProtocolFee: number;
        usageAsCollateralEnabled: boolean;
        ltv: number;
        supplyCap: number;
        debtCeiling: number;
        borrowingEnabled: boolean;
        isActive: boolean;
        eModeCategory: number;
        stableBorrowRateEnabled: boolean;
        isFlashloanable: boolean;
        aToken: string;
        liquidationThreshold: number;
        aTokenImpl: string;
        stableDebtTokenImpl: string;
        interestRateStrategy: string;
        variableDebtTokenImpl: string;
        oracleLatestAnswer: string;
        oracleDecimals: number;
        oracleName: string;
        oracleDescription: string;
        decimals: number;
        isSiloed: boolean;
        liquidityIndex: number;
        variableBorrowIndex: number;
        currentLiquidityRate: number;
        currentVariableBorrowRate: number;
        aTokenUnderlyingBalance: string;
        virtualAccountingActive: boolean;
        virtualBalance: string;
    }>;
    strategies: Record<string, {
        address: string;
        baseVariableBorrowRate: string;
        optimalUsageRatio: string;
        variableRateSlope1: string;
        variableRateSlope2: string;
        maxVariableBorrowRate: string;
    }>;
    eModes: Record<string, {
        liquidationBonus: number;
        ltv: number;
        eModeCategory: number;
        liquidationThreshold: number;
        label: string;
        priceSource: string;
        borrowableBitmap: string;
        collateralBitmap: string;
    }>;
    poolConfig: {
        oracle: string;
        pool: string;
        poolAddressesProvider: string;
        poolConfigurator: string;
        poolConfiguratorImpl: string;
        poolImpl: string;
        protocolDataProvider: string;
    };
    chainId: 1 | 10 | 137 | 250 | 42161 | 43114 | 1088 | 8453 | 534352 | 56 | 100 | 42220 | 324;
}, {
    reserves: Record<string, {
        symbol: string;
        oracle: string;
        id: number;
        isBorrowableInIsolation: boolean;
        borrowCap: number;
        liquidationBonus: number;
        underlying: string;
        isFrozen: boolean;
        stableDebtToken: string;
        variableDebtToken: string;
        reserveFactor: number;
        liquidationProtocolFee: number;
        usageAsCollateralEnabled: boolean;
        ltv: number;
        supplyCap: number;
        debtCeiling: number;
        borrowingEnabled: boolean;
        isActive: boolean;
        eModeCategory: number;
        stableBorrowRateEnabled: boolean;
        isFlashloanable: boolean;
        aToken: string;
        liquidationThreshold: number;
        aTokenImpl: string;
        stableDebtTokenImpl: string;
        interestRateStrategy: string;
        variableDebtTokenImpl: string;
        oracleLatestAnswer: string;
        oracleDecimals: number;
        oracleName: string;
        oracleDescription: string;
        decimals: number;
        isSiloed: boolean;
        liquidityIndex: number;
        variableBorrowIndex: number;
        currentLiquidityRate: number;
        currentVariableBorrowRate: number;
        aTokenUnderlyingBalance: string;
        virtualAccountingActive: boolean;
        virtualBalance: string;
    }>;
    strategies: Record<string, {
        address: string;
        baseVariableBorrowRate: string;
        optimalUsageRatio: string;
        variableRateSlope1: string;
        variableRateSlope2: string;
        maxVariableBorrowRate: string;
    }>;
    eModes: Record<string, {
        liquidationBonus: number;
        ltv: number;
        eModeCategory: number;
        liquidationThreshold: number;
        label: string;
        priceSource: string;
        borrowableBitmap: string;
        collateralBitmap: string;
    }>;
    poolConfig: {
        oracle: string;
        pool: string;
        poolAddressesProvider: string;
        poolConfigurator: string;
        poolConfiguratorImpl: string;
        poolImpl: string;
        protocolDataProvider: string;
    };
    chainId: 1 | 10 | 137 | 250 | 42161 | 43114 | 1088 | 8453 | 534352 | 56 | 100 | 42220 | 324;
}>;
type AaveV3Snapshot = z.infer<typeof aaveV3SnapshotSchema>;

declare function diffReports<A extends AaveV3Snapshot, B extends AaveV3Snapshot>(pre: A, post: B): Promise<string>;

type StateObject = {
    balance?: string;
    code?: string;
    storage?: Record<Hex, Hex>;
};
interface RawElement {
    address: string;
    key: string;
    original: string;
    dirty: string;
}
interface StateDiff {
    soltype: SoltypeElement | null;
    original: string | Record<string, any>;
    dirty: string | Record<string, any>;
    raw: RawElement[];
    address: string;
}
type ContractObject = {
    contractName: string;
    source: string;
    sourcePath: string;
    compiler: {
        name: 'solc';
        version: string;
    };
    networks: Record<string, {
        events?: Record<string, string>;
        links?: Record<string, string>;
        address: string;
        transactionHash?: string;
    }>;
};
type TenderlyRequest = {
    network_id: string;
    block_number?: number;
    transaction_index?: number;
    from: Hex;
    to: Hex;
    input: Hex;
    gas?: number;
    gas_price?: string;
    value?: string;
    simulation_type?: 'full' | 'quick';
    save?: boolean;
    save_if_fails?: boolean;
    state_objects?: Record<Hex, StateObject>;
    contracts?: ContractObject[];
    block_header?: {
        number?: Hex;
        timestamp?: Hex;
    };
    generate_access_list?: boolean;
    root?: string;
};
declare enum SoltypeType {
    Address = "address",
    Bool = "bool",
    Bytes32 = "bytes32",
    MappingAddressUint256 = "mapping (address => uint256)",
    MappingUint256Uint256 = "mapping (uint256 => uint256)",
    String = "string",
    Tuple = "tuple",
    TypeAddress = "address[]",
    TypeTuple = "tuple[]",
    Uint16 = "uint16",
    Uint256 = "uint256",
    Uint48 = "uint48",
    Uint56 = "uint56",
    Uint8 = "uint8"
}
declare enum StorageLocation {
    Calldata = "calldata",
    Default = "default",
    Memory = "memory",
    Storage = "storage"
}
declare enum SimpleTypeType {
    Address = "address",
    Bool = "bool",
    Bytes = "bytes",
    Slice = "slice",
    String = "string",
    Uint = "uint"
}
interface Type {
    type: SimpleTypeType;
}
interface SoltypeElement {
    name: string;
    type: SoltypeType;
    storage_location: StorageLocation;
    components: SoltypeElement[] | null;
    offset: number;
    index: string;
    indexed: boolean;
    simple_type?: Type;
}
interface Input {
    soltype: SoltypeElement | null;
    value: boolean | string;
}
interface Log {
    name: string | null;
    anonymous: boolean;
    inputs: Input[];
    raw: LogRaw;
}
interface LogRaw {
    address: string;
    topics: string[];
    data: string;
}
interface Trace {
    from: Hex;
    to?: Hex;
    function_name?: string;
    input: Hex;
    output: string;
    calls?: Trace[];
    decoded_input: Input[];
    caller_op: string;
}
interface TenderlyLogRaw {
    address: string;
    topics: string[];
    data: string;
}
interface TenderlyLog {
    name: string | null;
    anonymous: boolean;
    inputs: Input[];
    raw: TenderlyLogRaw;
}
interface TenderlyStackTrace {
    file_index: number;
    contract: string;
    name: string;
    line: number;
    error: string;
    error_reason: string;
    code: string;
    op: string;
    length: number;
}
type TransactionInfo = {
    call_trace: {
        calls: Trace[];
    };
    state_diff: StateDiff[];
    logs: TenderlyLog[] | null;
    stack_trace: TenderlyStackTrace[] | null;
};
type Transaction = {
    transaction_info: TransactionInfo;
    block_number: number;
    timestamp: string;
    status: boolean;
    addresses: Hex[];
};
type TenderlyContractResponseObject = {
    address: Hex;
    contract_name: string;
    standards?: string[];
    token_data?: {
        symbol: string;
        name: string;
        decimals: number;
    };
    child_contracts?: {
        id: string;
        address: Hex;
        network_id: string;
    }[];
    src_map: any;
};
interface TenderlySimulationResponseObject {
    id: string;
    project_id: string;
    owner_id: string;
    network_id: string;
    block_number: number;
    transaction_index: number;
    from: string;
    to: string;
    input: string;
    gas: number;
    gas_price: string;
    value: string;
    method: string;
    status: boolean;
    access_list: null;
    queue_origin: string;
    created_at: Date;
    block_header: {
        timestamp: string;
    };
}
type TenderlySimulationResponse = {
    transaction: Transaction;
    contracts: TenderlyContractResponseObject[];
    simulation: TenderlySimulationResponseObject;
};
type TenderlyTraceResponse = TransactionInfo;
type Fork = {
    id: string;
    chainId: string;
    block_number: number;
    forkNetworkId: string;
    forkUrl: string;
    global_head: string;
};
declare class Tenderly {
    TENDERLY_BASE: string;
    ACCESS_TOKEN: string;
    ACCOUNT: string;
    PROJECT: string;
    constructor(accessToken: string, account: string, project: string);
    trace: (chainId: number, txHash: string) => Promise<TenderlyTraceResponse>;
    simulate: (request: TenderlyRequest, client?: Client) => Promise<TenderlySimulationResponse>;
    /**
     * Fork api to get fork information from an existing fork id
     * @param project name of the Tenderly project where the fork was created
     * @param forkId id of the fork created in tenderly
     * @returns fork object
     */
    getForkInfo: (forkId: string, project?: string) => Promise<Fork>;
    /**
     * Trace api lacks most information we need, so simulateTx uses the simulation api to replicate the trace.
     * @param chainId
     * @param tx
     * @returns
     */
    simulateTx: (chainId: number, tx: GetTransactionReturnType<Chain, "latest">) => Promise<TenderlySimulationResponse>;
    fork: ({ chainId, blockNumber, alias, forkChainId, }: {
        chainId: number;
        blockNumber?: number;
        alias?: string;
        forkChainId?: number;
    }) => Promise<Fork>;
    deployCode: (fork: Fork, filePath: string, from?: Hex) => Promise<`0x${string}`>;
    warpTime: (fork: Fork, timestamp: bigint) => Promise<void>;
    warpBlocks: (fork: Fork, blockNumber: bigint) => Promise<void>;
    unwrapAndExecuteSimulationPayloadOnFork: (fork: Fork, request: TenderlyRequest) => Promise<`0x${string}` | undefined>;
    fundAccount: (fork: Fork, address: Hex) => Promise<Response>;
    replaceCode: (fork: Fork, address: Hex, code: Hex) => Promise<string | boolean | void | `0x${string}`[] | readonly `0x${string}`[] | viem.RpcTransactionReceipt | viem.RpcFeeHistory | viem.RpcBlock | viem.RpcLog[] | viem.RpcProof | viem.RpcTransaction | viem.RpcUncle | viem.NetworkSync | viem.WalletGetCallsStatusReturnType<`0x${string}`, `0x${string}`> | viem.WalletPermission[] | {
        expiry: number;
        factory?: `0x${string}` | undefined;
        factoryData?: string | undefined;
        grantedPermissions: readonly {
            data: unknown;
            policies: readonly {
                data: unknown;
                type: string;
            }[];
            required?: boolean | undefined;
            type: string;
        }[];
        permissionsContext: string;
        signerData?: {
            userOpBuilder?: `0x${string}` | undefined;
            submitToAddress?: `0x${string}` | undefined;
        } | undefined;
    } | viem.RpcEstimateUserOperationGasReturnType | viem.RpcGetUserOperationByHashReturnType | viem.RpcUserOperationReceipt | (viem.OneOf<{
        paymasterAndData: Hex;
    } | {
        paymaster: Address;
        paymasterData: Hex;
        paymasterVerificationGasLimit: Hex;
        paymasterPostOpGasLimit: Hex;
    }> & {
        sponsor?: {
            name: string;
            icon?: string | undefined;
        } | undefined;
        isFinal?: boolean | undefined;
    }) | viem.OneOf<{
        paymasterAndData: Hex;
    } | {
        paymaster: Address;
        paymasterData: Hex;
        paymasterVerificationGasLimit: Hex;
        paymasterPostOpGasLimit: Hex;
    }> | {
        [x: `0x${string}`]: viem.WalletCapabilities;
    } | null>;
}
declare const tenderly: Tenderly;

/**
 * Reference implementation, unused
 * @param governanceAddress
 * @param client
 * @param proposalId
 * @returns
 */
declare function simulateProposal(governanceAddress: Hex, client: Client, proposalId: bigint): Promise<{
    proposal: _bgd_labs_aave_v3_governance_cache_customStorageProvider.GetProposalReturnType;
    payloads: {
        payload: GetPayloadReturnType;
        simulation: TenderlySimulationResponse;
    }[];
}>;

interface Governance {
    governanceContract: GetContractReturnType<typeof IGovernanceCore_ABI, Client>;
    /**
     * Thin caching wrapper on top of getProposal.
     * If the proposal state is final, the proposal will be stored in json and fetched from there.
     * @param proposalId
     * @returns Proposal struct
     */
    getSimulationPayloadForExecution: (proposalId: bigint) => Promise<TenderlyRequest>;
    simulateProposalExecutionOnTenderly: (proposalId: bigint, params: {
        executedLog?: ProposalExecutedEvent;
    }) => Promise<TenderlySimulationResponse>;
    getStorageRoots(proposalId: bigint): Promise<GetProofReturnType[]>;
    /**
     * Returns the proofs that are non-zero for a specified address
     * @param proposalId
     * @param voter
     * @param votingChainId
     */
    getVotingProofs: (proposalId: bigint, voter: Hex, votingChainId: bigint) => Promise<{
        proof: Hex;
        slot: bigint;
        underlyingAsset: Hex;
    }[]>;
}
declare const HUMAN_READABLE_STATE: {
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
    5: string;
    6: string;
    7: string;
};
interface GetGovernanceParams {
    address: Hex;
    client: Client;
    blockCreated?: bigint;
}
declare const getGovernance: ({ address, client }: GetGovernanceParams) => Governance;

declare const HUMAN_READABLE_PAYLOAD_STATE: {
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
    5: string;
};
interface PayloadsController {
    controllerContract: GetContractReturnType<typeof IPayloadsControllerCore_ABI, Client>;
    getSimulationPayloadForExecution: (id: number) => Promise<TenderlyRequest>;
    simulatePayloadExecutionOnTenderly: (id: number, logs: GetPayloadReturnType['logs']) => Promise<TenderlySimulationResponse>;
}
declare const getPayloadsController: (address: Hex, client: Client) => PayloadsController;

type GenerateReportRequest$1 = {
    payloadId: number;
    payloadInfo: GetPayloadReturnType;
    simulation: TenderlySimulationResponse;
    client: Client;
};
declare function generateReport({ payloadId, payloadInfo, simulation, client, }: GenerateReportRequest$1): Promise<string>;

type GenerateReportRequest = {
    proposalId: bigint;
    proposalInfo: GetProposalReturnType;
    simulation: TenderlySimulationResponse;
    client: Client;
    formattedPayloads?: string[];
};
declare function generateProposalReport({ proposalId, proposalInfo, simulation, client, formattedPayloads, }: GenerateReportRequest): Promise<string>;

declare function logVerbose(topic: string, text: string | number | bigint): void;
declare function logInfo(topic: string, text: string | number | bigint): void;
declare function logWarning(topic: string, text: string | number | bigint): void;
declare function logError(topic: string, text: string | number | bigint): void;
declare function logSuccess(topic: string, text: string | number | bigint): void;

/**
 * Checks if address is listed on address-book
 * @param value
 * @param chainId
 * @returns string[] found paths to address-book addresses
 */
declare function isKnownAddress(value: Address, chainId: number): string[] | void;
declare function findPayloadsController(chainId: number): Address | void;
type AssetInfo = {
    symbol: string;
    decimals: number;
};
declare function findAsset(client: Client, address: Hex): Promise<AssetInfo>;
declare function assetIndexesToAsset(client: Client, poolAddress: Hex, indexes: number[]): Promise<string[]>;

export { type ContractObject, type Fork, type Governance, HUMAN_READABLE_PAYLOAD_STATE, HUMAN_READABLE_STATE, type Input, type Log, type LogRaw, type PayloadsController, type SoltypeElement, type StateDiff, type StateObject, type TenderlyLog, type TenderlyLogRaw, type TenderlyRequest, type TenderlySimulationResponse, type TenderlySimulationResponseObject, type TenderlyStackTrace, type TenderlyTraceResponse, type Trace, type TransactionInfo, assetIndexesToAsset, diffReports, findAsset, findPayloadsController, generateProposalReport, generateReport, getGovernance, getPayloadsController, isKnownAddress, logError, logInfo, logSuccess, logVerbose, logWarning, simulateProposal, tenderly };
