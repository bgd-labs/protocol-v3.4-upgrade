// src/foundry/storage-diff.ts
function compareStorageLayouts(layoutBefore, layoutAfter) {
  const layoutForComparisonBefore = preformatStorageLayout(layoutBefore);
  const layoutForComparisonAfter = preformatStorageLayout(layoutAfter);
  const comparison = compareStorageArrays(
    layoutForComparisonBefore,
    layoutForComparisonAfter
  );
  const md = generateMarkdownOutput(comparison);
  return md;
}
function preformatStorageLayout(json) {
  return json.storage.map((item) => ({
    label: item.label,
    offset: item.offset,
    slot: item.slot,
    type: json.types[item.type].label,
    numberOfBytes: json.types[item.type].numberOfBytes
  }));
}
function compareStorageArrays(oldArray, newArray) {
  const changes = [];
  const oldMap = new Map(
    oldArray.map((item) => [item.slot + "-" + item.offset, item])
  );
  const newMap = new Map(
    newArray.map((item) => [item.slot + "-" + item.offset, item])
  );
  oldArray.forEach((oldItem) => {
    const newItem = newMap.get(oldItem.slot + "-" + oldItem.offset);
    if (!newItem) {
      changes.push({ ...oldItem, status: "removed" });
    } else if (isDifferent(oldItem, newItem)) {
      changes.push({ ...oldItem, status: "removed" });
      changes.push({ ...newItem, status: "added" });
    } else {
      changes.push({ ...newItem, status: "unchanged" });
    }
  });
  newArray.forEach((newItem) => {
    if (!oldMap.has(newItem.slot + "-" + newItem.offset)) {
      changes.push({ ...newItem, status: "added" });
    }
  });
  changes.sort((a, b) => {
    if (a.slot === b.slot) {
      return a.offset - b.offset;
    }
    return a.slot.localeCompare(b.slot);
  });
  return changes;
}
function isDifferent(item1, item2) {
  return item1.offset !== item2.offset || item1.slot !== item2.slot || item1.type !== item2.type || item1.numberOfBytes !== item2.numberOfBytes;
}
function generateMarkdownOutput(items) {
  const columnWidths = {
    name: Math.max(...items.map((item) => item.label.length), "Label".length),
    offset: "Offset".length,
    slot: "Slot".length,
    type: Math.max(...items.map((item) => item.type.length), "Type".length),
    numberOfBytes: "Bytes".length
  };
  let markdownTable = "```diff\n";
  markdownTable += ` | ${"Label".padEnd(
    columnWidths.name,
    " "
  )} | ${"Offset".padEnd(columnWidths.offset, " ")} | ${"Slot".padEnd(
    columnWidths.slot,
    " "
  )} | ${"Type".padEnd(columnWidths.type, " ")} | ${"Bytes".padEnd(
    columnWidths.numberOfBytes,
    " "
  )} |
`;
  markdownTable += ` |${"-".repeat(columnWidths.name + 2)}|${"-".repeat(
    columnWidths.offset + 2
  )}|${"-".repeat(columnWidths.slot + 2)}|${"-".repeat(
    columnWidths.type + 2
  )}|${"-".repeat(columnWidths.numberOfBytes + 2)}||
`;
  items.forEach((item) => {
    const sign = item.status === "added" ? "+" : item.status === "removed" ? "-" : " ";
    const row = `${sign}| ${item.label.padEnd(
      columnWidths.name,
      " "
    )} | ${item.offset.toString().padEnd(columnWidths.offset, " ")} | ${item.slot.padEnd(
      columnWidths.slot,
      " "
    )} | ${item.type.padEnd(
      columnWidths.type,
      " "
    )} | ${item.numberOfBytes.padEnd(columnWidths.numberOfBytes, " ")} |
`;
    markdownTable += row;
  });
  markdownTable += "```";
  return markdownTable;
}

// src/rpc/chainIds.ts
import {
  mainnet,
  arbitrumGoerli,
  arbitrumSepolia,
  avalancheFuji,
  bsc,
  fantomTestnet,
  harmonyOne,
  optimismGoerli,
  optimismSepolia,
  polygonMumbai,
  polygonZkEvm,
  scrollSepolia,
  baseSepolia,
  goerli,
  polygon,
  avalanche,
  arbitrum,
  fantom,
  optimism,
  sepolia,
  scroll,
  metis,
  base,
  gnosis,
  celo,
  zkSync
} from "viem/chains";
var ChainId = {
  mainnet: mainnet.id,
  goerli: goerli.id,
  polygon: polygon.id,
  mumbai: polygonMumbai.id,
  avalanche: avalanche.id,
  fuji: avalancheFuji.id,
  arbitrum_one: arbitrum.id,
  arbitrum_goerli: arbitrumGoerli.id,
  arbitrum_sepolia: arbitrumSepolia.id,
  fantom: fantom.id,
  fantom_testnet: fantomTestnet.id,
  optimism: optimism.id,
  optimism_sepolia: optimismSepolia.id,
  optimism_goerli: optimismGoerli.id,
  harmony: harmonyOne.id,
  sepolia: sepolia.id,
  scroll: scroll.id,
  scroll_sepolia: scrollSepolia.id,
  metis: metis.id,
  base: base.id,
  base_sepolia: baseSepolia.id,
  bnb: bsc.id,
  gnosis: gnosis.id,
  zkEVM: polygonZkEvm.id,
  celo: celo.id,
  zkSync: zkSync.id
};

// src/rpc/helpers.ts
import {
  fromHex
} from "viem";
import { PromisePool } from "@supercharge/promise-pool";
import { getBlock, getBytecode, getLogs } from "viem/actions";
import { debug } from "util";
async function getContractDeploymentBlock({
  client,
  contractAddress,
  fromBlock,
  toBlock,
  maxDelta
}) {
  if (fromBlock == toBlock)
    return fromBlock;
  if (fromBlock < toBlock) {
    const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
    const codeMid = await getBytecode(client, {
      blockNumber: midBlock,
      address: contractAddress
    });
    if (!codeMid) {
      if (toBlock - midBlock > maxDelta) {
        return getContractDeploymentBlock({
          client,
          contractAddress,
          fromBlock: midBlock,
          toBlock,
          maxDelta
        });
      } else {
        return midBlock;
      }
    }
    return getContractDeploymentBlock({
      client,
      contractAddress,
      fromBlock,
      toBlock: midBlock,
      maxDelta
    });
  }
  throw new Error("Could not find contract deployment block");
}
async function getBlockAtTimestamp({
  client,
  timestamp,
  fromBlock,
  toBlock,
  maxDelta
}) {
  if (fromBlock <= toBlock) {
    const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
    const block = await getBlock(client, { blockNumber: midBlock });
    if (block.timestamp > timestamp) {
      return getBlockAtTimestamp({
        client,
        timestamp,
        fromBlock,
        toBlock: midBlock,
        maxDelta
      });
    } else {
      if (timestamp - block.timestamp < maxDelta) {
        return block;
      } else {
        return getBlockAtTimestamp({
          client,
          timestamp,
          fromBlock: midBlock,
          toBlock,
          maxDelta
        });
      }
    }
  }
  throw new Error("Could not find matching block");
}
async function strategicGetLogs({
  client,
  events,
  address,
  fromBlock,
  toBlock
}) {
  if (client.transport.key === "http") {
    const url = client.transport.url;
    let batchSize = 0;
    if (/llamarpc/.test(url))
      batchSize = 1e5;
    if (/quiknode/.test(url))
      batchSize = 1e4;
    if (/alchemy/.test(url)) {
      getLogsRecursive({ client, events, address, fromBlock, toBlock });
    }
    if (batchSize > 0) {
      return getLogsInBatches({
        client,
        events,
        address,
        fromBlock,
        toBlock,
        batchSize
      });
    }
  }
  return getLogsRecursive({ client, events, address, fromBlock, toBlock });
}
async function getLogsRecursive({
  client,
  events,
  address,
  fromBlock,
  toBlock
}) {
  debug("recursions")(`fetching from block ${fromBlock} to block ${toBlock}`);
  if (fromBlock <= toBlock) {
    try {
      const logs = await getLogs(client, {
        fromBlock,
        toBlock,
        events,
        address
      });
      return logs;
    } catch (error) {
      const rangeMatch = error.details?.match(/.*\[(.*),\s*(.*)\]/);
      if (rangeMatch?.length === 3) {
        const maxBlock = fromHex(rangeMatch[2], "bigint");
        const arr1 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock,
          toBlock: maxBlock
        });
        const midBlock = BigInt(maxBlock + toBlock) >> BigInt(1);
        const arr2 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock: maxBlock + BigInt(1),
          toBlock: midBlock
        });
        const arr3 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock: midBlock + BigInt(1),
          toBlock
        });
        return [...arr1, ...arr2, ...arr3];
      } else {
        const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
        const arr1 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock,
          toBlock: midBlock
        });
        const arr2 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock: midBlock + BigInt(1),
          toBlock
        });
        return [...arr1, ...arr2];
      }
    }
  }
  return [];
}
async function getLogsInBatches({
  client,
  events,
  address,
  fromBlock,
  toBlock,
  batchSize
}) {
  const batches = [];
  for (let i = Number(fromBlock); i < Number(toBlock); i = i + batchSize) {
    batches.push({
      from: BigInt(i),
      to: BigInt(i + batchSize - 1) > toBlock ? toBlock : BigInt(i + batchSize - 1)
    });
  }
  const { results, errors } = await PromisePool.for(batches).withConcurrency(5).useCorrespondingResults().process(async ({ from, to }) => {
    return getLogs(client, {
      fromBlock: from,
      toBlock: to,
      events,
      address
    });
  });
  if (errors.length !== 0) {
    throw new Error("Error fetching logs");
  }
  return results.flat();
}

// src/rpc/clients.ts
import { createClient, http } from "viem";
import {
  mainnet as mainnet2,
  arbitrum as arbitrum2,
  polygon as polygon2,
  optimism as optimism2,
  metis as metis2,
  base as base2,
  baseSepolia as baseSepolia2,
  sepolia as sepolia2,
  goerli as goerli2,
  bsc as bsc2,
  fantom as fantom2,
  avalanche as avalanche2,
  gnosis as gnosis2,
  polygonZkEvm as polygonZkEvm2,
  scroll as scroll2,
  celo as celo2,
  zkSync as zkSync2,
  avalancheFuji as avalancheFuji2,
  polygonMumbai as polygonMumbai2,
  harmonyOne as harmonyOne2,
  arbitrumGoerli as arbitrumGoerli2,
  optimismGoerli as optimismGoerli2,
  optimismSepolia as optimismSepolia2,
  scrollSepolia as scrollSepolia2,
  fantomTestnet as fantomTestnet2,
  arbitrumSepolia as arbitrumSepolia2
} from "viem/chains";
var commonConfig = { timeout: 3e4 };
var mainnetClient = createClient({
  chain: mainnet2,
  transport: http(process.env.RPC_MAINNET, commonConfig)
});
var arbitrumClient = createClient({
  chain: arbitrum2,
  transport: http(process.env.RPC_ARBITRUM, commonConfig)
});
var polygonClient = createClient({
  chain: polygon2,
  transport: http(process.env.RPC_POLYGON, commonConfig)
});
var optimismClient = createClient({
  chain: optimism2,
  transport: http(process.env.RPC_OPTIMISM, commonConfig)
});
var metisClient = createClient({
  chain: metis2,
  transport: http(process.env.RPC_METIS, commonConfig)
});
var baseClient = createClient({
  chain: base2,
  transport: http(process.env.RPC_BASE, commonConfig)
});
var fantomClient = createClient({
  chain: fantom2,
  transport: http(process.env.RPC_FANTOM, commonConfig)
});
var bnbClient = createClient({
  chain: bsc2,
  transport: http(process.env.RPC_BNB, commonConfig)
});
var avalancheClient = createClient({
  chain: avalanche2,
  transport: http(process.env.RPC_AVALANCHE, commonConfig)
});
var gnosisClient = createClient({
  chain: gnosis2,
  transport: http(process.env.RPC_GNOSIS, commonConfig)
});
var scrollClient = createClient({
  chain: scroll2,
  transport: http(process.env.RPC_SCROLL, commonConfig)
});
var zkEVMClient = createClient({
  chain: polygonZkEvm2,
  transport: http(process.env.RPC_ZKEVM, commonConfig)
});
var celoClient = createClient({
  chain: celo2,
  transport: http(process.env.RPC_CELO, commonConfig)
});
var zkSyncClient = createClient({
  chain: zkSync2,
  transport: http(process.env.RPC_ZKSYNC, commonConfig)
});
var harmonyClient = createClient({
  chain: harmonyOne2,
  transport: http(process.env.RPC_HARMONY, commonConfig)
});
var fujiClient = createClient({
  chain: avalancheFuji2,
  transport: http(process.env.RPC_FUJI, commonConfig)
});
var mumbaiClient = createClient({
  chain: polygonMumbai2,
  transport: http(process.env.RPC_MUMBAI, commonConfig)
});
var sepoliaClient = createClient({
  chain: sepolia2,
  transport: http(process.env.RPC_SEPOLIA, commonConfig)
});
var goerliClient = createClient({
  chain: goerli2,
  transport: http(process.env.RPC_GOERLI, commonConfig)
});
var arbitrumGoerliClient = createClient({
  chain: arbitrumGoerli2,
  transport: http(process.env.RPC_ARBITRUM_GOERLI, commonConfig)
});
var arbitrumSepoliaClient = createClient({
  chain: arbitrumSepolia2,
  transport: http(process.env.RPC_ARBITRUM_SEPOLIA, commonConfig)
});
var optimismGoerliClient = createClient({
  chain: optimismGoerli2,
  transport: http(process.env.RPC_OPTIMISM_GOERLI, commonConfig)
});
var optimismSepoliaClient = createClient({
  chain: optimismSepolia2,
  transport: http(process.env.RPC_OPTIMISM_SEPOLIA, commonConfig)
});
var scrollSepoliaClient = createClient({
  chain: scrollSepolia2,
  transport: http(process.env.RPC_SCROLL_SEPOLIA, commonConfig)
});
var fantomTestnetClient = createClient({
  chain: fantomTestnet2,
  transport: http(process.env.RPC_FANTOM_TESTNET, commonConfig)
});
var baseSepoliaClient = createClient({
  chain: baseSepolia2,
  transport: http(process.env.RPC_BASE_SEPOLIA, commonConfig)
});
var CHAIN_ID_CLIENT_MAP = {
  [ChainId.mainnet]: mainnetClient,
  [ChainId.arbitrum_one]: arbitrumClient,
  [ChainId.arbitrum_goerli]: arbitrumGoerliClient,
  [ChainId.arbitrum_sepolia]: arbitrumSepoliaClient,
  [ChainId.polygon]: polygonClient,
  [ChainId.optimism]: optimismClient,
  [ChainId.optimism_goerli]: optimismGoerliClient,
  [ChainId.optimism_sepolia]: optimismSepoliaClient,
  [ChainId.metis]: metisClient,
  [ChainId.base]: baseClient,
  [ChainId.base_sepolia]: baseSepoliaClient,
  [ChainId.sepolia]: sepoliaClient,
  [ChainId.goerli]: goerliClient,
  [ChainId.fantom]: fantomClient,
  [ChainId.fantom_testnet]: fantomTestnetClient,
  [ChainId.bnb]: bnbClient,
  [ChainId.avalanche]: avalancheClient,
  [ChainId.gnosis]: gnosisClient,
  [ChainId.scroll]: scrollClient,
  [ChainId.scroll_sepolia]: scrollSepoliaClient,
  [ChainId.zkEVM]: zkEVMClient,
  [ChainId.celo]: celoClient,
  [ChainId.zkSync]: zkSyncClient,
  [ChainId.fuji]: fujiClient,
  [ChainId.mumbai]: mumbaiClient,
  [ChainId.harmony]: harmonyClient
};

// src/ipfs/hash.ts
import bs58 from "bs58";
function baseToCidv0(hash) {
  return bs58.encode(Buffer.from(`1220${hash.slice(2)}`, "hex"));
}

// src/ipfs/upload.ts
async function uploadToPinata(source) {
  const PINATA_KEY = process.env.PINATA_KEY;
  if (!PINATA_KEY)
    throw new Error("PINATA_KEY env must be set");
  const PINATA_SECRET = process.env.PINATA_SECRET;
  if (!PINATA_SECRET)
    throw new Error("PINATA_SECRET env must be set");
  const data = new FormData();
  data.append("file", new Blob([source]));
  const res = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
    method: "POST",
    body: data,
    headers: {
      pinata_api_key: PINATA_KEY,
      pinata_secret_api_key: PINATA_SECRET
    }
  });
  if (!res.ok) {
    throw Error(await res.text());
  }
  const result = await res.json();
  if (result.error)
    throw { message: result.error };
  return result;
}
async function uploadToTheGraph(source) {
  const data = new FormData();
  data.append("file", new Blob([source]));
  const res = await fetch("https://api.thegraph.com/ipfs/api/v0/add", {
    method: "POST",
    body: data
  });
  return res.json();
}
async function uploadToQuicknode(source, key) {
  const apiKey = process.env.QUICKNODE_API_KEY;
  const headers = new Headers();
  headers.append("x-api-key", apiKey);
  const data = new FormData();
  data.append("Body", new Blob([source]));
  data.append("Key", key || "unknownKey");
  data.append("ContentType", "text/plain");
  const res = await fetch(
    "https://api.quicknode.com/ipfs/rest/v1/s3/put-object",
    {
      method: "POST",
      headers,
      body: data,
      redirect: "follow"
    }
  );
  return res.text();
}

// src/ipfs/parseIpfs.ts
import matter from "gray-matter";
function getLink(hash, gateway) {
  return `${gateway}/${hash}`;
}
async function getProposalMetadata(hash, gateway = "https://cloudflare-ipfs.com/ipfs") {
  const ipfsHash = hash.startsWith("0x") ? baseToCidv0(hash) : hash;
  const ipfsPath = getLink(ipfsHash, gateway);
  const ipfsResponse = await fetch(ipfsPath, {
    headers: {
      "Content-Type": "application/json"
    }
  });
  if (!ipfsResponse.ok)
    throw Error(`IPFS: error fetching ${ipfsPath}`);
  const clone = ipfsResponse.clone();
  try {
    const response = await ipfsResponse.json();
    const { content, data } = matter(response.description);
    return {
      ...response,
      ipfsHash,
      description: content,
      ...data
    };
  } catch (e) {
    const { content, data } = matter(await clone.text());
    return {
      ...ipfsResponse,
      ipfsHash,
      description: content,
      ...data
    };
  }
}

// src/storage/storageSlots.ts
import {
  concat,
  encodeAbiParameters,
  fromHex as fromHex2,
  keccak256,
  pad,
  parseAbiParameters,
  toBytes,
  toHex,
  trim
} from "viem";
function getSolidityStorageSlotBytes(mappingSlot, key) {
  const slot = pad(mappingSlot, { size: 32 });
  return trim(
    keccak256(
      encodeAbiParameters(parseAbiParameters("bytes32, uint256"), [
        key,
        BigInt(slot)
      ])
    )
  );
}
function getSolidityStorageSlotUint(mappingSlot, key) {
  return keccak256(
    encodeAbiParameters(parseAbiParameters("uint256, uint256"), [
      key,
      mappingSlot
    ])
  );
}
function getSolidityStorageSlotAddress(mappingSlot, key) {
  return keccak256(
    encodeAbiParameters(parseAbiParameters("address, uint256"), [
      key,
      BigInt(mappingSlot)
    ])
  );
}
function getDynamicArraySlot(baseSlot, arrayIndex, itemSize) {
  return pad(
    toHex(
      fromHex2(
        keccak256(
          encodeAbiParameters(parseAbiParameters("uint256"), [baseSlot])
        ),
        "bigint"
      ) + BigInt(arrayIndex * itemSize)
    ),
    { size: 32 }
  );
}
function getBytesValue(value) {
  const bytesString = toBytes(value);
  if (bytesString.length > 31)
    throw new Error("Error: strings > 31 bytes are not implemented");
  return concat([
    toHex(pad(bytesString, { size: 31, dir: "right" })),
    toHex(bytesString.length * 2, { size: 1 })
  ]);
}
function getBits(_bigIntValue, startBit, _endBit) {
  let endBit = _endBit;
  const bigIntValue = BigInt(_bigIntValue);
  if (startBit > endBit) {
    throw new Error(
      "Invalid bit range: startBit must be less than or equal to endBit"
    );
  }
  const bitLength = BigInt(bigIntValue.toString(2)).toString().length;
  if (endBit >= bitLength) {
    endBit = BigInt(bitLength - 1);
  }
  const mask = (1n << endBit - startBit + 1n) - 1n;
  const maskedValue = bigIntValue >> startBit & mask;
  return maskedValue.toString();
}
function setBits(_bigIntBase, startBit, endBit, _replaceValue) {
  const bigIntBase = BigInt(_bigIntBase);
  const bigIntReplaceValue = BigInt(_replaceValue);
  let mask = BigInt(0);
  for (let i = startBit; i < endBit; i++) {
    mask |= BigInt(1) << BigInt(i);
  }
  const clearedNumber = bigIntBase & ~mask;
  const result = clearedNumber | bigIntReplaceValue << BigInt(startBit);
  return result;
}

// src/storage/poolStorage.ts
function decodeReserveConfigV2(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const reserveFactor = getBits(data, 64n, 79n);
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableBorrowingEnabled: !!stableBorrowingEnabled,
    reserveFactor
  };
}
function decodeReserveConfigV3(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableRateBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const paused = Number(getBits(data, 60n, 60n));
  const borrowingInIsolation = Number(getBits(data, 61n, 61n));
  const siloedBorrowingEnabled = Number(getBits(data, 62n, 62n));
  const flashloaningEnabled = Number(getBits(data, 63n, 63n));
  const reserveFactor = getBits(data, 64n, 79n);
  const borrowCap = getBits(data, 80n, 115n);
  const supplyCap = getBits(data, 116n, 151n);
  const liquidationProtocolFee = getBits(data, 152n, 167n);
  const eModeCategory = getBits(data, 168n, 175n);
  const unbackedMintCap = getBits(data, 176n, 211n);
  const debtCeiling = getBits(data, 212n, 251n);
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableRateBorrowingEnabled: !!stableRateBorrowingEnabled,
    paused: !!paused,
    borrowingInIsolation: !!borrowingInIsolation,
    reserveFactor,
    borrowCap,
    supplyCap,
    liquidationProtocolFee,
    eModeCategory,
    unbackedMintCap,
    debtCeiling,
    siloedBorrowingEnabled: !!siloedBorrowingEnabled,
    flashloaningEnabled: !!flashloaningEnabled
  };
}

// src/cache/json.ts
import { existsSync, readFileSync, mkdirSync, writeFileSync } from "fs";
import path from "path";
var DEFAULT_PATH = path.join(process.cwd(), "cache");
function readJSONCache(filePath, filename) {
  const joinedPath = path.join(DEFAULT_PATH, filePath, `${filename}.json`);
  if (existsSync(joinedPath)) {
    return JSON.parse(readFileSync(joinedPath, "utf8"));
  }
}
function writeJSONCache(filePath, filename, json) {
  const joinedFolderPath = path.join(DEFAULT_PATH, filePath);
  if (!existsSync(joinedFolderPath)) {
    mkdirSync(joinedFolderPath, { recursive: true });
  }
  const joinedFilePath = path.join(joinedFolderPath, `${filename}.json`);
  writeFileSync(
    joinedFilePath,
    JSON.stringify(
      json,
      (key, value) => typeof value === "bigint" ? value.toString() : value === void 0 ? null : value,
      2
    )
  );
}
export {
  CHAIN_ID_CLIENT_MAP,
  ChainId,
  arbitrumClient,
  arbitrumGoerliClient,
  arbitrumSepoliaClient,
  avalancheClient,
  baseClient,
  baseSepoliaClient,
  baseToCidv0,
  bnbClient,
  celoClient,
  compareStorageLayouts,
  decodeReserveConfigV2,
  decodeReserveConfigV3,
  fantomClient,
  fantomTestnetClient,
  fujiClient,
  getBits,
  getBlockAtTimestamp,
  getBytesValue,
  getContractDeploymentBlock,
  getDynamicArraySlot,
  getLink,
  getLogsRecursive,
  getProposalMetadata,
  getSolidityStorageSlotAddress,
  getSolidityStorageSlotBytes,
  getSolidityStorageSlotUint,
  gnosisClient,
  goerliClient,
  harmonyClient,
  mainnetClient,
  metisClient,
  mumbaiClient,
  optimismClient,
  optimismGoerliClient,
  optimismSepoliaClient,
  polygonClient,
  readJSONCache,
  scrollClient,
  scrollSepoliaClient,
  sepoliaClient,
  setBits,
  strategicGetLogs,
  uploadToPinata,
  uploadToQuicknode,
  uploadToTheGraph,
  writeJSONCache,
  zkEVMClient,
  zkSyncClient
};
//# sourceMappingURL=node.js.map