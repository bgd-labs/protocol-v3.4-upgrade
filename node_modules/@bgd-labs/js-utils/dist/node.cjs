"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/node.ts
var node_exports = {};
__export(node_exports, {
  CHAIN_ID_CLIENT_MAP: () => CHAIN_ID_CLIENT_MAP,
  ChainId: () => ChainId,
  arbitrumClient: () => arbitrumClient,
  arbitrumGoerliClient: () => arbitrumGoerliClient,
  arbitrumSepoliaClient: () => arbitrumSepoliaClient,
  avalancheClient: () => avalancheClient,
  baseClient: () => baseClient,
  baseSepoliaClient: () => baseSepoliaClient,
  baseToCidv0: () => baseToCidv0,
  bnbClient: () => bnbClient,
  celoClient: () => celoClient,
  compareStorageLayouts: () => compareStorageLayouts,
  decodeReserveConfigV2: () => decodeReserveConfigV2,
  decodeReserveConfigV3: () => decodeReserveConfigV3,
  fantomClient: () => fantomClient,
  fantomTestnetClient: () => fantomTestnetClient,
  fujiClient: () => fujiClient,
  getBits: () => getBits,
  getBlockAtTimestamp: () => getBlockAtTimestamp,
  getBytesValue: () => getBytesValue,
  getContractDeploymentBlock: () => getContractDeploymentBlock,
  getDynamicArraySlot: () => getDynamicArraySlot,
  getLink: () => getLink,
  getLogsRecursive: () => getLogsRecursive,
  getProposalMetadata: () => getProposalMetadata,
  getSolidityStorageSlotAddress: () => getSolidityStorageSlotAddress,
  getSolidityStorageSlotBytes: () => getSolidityStorageSlotBytes,
  getSolidityStorageSlotUint: () => getSolidityStorageSlotUint,
  gnosisClient: () => gnosisClient,
  goerliClient: () => goerliClient,
  harmonyClient: () => harmonyClient,
  mainnetClient: () => mainnetClient,
  metisClient: () => metisClient,
  mumbaiClient: () => mumbaiClient,
  optimismClient: () => optimismClient,
  optimismGoerliClient: () => optimismGoerliClient,
  optimismSepoliaClient: () => optimismSepoliaClient,
  polygonClient: () => polygonClient,
  readJSONCache: () => readJSONCache,
  scrollClient: () => scrollClient,
  scrollSepoliaClient: () => scrollSepoliaClient,
  sepoliaClient: () => sepoliaClient,
  setBits: () => setBits,
  strategicGetLogs: () => strategicGetLogs,
  uploadToPinata: () => uploadToPinata,
  uploadToQuicknode: () => uploadToQuicknode,
  uploadToTheGraph: () => uploadToTheGraph,
  writeJSONCache: () => writeJSONCache,
  zkEVMClient: () => zkEVMClient,
  zkSyncClient: () => zkSyncClient
});
module.exports = __toCommonJS(node_exports);

// src/foundry/storage-diff.ts
function compareStorageLayouts(layoutBefore, layoutAfter) {
  const layoutForComparisonBefore = preformatStorageLayout(layoutBefore);
  const layoutForComparisonAfter = preformatStorageLayout(layoutAfter);
  const comparison = compareStorageArrays(
    layoutForComparisonBefore,
    layoutForComparisonAfter
  );
  const md = generateMarkdownOutput(comparison);
  return md;
}
function preformatStorageLayout(json) {
  return json.storage.map((item) => ({
    label: item.label,
    offset: item.offset,
    slot: item.slot,
    type: json.types[item.type].label,
    numberOfBytes: json.types[item.type].numberOfBytes
  }));
}
function compareStorageArrays(oldArray, newArray) {
  const changes = [];
  const oldMap = new Map(
    oldArray.map((item) => [item.slot + "-" + item.offset, item])
  );
  const newMap = new Map(
    newArray.map((item) => [item.slot + "-" + item.offset, item])
  );
  oldArray.forEach((oldItem) => {
    const newItem = newMap.get(oldItem.slot + "-" + oldItem.offset);
    if (!newItem) {
      changes.push({ ...oldItem, status: "removed" });
    } else if (isDifferent(oldItem, newItem)) {
      changes.push({ ...oldItem, status: "removed" });
      changes.push({ ...newItem, status: "added" });
    } else {
      changes.push({ ...newItem, status: "unchanged" });
    }
  });
  newArray.forEach((newItem) => {
    if (!oldMap.has(newItem.slot + "-" + newItem.offset)) {
      changes.push({ ...newItem, status: "added" });
    }
  });
  changes.sort((a, b) => {
    if (a.slot === b.slot) {
      return a.offset - b.offset;
    }
    return a.slot.localeCompare(b.slot);
  });
  return changes;
}
function isDifferent(item1, item2) {
  return item1.offset !== item2.offset || item1.slot !== item2.slot || item1.type !== item2.type || item1.numberOfBytes !== item2.numberOfBytes;
}
function generateMarkdownOutput(items) {
  const columnWidths = {
    name: Math.max(...items.map((item) => item.label.length), "Label".length),
    offset: "Offset".length,
    slot: "Slot".length,
    type: Math.max(...items.map((item) => item.type.length), "Type".length),
    numberOfBytes: "Bytes".length
  };
  let markdownTable = "```diff\n";
  markdownTable += ` | ${"Label".padEnd(
    columnWidths.name,
    " "
  )} | ${"Offset".padEnd(columnWidths.offset, " ")} | ${"Slot".padEnd(
    columnWidths.slot,
    " "
  )} | ${"Type".padEnd(columnWidths.type, " ")} | ${"Bytes".padEnd(
    columnWidths.numberOfBytes,
    " "
  )} |
`;
  markdownTable += ` |${"-".repeat(columnWidths.name + 2)}|${"-".repeat(
    columnWidths.offset + 2
  )}|${"-".repeat(columnWidths.slot + 2)}|${"-".repeat(
    columnWidths.type + 2
  )}|${"-".repeat(columnWidths.numberOfBytes + 2)}||
`;
  items.forEach((item) => {
    const sign = item.status === "added" ? "+" : item.status === "removed" ? "-" : " ";
    const row = `${sign}| ${item.label.padEnd(
      columnWidths.name,
      " "
    )} | ${item.offset.toString().padEnd(columnWidths.offset, " ")} | ${item.slot.padEnd(
      columnWidths.slot,
      " "
    )} | ${item.type.padEnd(
      columnWidths.type,
      " "
    )} | ${item.numberOfBytes.padEnd(columnWidths.numberOfBytes, " ")} |
`;
    markdownTable += row;
  });
  markdownTable += "```";
  return markdownTable;
}

// src/rpc/chainIds.ts
var import_chains = require("viem/chains");
var ChainId = {
  mainnet: import_chains.mainnet.id,
  goerli: import_chains.goerli.id,
  polygon: import_chains.polygon.id,
  mumbai: import_chains.polygonMumbai.id,
  avalanche: import_chains.avalanche.id,
  fuji: import_chains.avalancheFuji.id,
  arbitrum_one: import_chains.arbitrum.id,
  arbitrum_goerli: import_chains.arbitrumGoerli.id,
  arbitrum_sepolia: import_chains.arbitrumSepolia.id,
  fantom: import_chains.fantom.id,
  fantom_testnet: import_chains.fantomTestnet.id,
  optimism: import_chains.optimism.id,
  optimism_sepolia: import_chains.optimismSepolia.id,
  optimism_goerli: import_chains.optimismGoerli.id,
  harmony: import_chains.harmonyOne.id,
  sepolia: import_chains.sepolia.id,
  scroll: import_chains.scroll.id,
  scroll_sepolia: import_chains.scrollSepolia.id,
  metis: import_chains.metis.id,
  base: import_chains.base.id,
  base_sepolia: import_chains.baseSepolia.id,
  bnb: import_chains.bsc.id,
  gnosis: import_chains.gnosis.id,
  zkEVM: import_chains.polygonZkEvm.id,
  celo: import_chains.celo.id,
  zkSync: import_chains.zkSync.id
};

// src/rpc/helpers.ts
var import_viem = require("viem");
var import_promise_pool = require("@supercharge/promise-pool");
var import_actions = require("viem/actions");
var import_node_util = require("util");
async function getContractDeploymentBlock({
  client,
  contractAddress,
  fromBlock,
  toBlock,
  maxDelta
}) {
  if (fromBlock == toBlock)
    return fromBlock;
  if (fromBlock < toBlock) {
    const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
    const codeMid = await (0, import_actions.getBytecode)(client, {
      blockNumber: midBlock,
      address: contractAddress
    });
    if (!codeMid) {
      if (toBlock - midBlock > maxDelta) {
        return getContractDeploymentBlock({
          client,
          contractAddress,
          fromBlock: midBlock,
          toBlock,
          maxDelta
        });
      } else {
        return midBlock;
      }
    }
    return getContractDeploymentBlock({
      client,
      contractAddress,
      fromBlock,
      toBlock: midBlock,
      maxDelta
    });
  }
  throw new Error("Could not find contract deployment block");
}
async function getBlockAtTimestamp({
  client,
  timestamp,
  fromBlock,
  toBlock,
  maxDelta
}) {
  if (fromBlock <= toBlock) {
    const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
    const block = await (0, import_actions.getBlock)(client, { blockNumber: midBlock });
    if (block.timestamp > timestamp) {
      return getBlockAtTimestamp({
        client,
        timestamp,
        fromBlock,
        toBlock: midBlock,
        maxDelta
      });
    } else {
      if (timestamp - block.timestamp < maxDelta) {
        return block;
      } else {
        return getBlockAtTimestamp({
          client,
          timestamp,
          fromBlock: midBlock,
          toBlock,
          maxDelta
        });
      }
    }
  }
  throw new Error("Could not find matching block");
}
async function strategicGetLogs({
  client,
  events,
  address,
  fromBlock,
  toBlock
}) {
  if (client.transport.key === "http") {
    const url = client.transport.url;
    let batchSize = 0;
    if (/llamarpc/.test(url))
      batchSize = 1e5;
    if (/quiknode/.test(url))
      batchSize = 1e4;
    if (/alchemy/.test(url)) {
      getLogsRecursive({ client, events, address, fromBlock, toBlock });
    }
    if (batchSize > 0) {
      return getLogsInBatches({
        client,
        events,
        address,
        fromBlock,
        toBlock,
        batchSize
      });
    }
  }
  return getLogsRecursive({ client, events, address, fromBlock, toBlock });
}
async function getLogsRecursive({
  client,
  events,
  address,
  fromBlock,
  toBlock
}) {
  (0, import_node_util.debug)("recursions")(`fetching from block ${fromBlock} to block ${toBlock}`);
  if (fromBlock <= toBlock) {
    try {
      const logs = await (0, import_actions.getLogs)(client, {
        fromBlock,
        toBlock,
        events,
        address
      });
      return logs;
    } catch (error) {
      const rangeMatch = error.details?.match(/.*\[(.*),\s*(.*)\]/);
      if (rangeMatch?.length === 3) {
        const maxBlock = (0, import_viem.fromHex)(rangeMatch[2], "bigint");
        const arr1 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock,
          toBlock: maxBlock
        });
        const midBlock = BigInt(maxBlock + toBlock) >> BigInt(1);
        const arr2 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock: maxBlock + BigInt(1),
          toBlock: midBlock
        });
        const arr3 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock: midBlock + BigInt(1),
          toBlock
        });
        return [...arr1, ...arr2, ...arr3];
      } else {
        const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
        const arr1 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock,
          toBlock: midBlock
        });
        const arr2 = await getLogsRecursive({
          client,
          events,
          address,
          fromBlock: midBlock + BigInt(1),
          toBlock
        });
        return [...arr1, ...arr2];
      }
    }
  }
  return [];
}
async function getLogsInBatches({
  client,
  events,
  address,
  fromBlock,
  toBlock,
  batchSize
}) {
  const batches = [];
  for (let i = Number(fromBlock); i < Number(toBlock); i = i + batchSize) {
    batches.push({
      from: BigInt(i),
      to: BigInt(i + batchSize - 1) > toBlock ? toBlock : BigInt(i + batchSize - 1)
    });
  }
  const { results, errors } = await import_promise_pool.PromisePool.for(batches).withConcurrency(5).useCorrespondingResults().process(async ({ from, to }) => {
    return (0, import_actions.getLogs)(client, {
      fromBlock: from,
      toBlock: to,
      events,
      address
    });
  });
  if (errors.length !== 0) {
    throw new Error("Error fetching logs");
  }
  return results.flat();
}

// src/rpc/clients.ts
var import_viem2 = require("viem");
var import_chains2 = require("viem/chains");
var commonConfig = { timeout: 3e4 };
var mainnetClient = (0, import_viem2.createClient)({
  chain: import_chains2.mainnet,
  transport: (0, import_viem2.http)(process.env.RPC_MAINNET, commonConfig)
});
var arbitrumClient = (0, import_viem2.createClient)({
  chain: import_chains2.arbitrum,
  transport: (0, import_viem2.http)(process.env.RPC_ARBITRUM, commonConfig)
});
var polygonClient = (0, import_viem2.createClient)({
  chain: import_chains2.polygon,
  transport: (0, import_viem2.http)(process.env.RPC_POLYGON, commonConfig)
});
var optimismClient = (0, import_viem2.createClient)({
  chain: import_chains2.optimism,
  transport: (0, import_viem2.http)(process.env.RPC_OPTIMISM, commonConfig)
});
var metisClient = (0, import_viem2.createClient)({
  chain: import_chains2.metis,
  transport: (0, import_viem2.http)(process.env.RPC_METIS, commonConfig)
});
var baseClient = (0, import_viem2.createClient)({
  chain: import_chains2.base,
  transport: (0, import_viem2.http)(process.env.RPC_BASE, commonConfig)
});
var fantomClient = (0, import_viem2.createClient)({
  chain: import_chains2.fantom,
  transport: (0, import_viem2.http)(process.env.RPC_FANTOM, commonConfig)
});
var bnbClient = (0, import_viem2.createClient)({
  chain: import_chains2.bsc,
  transport: (0, import_viem2.http)(process.env.RPC_BNB, commonConfig)
});
var avalancheClient = (0, import_viem2.createClient)({
  chain: import_chains2.avalanche,
  transport: (0, import_viem2.http)(process.env.RPC_AVALANCHE, commonConfig)
});
var gnosisClient = (0, import_viem2.createClient)({
  chain: import_chains2.gnosis,
  transport: (0, import_viem2.http)(process.env.RPC_GNOSIS, commonConfig)
});
var scrollClient = (0, import_viem2.createClient)({
  chain: import_chains2.scroll,
  transport: (0, import_viem2.http)(process.env.RPC_SCROLL, commonConfig)
});
var zkEVMClient = (0, import_viem2.createClient)({
  chain: import_chains2.polygonZkEvm,
  transport: (0, import_viem2.http)(process.env.RPC_ZKEVM, commonConfig)
});
var celoClient = (0, import_viem2.createClient)({
  chain: import_chains2.celo,
  transport: (0, import_viem2.http)(process.env.RPC_CELO, commonConfig)
});
var zkSyncClient = (0, import_viem2.createClient)({
  chain: import_chains2.zkSync,
  transport: (0, import_viem2.http)(process.env.RPC_ZKSYNC, commonConfig)
});
var harmonyClient = (0, import_viem2.createClient)({
  chain: import_chains2.harmonyOne,
  transport: (0, import_viem2.http)(process.env.RPC_HARMONY, commonConfig)
});
var fujiClient = (0, import_viem2.createClient)({
  chain: import_chains2.avalancheFuji,
  transport: (0, import_viem2.http)(process.env.RPC_FUJI, commonConfig)
});
var mumbaiClient = (0, import_viem2.createClient)({
  chain: import_chains2.polygonMumbai,
  transport: (0, import_viem2.http)(process.env.RPC_MUMBAI, commonConfig)
});
var sepoliaClient = (0, import_viem2.createClient)({
  chain: import_chains2.sepolia,
  transport: (0, import_viem2.http)(process.env.RPC_SEPOLIA, commonConfig)
});
var goerliClient = (0, import_viem2.createClient)({
  chain: import_chains2.goerli,
  transport: (0, import_viem2.http)(process.env.RPC_GOERLI, commonConfig)
});
var arbitrumGoerliClient = (0, import_viem2.createClient)({
  chain: import_chains2.arbitrumGoerli,
  transport: (0, import_viem2.http)(process.env.RPC_ARBITRUM_GOERLI, commonConfig)
});
var arbitrumSepoliaClient = (0, import_viem2.createClient)({
  chain: import_chains2.arbitrumSepolia,
  transport: (0, import_viem2.http)(process.env.RPC_ARBITRUM_SEPOLIA, commonConfig)
});
var optimismGoerliClient = (0, import_viem2.createClient)({
  chain: import_chains2.optimismGoerli,
  transport: (0, import_viem2.http)(process.env.RPC_OPTIMISM_GOERLI, commonConfig)
});
var optimismSepoliaClient = (0, import_viem2.createClient)({
  chain: import_chains2.optimismSepolia,
  transport: (0, import_viem2.http)(process.env.RPC_OPTIMISM_SEPOLIA, commonConfig)
});
var scrollSepoliaClient = (0, import_viem2.createClient)({
  chain: import_chains2.scrollSepolia,
  transport: (0, import_viem2.http)(process.env.RPC_SCROLL_SEPOLIA, commonConfig)
});
var fantomTestnetClient = (0, import_viem2.createClient)({
  chain: import_chains2.fantomTestnet,
  transport: (0, import_viem2.http)(process.env.RPC_FANTOM_TESTNET, commonConfig)
});
var baseSepoliaClient = (0, import_viem2.createClient)({
  chain: import_chains2.baseSepolia,
  transport: (0, import_viem2.http)(process.env.RPC_BASE_SEPOLIA, commonConfig)
});
var CHAIN_ID_CLIENT_MAP = {
  [ChainId.mainnet]: mainnetClient,
  [ChainId.arbitrum_one]: arbitrumClient,
  [ChainId.arbitrum_goerli]: arbitrumGoerliClient,
  [ChainId.arbitrum_sepolia]: arbitrumSepoliaClient,
  [ChainId.polygon]: polygonClient,
  [ChainId.optimism]: optimismClient,
  [ChainId.optimism_goerli]: optimismGoerliClient,
  [ChainId.optimism_sepolia]: optimismSepoliaClient,
  [ChainId.metis]: metisClient,
  [ChainId.base]: baseClient,
  [ChainId.base_sepolia]: baseSepoliaClient,
  [ChainId.sepolia]: sepoliaClient,
  [ChainId.goerli]: goerliClient,
  [ChainId.fantom]: fantomClient,
  [ChainId.fantom_testnet]: fantomTestnetClient,
  [ChainId.bnb]: bnbClient,
  [ChainId.avalanche]: avalancheClient,
  [ChainId.gnosis]: gnosisClient,
  [ChainId.scroll]: scrollClient,
  [ChainId.scroll_sepolia]: scrollSepoliaClient,
  [ChainId.zkEVM]: zkEVMClient,
  [ChainId.celo]: celoClient,
  [ChainId.zkSync]: zkSyncClient,
  [ChainId.fuji]: fujiClient,
  [ChainId.mumbai]: mumbaiClient,
  [ChainId.harmony]: harmonyClient
};

// src/ipfs/hash.ts
var import_bs58 = __toESM(require("bs58"), 1);
function baseToCidv0(hash) {
  return import_bs58.default.encode(Buffer.from(`1220${hash.slice(2)}`, "hex"));
}

// src/ipfs/upload.ts
async function uploadToPinata(source) {
  const PINATA_KEY = process.env.PINATA_KEY;
  if (!PINATA_KEY)
    throw new Error("PINATA_KEY env must be set");
  const PINATA_SECRET = process.env.PINATA_SECRET;
  if (!PINATA_SECRET)
    throw new Error("PINATA_SECRET env must be set");
  const data = new FormData();
  data.append("file", new Blob([source]));
  const res = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
    method: "POST",
    body: data,
    headers: {
      pinata_api_key: PINATA_KEY,
      pinata_secret_api_key: PINATA_SECRET
    }
  });
  if (!res.ok) {
    throw Error(await res.text());
  }
  const result = await res.json();
  if (result.error)
    throw { message: result.error };
  return result;
}
async function uploadToTheGraph(source) {
  const data = new FormData();
  data.append("file", new Blob([source]));
  const res = await fetch("https://api.thegraph.com/ipfs/api/v0/add", {
    method: "POST",
    body: data
  });
  return res.json();
}
async function uploadToQuicknode(source, key) {
  const apiKey = process.env.QUICKNODE_API_KEY;
  const headers = new Headers();
  headers.append("x-api-key", apiKey);
  const data = new FormData();
  data.append("Body", new Blob([source]));
  data.append("Key", key || "unknownKey");
  data.append("ContentType", "text/plain");
  const res = await fetch(
    "https://api.quicknode.com/ipfs/rest/v1/s3/put-object",
    {
      method: "POST",
      headers,
      body: data,
      redirect: "follow"
    }
  );
  return res.text();
}

// src/ipfs/parseIpfs.ts
var import_gray_matter = __toESM(require("gray-matter"), 1);
function getLink(hash, gateway) {
  return `${gateway}/${hash}`;
}
async function getProposalMetadata(hash, gateway = "https://cloudflare-ipfs.com/ipfs") {
  const ipfsHash = hash.startsWith("0x") ? baseToCidv0(hash) : hash;
  const ipfsPath = getLink(ipfsHash, gateway);
  const ipfsResponse = await fetch(ipfsPath, {
    headers: {
      "Content-Type": "application/json"
    }
  });
  if (!ipfsResponse.ok)
    throw Error(`IPFS: error fetching ${ipfsPath}`);
  const clone = ipfsResponse.clone();
  try {
    const response = await ipfsResponse.json();
    const { content, data } = (0, import_gray_matter.default)(response.description);
    return {
      ...response,
      ipfsHash,
      description: content,
      ...data
    };
  } catch (e) {
    const { content, data } = (0, import_gray_matter.default)(await clone.text());
    return {
      ...ipfsResponse,
      ipfsHash,
      description: content,
      ...data
    };
  }
}

// src/storage/storageSlots.ts
var import_viem3 = require("viem");
function getSolidityStorageSlotBytes(mappingSlot, key) {
  const slot = (0, import_viem3.pad)(mappingSlot, { size: 32 });
  return (0, import_viem3.trim)(
    (0, import_viem3.keccak256)(
      (0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("bytes32, uint256"), [
        key,
        BigInt(slot)
      ])
    )
  );
}
function getSolidityStorageSlotUint(mappingSlot, key) {
  return (0, import_viem3.keccak256)(
    (0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("uint256, uint256"), [
      key,
      mappingSlot
    ])
  );
}
function getSolidityStorageSlotAddress(mappingSlot, key) {
  return (0, import_viem3.keccak256)(
    (0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("address, uint256"), [
      key,
      BigInt(mappingSlot)
    ])
  );
}
function getDynamicArraySlot(baseSlot, arrayIndex, itemSize) {
  return (0, import_viem3.pad)(
    (0, import_viem3.toHex)(
      (0, import_viem3.fromHex)(
        (0, import_viem3.keccak256)(
          (0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("uint256"), [baseSlot])
        ),
        "bigint"
      ) + BigInt(arrayIndex * itemSize)
    ),
    { size: 32 }
  );
}
function getBytesValue(value) {
  const bytesString = (0, import_viem3.toBytes)(value);
  if (bytesString.length > 31)
    throw new Error("Error: strings > 31 bytes are not implemented");
  return (0, import_viem3.concat)([
    (0, import_viem3.toHex)((0, import_viem3.pad)(bytesString, { size: 31, dir: "right" })),
    (0, import_viem3.toHex)(bytesString.length * 2, { size: 1 })
  ]);
}
function getBits(_bigIntValue, startBit, _endBit) {
  let endBit = _endBit;
  const bigIntValue = BigInt(_bigIntValue);
  if (startBit > endBit) {
    throw new Error(
      "Invalid bit range: startBit must be less than or equal to endBit"
    );
  }
  const bitLength = BigInt(bigIntValue.toString(2)).toString().length;
  if (endBit >= bitLength) {
    endBit = BigInt(bitLength - 1);
  }
  const mask = (1n << endBit - startBit + 1n) - 1n;
  const maskedValue = bigIntValue >> startBit & mask;
  return maskedValue.toString();
}
function setBits(_bigIntBase, startBit, endBit, _replaceValue) {
  const bigIntBase = BigInt(_bigIntBase);
  const bigIntReplaceValue = BigInt(_replaceValue);
  let mask = BigInt(0);
  for (let i = startBit; i < endBit; i++) {
    mask |= BigInt(1) << BigInt(i);
  }
  const clearedNumber = bigIntBase & ~mask;
  const result = clearedNumber | bigIntReplaceValue << BigInt(startBit);
  return result;
}

// src/storage/poolStorage.ts
function decodeReserveConfigV2(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const reserveFactor = getBits(data, 64n, 79n);
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableBorrowingEnabled: !!stableBorrowingEnabled,
    reserveFactor
  };
}
function decodeReserveConfigV3(data) {
  const ltv = getBits(data, 0n, 15n);
  const liquidationThreshold = getBits(data, 16n, 31n);
  const liquidationBonus = getBits(data, 32n, 47n);
  const decimals = getBits(data, 48n, 55n);
  const active = Number(getBits(data, 56n, 56n));
  const frozen = Number(getBits(data, 57n, 57n));
  const borrowingEnabled = Number(getBits(data, 58n, 58n));
  const stableRateBorrowingEnabled = Number(getBits(data, 59n, 59n));
  const paused = Number(getBits(data, 60n, 60n));
  const borrowingInIsolation = Number(getBits(data, 61n, 61n));
  const siloedBorrowingEnabled = Number(getBits(data, 62n, 62n));
  const flashloaningEnabled = Number(getBits(data, 63n, 63n));
  const reserveFactor = getBits(data, 64n, 79n);
  const borrowCap = getBits(data, 80n, 115n);
  const supplyCap = getBits(data, 116n, 151n);
  const liquidationProtocolFee = getBits(data, 152n, 167n);
  const eModeCategory = getBits(data, 168n, 175n);
  const unbackedMintCap = getBits(data, 176n, 211n);
  const debtCeiling = getBits(data, 212n, 251n);
  return {
    ltv,
    liquidationThreshold,
    liquidationBonus,
    decimals,
    active: !!active,
    frozen: !!frozen,
    borrowingEnabled: !!borrowingEnabled,
    stableRateBorrowingEnabled: !!stableRateBorrowingEnabled,
    paused: !!paused,
    borrowingInIsolation: !!borrowingInIsolation,
    reserveFactor,
    borrowCap,
    supplyCap,
    liquidationProtocolFee,
    eModeCategory,
    unbackedMintCap,
    debtCeiling,
    siloedBorrowingEnabled: !!siloedBorrowingEnabled,
    flashloaningEnabled: !!flashloaningEnabled
  };
}

// src/cache/json.ts
var import_fs = require("fs");
var import_path = __toESM(require("path"), 1);
var DEFAULT_PATH = import_path.default.join(process.cwd(), "cache");
function readJSONCache(filePath, filename) {
  const joinedPath = import_path.default.join(DEFAULT_PATH, filePath, `${filename}.json`);
  if ((0, import_fs.existsSync)(joinedPath)) {
    return JSON.parse((0, import_fs.readFileSync)(joinedPath, "utf8"));
  }
}
function writeJSONCache(filePath, filename, json) {
  const joinedFolderPath = import_path.default.join(DEFAULT_PATH, filePath);
  if (!(0, import_fs.existsSync)(joinedFolderPath)) {
    (0, import_fs.mkdirSync)(joinedFolderPath, { recursive: true });
  }
  const joinedFilePath = import_path.default.join(joinedFolderPath, `${filename}.json`);
  (0, import_fs.writeFileSync)(
    joinedFilePath,
    JSON.stringify(
      json,
      (key, value) => typeof value === "bigint" ? value.toString() : value === void 0 ? null : value,
      2
    )
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CHAIN_ID_CLIENT_MAP,
  ChainId,
  arbitrumClient,
  arbitrumGoerliClient,
  arbitrumSepoliaClient,
  avalancheClient,
  baseClient,
  baseSepoliaClient,
  baseToCidv0,
  bnbClient,
  celoClient,
  compareStorageLayouts,
  decodeReserveConfigV2,
  decodeReserveConfigV3,
  fantomClient,
  fantomTestnetClient,
  fujiClient,
  getBits,
  getBlockAtTimestamp,
  getBytesValue,
  getContractDeploymentBlock,
  getDynamicArraySlot,
  getLink,
  getLogsRecursive,
  getProposalMetadata,
  getSolidityStorageSlotAddress,
  getSolidityStorageSlotBytes,
  getSolidityStorageSlotUint,
  gnosisClient,
  goerliClient,
  harmonyClient,
  mainnetClient,
  metisClient,
  mumbaiClient,
  optimismClient,
  optimismGoerliClient,
  optimismSepoliaClient,
  polygonClient,
  readJSONCache,
  scrollClient,
  scrollSepoliaClient,
  sepoliaClient,
  setBits,
  strategicGetLogs,
  uploadToPinata,
  uploadToQuicknode,
  uploadToTheGraph,
  writeJSONCache,
  zkEVMClient,
  zkSyncClient
});
//# sourceMappingURL=node.cjs.map