import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/abitype/dist/esm/regex.js
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match?.groups;
}
var init_regex = () => {
};

// node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let i = 0;i < length; i++) {
      const component = abiParameter.components[i];
      type += formatAbiParameter(component);
      if (i < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
var tupleRegex;
var init_formatAbiParameter = __esm(() => {
  init_regex();
  tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
});

// node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0;i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
var init_formatAbiParameters = __esm(() => {
  init_formatAbiParameter();
});

// node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  else if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  else if (abiItem.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
var init_formatAbiItem = __esm(() => {
  init_formatAbiParameters();
});

// node_modules/abitype/dist/esm/exports/index.js
var init_exports = __esm(() => {
  init_formatAbiItem();
});

// node_modules/viem/_esm/utils/abi/formatAbiItem.js
function formatAbiItem2(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
var init_formatAbiItem2 = __esm(() => {
  init_abi();
});

// node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

// node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = () => {
};

// node_modules/viem/_esm/errors/version.js
var version = "2.9.20";

// node_modules/viem/_esm/errors/utils.js
var getContractAddress = (address) => address, getUrl = (url) => url, getVersion = () => `viem@${version}`;
var init_utils = () => {
};

// node_modules/viem/_esm/errors/base.js
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn);
  return fn ? null : err;
}
var BaseError;
var init_base = __esm(() => {
  init_utils();
  BaseError = class BaseError extends Error {
    constructor(shortMessage, args = {}) {
      super();
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ViemError"
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: getVersion()
      });
      const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
      const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
      this.message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath ? [
          `Docs: https://viem.sh${docsPath}${args.docsSlug ? `#${args.docsSlug}` : ""}`
        ] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: ${this.version}`
      ].join("\n");
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
    walk(fn) {
      return walk(this, fn);
    }
  };
});

// node_modules/viem/_esm/errors/abi.js
var AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiItemAmbiguityError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
var init_abi = __esm(() => {
  init_formatAbiItem2();
  init_size();
  init_base();
  AbiDecodingDataSizeTooSmallError = class AbiDecodingDataSizeTooSmallError extends BaseError {
    constructor({ data, params, size: size2 }) {
      super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingDataSizeTooSmallError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  AbiDecodingZeroDataError = class AbiDecodingZeroDataError extends BaseError {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.');
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingZeroDataError"
      });
    }
  };
  AbiEncodingArrayLengthMismatchError = class AbiEncodingArrayLengthMismatchError extends BaseError {
    constructor({ expectedLength, givenLength, type }) {
      super([
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingArrayLengthMismatchError"
      });
    }
  };
  AbiEncodingBytesSizeMismatchError = class AbiEncodingBytesSizeMismatchError extends BaseError {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingBytesSizeMismatchError"
      });
    }
  };
  AbiEncodingLengthMismatchError = class AbiEncodingLengthMismatchError extends BaseError {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingLengthMismatchError"
      });
    }
  };
  AbiErrorSignatureNotFoundError = class AbiErrorSignatureNotFoundError extends BaseError {
    constructor(signature, { docsPath }) {
      super([
        `Encoded error signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"), {
        docsPath
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiErrorSignatureNotFoundError"
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.signature = signature;
    }
  };
  AbiEventSignatureEmptyTopicsError = class AbiEventSignatureEmptyTopicsError extends BaseError {
    constructor({ docsPath }) {
      super("Cannot extract event signature from empty topics.", {
        docsPath
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventSignatureEmptyTopicsError"
      });
    }
  };
  AbiEventSignatureNotFoundError = class AbiEventSignatureNotFoundError extends BaseError {
    constructor(signature, { docsPath }) {
      super([
        `Encoded event signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"), {
        docsPath
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventSignatureNotFoundError"
      });
    }
  };
  AbiEventNotFoundError = class AbiEventNotFoundError extends BaseError {
    constructor(eventName, { docsPath } = {}) {
      super([
        `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it."
      ].join("\n"), {
        docsPath
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventNotFoundError"
      });
    }
  };
  AbiFunctionNotFoundError = class AbiFunctionNotFoundError extends BaseError {
    constructor(functionName, { docsPath } = {}) {
      super([
        `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"), {
        docsPath
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionNotFoundError"
      });
    }
  };
  AbiFunctionOutputsNotFoundError = class AbiFunctionOutputsNotFoundError extends BaseError {
    constructor(functionName, { docsPath }) {
      super([
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"), {
        docsPath
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionOutputsNotFoundError"
      });
    }
  };
  AbiItemAmbiguityError = class AbiItemAmbiguityError extends BaseError {
    constructor(x, y) {
      super("Found ambiguous types in overloaded ABI items.", {
        metaMessages: [
          `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
          `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
          "",
          "These types encode differently and cannot be distinguished at runtime.",
          "Remove one of the ambiguous items in the ABI."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiItemAmbiguityError"
      });
    }
  };
  DecodeLogDataMismatch = class DecodeLogDataMismatch extends BaseError {
    constructor({ abiItem, data, params, size: size2 }) {
      super([
        `Data size of ${size2} bytes is too small for non-indexed event parameters.`
      ].join("\n"), {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DecodeLogDataMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  DecodeLogTopicsMismatch = class DecodeLogTopicsMismatch extends BaseError {
    constructor({ abiItem, param }) {
      super([
        `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem2(abiItem, { includeName: true })}".`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DecodeLogTopicsMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
    }
  };
  InvalidAbiEncodingTypeError = class InvalidAbiEncodingTypeError extends BaseError {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"), { docsPath });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiEncodingType"
      });
    }
  };
  InvalidAbiDecodingTypeError = class InvalidAbiDecodingTypeError extends BaseError {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid decoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"), { docsPath });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiDecodingType"
      });
    }
  };
  InvalidArrayError = class InvalidArrayError extends BaseError {
    constructor(value) {
      super([`Value "${value}" is not a valid array.`].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidArrayError"
      });
    }
  };
  InvalidDefinitionTypeError = class InvalidDefinitionTypeError extends BaseError {
    constructor(type) {
      super([
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidDefinitionTypeError"
      });
    }
  };
});

// node_modules/viem/_esm/errors/data.js
var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError, InvalidBytesLengthError;
var init_data = __esm(() => {
  init_base();
  SliceOffsetOutOfBoundsError = class SliceOffsetOutOfBoundsError extends BaseError {
    constructor({ offset, position, size: size2 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SliceOffsetOutOfBoundsError"
      });
    }
  };
  SizeExceedsPaddingSizeError = class SizeExceedsPaddingSizeError extends BaseError {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SizeExceedsPaddingSizeError"
      });
    }
  };
  InvalidBytesLengthError = class InvalidBytesLengthError extends BaseError {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidBytesLengthError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes;
  if (bytes.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0;i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm(() => {
  init_data();
});

// node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, InvalidBytesBooleanError, SizeOverflowError;
var init_encoding = __esm(() => {
  init_base();
  IntegerOutOfRangeError = class IntegerOutOfRangeError extends BaseError {
    constructor({ max, min, signed, size: size2, value }) {
      super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "IntegerOutOfRangeError"
      });
    }
  };
  InvalidBytesBooleanError = class InvalidBytesBooleanError extends BaseError {
    constructor(bytes) {
      super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidBytesBooleanError"
      });
    }
  };
  SizeOverflowError = class SizeOverflowError extends BaseError {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SizeOverflowError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0;i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

// node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size2 }) {
  if (size(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
var init_fromHex = __esm(() => {
  init_encoding();
  init_size();
});

// node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex(value, opts = {}) {
  let string = "";
  for (let i = 0;i < value.length; i++) {
    string += hexes[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex(value, opts);
}
var hexes, encoder;
var init_toHex = __esm(() => {
  init_encoding();
  init_pad();
  init_fromHex();
  hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  encoder = /* @__PURE__ */ new TextEncoder;
});

// node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { size: opts.size });
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0;index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { dir: "right", size: opts.size });
  }
  return bytes;
}
var encoder2, charCodeMap;
var init_toBytes = __esm(() => {
  init_base();
  init_pad();
  init_fromHex();
  init_toHex();
  encoder2 = /* @__PURE__ */ new TextEncoder;
  charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
});

// node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var init__assert = () => {
};

// node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var U32_MASK64, _32n, rotlSH = (h, l, s) => h << s | l >>> 32 - s, rotlSL = (h, l, s) => l << s | h >>> 32 - s, rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s, rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
var init__u64 = __esm(() => {
  U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  _32n = /* @__PURE__ */ BigInt(32);
});

// node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes(str2) {
  if (typeof str2 !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

class Hash {
  clone() {
    return this._cloneInto();
  }
}
var u8a = (a) => a instanceof Uint8Array, u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4)), createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength), rotr = (word, shift) => word << 32 - shift | word >>> shift, isLE, toStr;
var init_utils2 = __esm(() => {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  toStr = {}.toString;
});

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s), rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s), Keccak, gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen)), sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)), shake128, shake256;
var init_sha3 = __esm(() => {
  init__assert();
  init__u64();
  init_utils2();
  [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  _0n = /* @__PURE__ */ BigInt(0);
  _1n = /* @__PURE__ */ BigInt(1);
  _2n = /* @__PURE__ */ BigInt(2);
  _7n = /* @__PURE__ */ BigInt(7);
  _256n = /* @__PURE__ */ BigInt(256);
  _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  Keccak = class Keccak extends Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
});

// node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes2 = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes2;
  return toHex(bytes2);
}
var init_keccak256 = __esm(() => {
  init_sha3();
  init_toBytes();
  init_toHex();
});

// node_modules/viem/_esm/utils/hash/hashSignature.js
function hashSignature(sig) {
  return hash(sig);
}
var hash = (value) => keccak256(toBytes(value));
var init_hashSignature = __esm(() => {
  init_toBytes();
  init_keccak256();
});

// node_modules/viem/_esm/utils/hash/normalizeSignature.js
function normalizeSignature(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0;i < signature.length; i++) {
    const char = signature[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError("Unable to normalize signature.");
  return result;
}
var init_normalizeSignature = __esm(() => {
  init_base();
});

// node_modules/viem/_esm/utils/hash/toSignature.js
var toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem(def);
  })();
  return normalizeSignature(def_);
};
var init_toSignature = __esm(() => {
  init_exports();
  init_normalizeSignature();
});

// node_modules/viem/_esm/utils/hash/toSignatureHash.js
function toSignatureHash(fn) {
  return hashSignature(toSignature(fn));
}
var init_toSignatureHash = __esm(() => {
  init_hashSignature();
  init_toSignature();
});

// node_modules/viem/_esm/utils/hash/toEventSelector.js
var toEventSelector;
var init_toEventSelector = __esm(() => {
  init_toSignatureHash();
  toEventSelector = toSignatureHash;
});

// node_modules/viem/_esm/errors/address.js
var InvalidAddressError;
var init_address = __esm(() => {
  init_base();
  InvalidAddressError = class InvalidAddressError extends BaseError {
    constructor({ address }) {
      super(`Address "${address}" is invalid.`, {
        metaMessages: [
          "- Address must be a hex value of 20 bytes (40 hex characters).",
          "- Address must match its checksum counterpart."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAddressError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/lru.js
var LruMap;
var init_lru = __esm(() => {
  LruMap = class LruMap extends Map {
    constructor(size2) {
      super();
      Object.defineProperty(this, "maxSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.maxSize = size2;
    }
    set(key, value) {
      super.set(key, value);
      if (this.maxSize && this.size > this.maxSize)
        this.delete(this.keys().next().value);
      return this;
    }
  };
});

// node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0;i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  return `0x${address.join("")}`;
}
var init_getAddress = __esm(() => {
  init_toBytes();
  init_keccak256();
});

// node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address, options2) {
  const { strict = true } = options2 ?? {};
  if (isAddressCache.has(address))
    return isAddressCache.get(address);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(address, result);
  return result;
}
var addressRegex, isAddressCache;
var init_isAddress = __esm(() => {
  init_lru();
  init_getAddress();
  addressRegex = /^0x[a-fA-F0-9]{40}$/;
  isAddressCache = /* @__PURE__ */ new LruMap(8192);
});

// node_modules/viem/_esm/utils/data/concat.js
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes(values);
}
function concatBytes(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}

// node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var init_slice = __esm(() => {
  init_data();
  init_size();
});

// node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0;i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber(value, { signed });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0;i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0;i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0;i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  if (typeof value !== "boolean")
    throw new BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue) / 32);
  const parts = [];
  for (let i = 0;i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(size(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0;i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}
var init_encodeAbiParameters = __esm(() => {
  init_abi();
  init_address();
  init_base();
  init_isAddress();
  init_pad();
  init_size();
  init_slice();
  init_toHex();
});

// node_modules/viem/_esm/utils/hash/toFunctionSelector.js
var toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
var init_toFunctionSelector = __esm(() => {
  init_slice();
  init_toSignatureHash();
});

// node_modules/viem/_esm/utils/abi/getAbiItem.js
function getAbiItem(parameters) {
  const { abi, args = [], name } = parameters;
  const isSelector = isHex(name, { strict: false });
  const abiItems = abi.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = undefined;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index) => {
          return isArgOfType(Object.values(arg)[index], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return isAddress(args[parameterIndex], { strict: false });
      if (types.includes("address") && types.includes("bytes"))
        return isAddress(args[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}
var init_getAbiItem = __esm(() => {
  init_abi();
  init_isAddress();
  init_toEventSelector();
  init_toFunctionSelector();
});

// node_modules/viem/_esm/accounts/utils/parseAccount.js
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}

// node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js
function prepareEncodeFunctionData(parameters) {
  const { abi, args, functionName } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath2 });
  return {
    abi: [abiItem],
    functionName: toFunctionSelector(formatAbiItem2(abiItem))
  };
}
var docsPath2 = "/docs/contract/encodeFunctionData";
var init_prepareEncodeFunctionData = __esm(() => {
  init_abi();
  init_toFunctionSelector();
  init_formatAbiItem2();
  init_getAbiItem();
});

// node_modules/viem/_esm/utils/abi/encodeFunctionData.js
function encodeFunctionData(parameters) {
  const { args } = parameters;
  const { abi, functionName } = (() => {
    if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
      return parameters;
    return prepareEncodeFunctionData(parameters);
  })();
  const abiItem = abi[0];
  const signature = functionName;
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : undefined;
  return concatHex([signature, data ?? "0x"]);
}
var init_encodeFunctionData = __esm(() => {
  init_encodeAbiParameters();
  init_prepareEncodeFunctionData();
});

// node_modules/viem/_esm/constants/solidity.js
var panicReasons, solidityError, solidityPanic;
var init_solidity = __esm(() => {
  panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmetic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
  };
  solidityError = {
    inputs: [
      {
        name: "message",
        type: "string"
      }
    ],
    name: "Error",
    type: "error"
  };
  solidityPanic = {
    inputs: [
      {
        name: "reason",
        type: "uint256"
      }
    ],
    name: "Panic",
    type: "error"
  };
});

// node_modules/viem/_esm/errors/cursor.js
var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
var init_cursor = __esm(() => {
  init_base();
  NegativeOffsetError = class NegativeOffsetError extends BaseError {
    constructor({ offset }) {
      super(`Offset \`${offset}\` cannot be negative.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NegativeOffsetError"
      });
    }
  };
  PositionOutOfBoundsError = class PositionOutOfBoundsError extends BaseError {
    constructor({ length, position }) {
      super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PositionOutOfBoundsError"
      });
    }
  };
  RecursiveReadLimitExceededError = class RecursiveReadLimitExceededError extends BaseError {
    constructor({ count, limit }) {
      super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RecursiveReadLimitExceededError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/cursor.js
function createCursor(bytes2, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes2;
  cursor.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  cursor.positionReadCount = new Map;
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
var staticCursor;
var init_cursor2 = __esm(() => {
  init_cursor();
  staticCursor = {
    bytes: new Uint8Array,
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map,
    recursiveReadCount: 0,
    recursiveReadLimit: Infinity,
    assertReadLimit() {
      if (this.recursiveReadCount >= this.recursiveReadLimit)
        throw new RecursiveReadLimitExceededError({
          count: this.recursiveReadCount + 1,
          limit: this.recursiveReadLimit
        });
    },
    assertPosition(position) {
      if (position < 0 || position > this.bytes.length - 1)
        throw new PositionOutOfBoundsError({
          length: this.bytes.length,
          position
        });
    },
    decrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position - offset;
      this.assertPosition(position);
      this.position = position;
    },
    getReadCount(position) {
      return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position + offset;
      this.assertPosition(position);
      this.position = position;
    },
    inspectByte(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectBytes(length, position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + length - 1);
      return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectUint16(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 1);
      return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 2);
      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 3);
      return this.dataView.getUint32(position);
    },
    pushByte(byte) {
      this.assertPosition(this.position);
      this.bytes[this.position] = byte;
      this.position++;
    },
    pushBytes(bytes2) {
      this.assertPosition(this.position + bytes2.length - 1);
      this.bytes.set(bytes2, this.position);
      this.position += bytes2.length;
    },
    pushUint8(value) {
      this.assertPosition(this.position);
      this.bytes[this.position] = value;
      this.position++;
    },
    pushUint16(value) {
      this.assertPosition(this.position + 1);
      this.dataView.setUint16(this.position, value);
      this.position += 2;
    },
    pushUint24(value) {
      this.assertPosition(this.position + 2);
      this.dataView.setUint16(this.position, value >> 8);
      this.dataView.setUint8(this.position + 2, value & ~4294967040);
      this.position += 3;
    },
    pushUint32(value) {
      this.assertPosition(this.position + 3);
      this.dataView.setUint32(this.position, value);
      this.position += 4;
    },
    readByte() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectByte();
      this.position++;
      return value;
    },
    readBytes(length, size2) {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectBytes(length);
      this.position += size2 ?? length;
      return value;
    },
    readUint8() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint8();
      this.position += 1;
      return value;
    },
    readUint16() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint16();
      this.position += 2;
      return value;
    },
    readUint24() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint24();
      this.position += 3;
      return value;
    },
    readUint32() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint32();
      this.position += 4;
      return value;
    },
    get remaining() {
      return this.bytes.length - this.position;
    },
    setPosition(position) {
      const oldPosition = this.position;
      this.assertPosition(position);
      this.position = position;
      return () => this.position = oldPosition;
    },
    _touch() {
      if (this.recursiveReadLimit === Infinity)
        return;
      const count = this.getReadCount();
      this.positionReadCount.set(this.position, count + 1);
      if (count > 0)
        this.recursiveReadCount++;
    }
  };
});

// node_modules/viem/_esm/utils/encoding/fromBytes.js
function bytesToBigInt(bytes2, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes2, { size: opts.size });
  const hex = bytesToHex(bytes2, opts);
  return hexToBigInt(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes2 = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes2, { size: opts.size });
    bytes2 = trim(bytes2);
  }
  if (bytes2.length > 1 || bytes2[0] > 1)
    throw new InvalidBytesBooleanError(bytes2);
  return Boolean(bytes2[0]);
}
function bytesToNumber(bytes2, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes2, { size: opts.size });
  const hex = bytesToHex(bytes2, opts);
  return hexToNumber(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes2 = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes2, { size: opts.size });
    bytes2 = trim(bytes2, { dir: "right" });
  }
  return new TextDecoder().decode(bytes2);
}
var init_fromBytes = __esm(() => {
  init_encoding();
  init_fromHex();
  init_toHex();
});

// node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
function decodeAbiParameters(params, data) {
  const bytes2 = typeof data === "string" ? hexToBytes(data) : data;
  const cursor = createCursor(bytes2);
  if (size(bytes2) === 0 && params.length > 0)
    throw new AbiDecodingZeroDataError;
  if (size(data) && size(data) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof data === "string" ? data : bytesToHex(data),
      params,
      size: size(data)
    });
  let consumed = 0;
  const values = [];
  for (let i = 0;i < params.length; ++i) {
    const param = params[i];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, param, {
      staticPosition: 0
    });
    consumed += consumed_;
    values.push(data2);
  }
  return values;
}
function decodeParameter(cursor, param, { staticPosition }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(cursor, { ...param, type }, { length, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, { staticPosition });
  if (param.type === "address")
    return decodeAddress(cursor);
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(cursor) {
  const value = cursor.readBytes(32);
  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];
}
function decodeArray(cursor, param, { length, staticPosition }) {
  if (!length) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value2 = [];
    for (let i = 0;i < length2; ++i) {
      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(param)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const value2 = [];
    for (let i = 0;i < length; ++i) {
      cursor.setPosition(start + i * 32);
      const [data] = decodeParameter(cursor, param, {
        staticPosition: start
      });
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let i = 0;i < length; ++i) {
    const [data, consumed_] = decodeParameter(cursor, param, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data);
  }
  return [value, consumed];
}
function decodeBool(cursor) {
  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
  const [_, size2] = param.type.split("bytes");
  if (!size2) {
    const offset = bytesToNumber(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [bytesToHex(data), 32];
  }
  const value = bytesToHex(cursor.readBytes(parseInt(size2), 32));
  return [value, 32];
}
function decodeNumber(cursor, param) {
  const signed = param.type.startsWith("int");
  const size2 = parseInt(param.type.split("int")[1] || "256");
  const value = cursor.readBytes(32);
  return [
    size2 > 48 ? bytesToBigInt(value, { signed }) : bytesToNumber(value, { signed }),
    32
  ];
}
function decodeTuple(cursor, param, { staticPosition }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    for (let i = 0;i < param.components.length; ++i) {
      const component = param.components[i];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition: start
      });
      consumed += consumed_;
      value[hasUnnamedChild ? i : component?.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let i = 0;i < param.components.length; ++i) {
    const component = param.components[i];
    const [data, consumed_] = decodeParameter(cursor, component, {
      staticPosition
    });
    value[hasUnnamedChild ? i : component?.name] = data;
    consumed += consumed_;
  }
  return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset = bytesToNumber(cursor.readBytes(32));
  const start = staticPosition + offset;
  cursor.setPosition(start);
  const length = bytesToNumber(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value = bytesToString(trim(data));
  cursor.setPosition(staticPosition + 32);
  return [value, 32];
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
var sizeOfLength = 32, sizeOfOffset = 32;
var init_decodeAbiParameters = __esm(() => {
  init_abi();
  init_getAddress();
  init_cursor2();
  init_size();
  init_slice();
  init_fromBytes();
  init_toBytes();
  init_toHex();
  init_encodeAbiParameters();
});

// node_modules/viem/_esm/utils/abi/decodeErrorResult.js
function decodeErrorResult(parameters) {
  const { abi, data } = parameters;
  const signature = slice(data, 0, 4);
  if (signature === "0x")
    throw new AbiDecodingZeroDataError;
  const abi_ = [...abi || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x) => x.type === "error" && signature === toFunctionSelector(formatAbiItem2(x)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : undefined,
    errorName: abiItem.name
  };
}
var init_decodeErrorResult = __esm(() => {
  init_solidity();
  init_abi();
  init_slice();
  init_toFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem2();
});

// node_modules/viem/_esm/utils/stringify.js
var stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);

// node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify(args[i]) : args[i]}`).join(", ")})`;
}
var init_formatAbiItemWithArgs = () => {
};

// node_modules/viem/_esm/constants/unit.js
var etherUnits, gweiUnits;
var init_unit = __esm(() => {
  etherUnits = {
    gwei: 9,
    wei: 18
  };
  gweiUnits = {
    ether: -9,
    wei: 9
  };
});

// node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// node_modules/viem/_esm/utils/unit/formatEther.js
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
var init_formatEther = __esm(() => {
  init_unit();
});

// node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
var init_formatGwei = __esm(() => {
  init_unit();
});

// node_modules/viem/_esm/errors/stateOverride.js
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}\n`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state }) => {
    let val = `${pretty}    ${address}:\n`;
    if (state.nonce)
      val += `      nonce: ${state.nonce}\n`;
    if (state.balance)
      val += `      balance: ${state.balance}\n`;
    if (state.code)
      val += `      code: ${state.code}\n`;
    if (state.state) {
      val += "      state:\n";
      val += prettyStateMapping(state.state);
    }
    if (state.stateDiff) {
      val += "      stateDiff:\n";
      val += prettyStateMapping(state.stateDiff);
    }
    return val;
  }, "  State Override:\n").slice(0, -1);
}
var AccountStateConflictError, StateAssignmentConflictError;
var init_stateOverride = __esm(() => {
  init_base();
  AccountStateConflictError = class AccountStateConflictError extends BaseError {
    constructor({ address }) {
      super(`State for account "${address}" is set multiple times.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AccountStateConflictError"
      });
    }
  };
  StateAssignmentConflictError = class StateAssignmentConflictError extends BaseError {
    constructor() {
      super("state and stateDiff are set on the same account.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "StateAssignmentConflictError"
      });
    }
  };
});

// node_modules/viem/_esm/errors/transaction.js
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === undefined || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
var FeeConflictError, InvalidSerializableTransactionError, TransactionExecutionError;
var init_transaction = __esm(() => {
  init_formatEther();
  init_formatGwei();
  init_base();
  FeeConflictError = class FeeConflictError extends BaseError {
    constructor() {
      super([
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FeeConflictError"
      });
    }
  };
  InvalidSerializableTransactionError = class InvalidSerializableTransactionError extends BaseError {
    constructor({ transaction }) {
      super("Cannot infer a transaction type from provided transaction.", {
        metaMessages: [
          "Provided Transaction:",
          "{",
          prettyPrint(transaction),
          "}",
          "",
          "To infer the type, either provide:",
          "- a `type` to the Transaction, or",
          "- an EIP-1559 Transaction with `maxFeePerGas`, or",
          "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
          "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
          "- a Legacy Transaction with `gasPrice`"
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSerializableTransactionError"
      });
    }
  };
  TransactionExecutionError = class TransactionExecutionError extends BaseError {
    constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
      const prettyArgs = prettyPrint({
        chain: chain && `${chain?.name} (id: ${chain?.id})`,
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Request Arguments:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionExecutionError"
      });
      this.cause = cause;
    }
  };
});

// node_modules/viem/_esm/errors/contract.js
var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, RawContractError;
var init_contract = __esm(() => {
  init_solidity();
  init_decodeErrorResult();
  init_formatAbiItem2();
  init_formatAbiItemWithArgs();
  init_getAbiItem();
  init_formatEther();
  init_formatGwei();
  init_abi();
  init_base();
  init_stateOverride();
  init_transaction();
  init_utils();
  CallExecutionError = class CallExecutionError extends BaseError {
    constructor(cause, { account: account_, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
      const account = account_ ? parseAccount(account_) : undefined;
      let prettyArgs = prettyPrint({
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      if (stateOverride) {
        prettyArgs += `\n${prettyStateOverride(stateOverride)}`;
      }
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Raw Call Arguments:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CallExecutionError"
      });
      this.cause = cause;
    }
  };
  ContractFunctionExecutionError = class ContractFunctionExecutionError extends BaseError {
    constructor(cause, { abi, args, contractAddress, docsPath: docsPath3, functionName, sender }) {
      const abiItem = getAbiItem({ abi, args, name: functionName });
      const formattedArgs = abiItem ? formatAbiItemWithArgs({
        abiItem,
        args,
        includeFunctionName: false,
        includeName: false
      }) : undefined;
      const functionWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
      const prettyArgs = prettyPrint({
        address: contractAddress && getContractAddress(contractAddress),
        function: functionWithParams,
        args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
        sender
      });
      super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Contract Call:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "abi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "args", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "contractAddress", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "formattedArgs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "functionName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "sender", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ContractFunctionExecutionError"
      });
      this.abi = abi;
      this.args = args;
      this.cause = cause;
      this.contractAddress = contractAddress;
      this.functionName = functionName;
      this.sender = sender;
    }
  };
  ContractFunctionRevertedError = class ContractFunctionRevertedError extends BaseError {
    constructor({ abi, data, functionName, message }) {
      let cause;
      let decodedData = undefined;
      let metaMessages;
      let reason;
      if (data && data !== "0x") {
        try {
          decodedData = decodeErrorResult({ abi, data });
          const { abiItem, errorName, args: errorArgs } = decodedData;
          if (errorName === "Error") {
            reason = errorArgs[0];
          } else if (errorName === "Panic") {
            const [firstArg] = errorArgs;
            reason = panicReasons[firstArg];
          } else {
            const errorWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
            const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
              abiItem,
              args: errorArgs,
              includeFunctionName: false,
              includeName: false
            }) : undefined;
            metaMessages = [
              errorWithParams ? `Error: ${errorWithParams}` : "",
              formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
            ];
          }
        } catch (err) {
          cause = err;
        }
      } else if (message)
        reason = message;
      let signature;
      if (cause instanceof AbiErrorSignatureNotFoundError) {
        signature = cause.signature;
        metaMessages = [
          `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ];
      }
      super(reason && reason !== "execution reverted" || signature ? [
        `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
        reason || signature
      ].join("\n") : `The contract function "${functionName}" reverted.`, {
        cause,
        metaMessages
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ContractFunctionRevertedError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "reason", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = decodedData;
      this.reason = reason;
      this.signature = signature;
    }
  };
  ContractFunctionZeroDataError = class ContractFunctionZeroDataError extends BaseError {
    constructor({ functionName }) {
      super(`The contract function "${functionName}" returned no data ("0x").`, {
        metaMessages: [
          "This could be due to any of the following:",
          `  - The contract does not have the function "${functionName}",`,
          "  - The parameters passed to the contract function may be invalid, or",
          "  - The address is not a contract."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ContractFunctionZeroDataError"
      });
    }
  };
  RawContractError = class RawContractError extends BaseError {
    constructor({ data, message }) {
      super(message || "");
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RawContractError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
    }
  };
});

// node_modules/viem/_esm/errors/request.js
var HttpRequestError, RpcRequestError;
var init_request = __esm(() => {
  init_base();
  init_utils();
  HttpRequestError = class HttpRequestError extends BaseError {
    constructor({ body, details, headers, status, url }) {
      super("HTTP request failed.", {
        details,
        metaMessages: [
          status && `Status: ${status}`,
          `URL: ${getUrl(url)}`,
          body && `Request body: ${stringify(body)}`
        ].filter(Boolean)
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "HttpRequestError"
      });
      Object.defineProperty(this, "body", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "headers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "status", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "url", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.body = body;
      this.headers = headers;
      this.status = status;
      this.url = url;
    }
  };
  RpcRequestError = class RpcRequestError extends BaseError {
    constructor({ body, error, url }) {
      super("RPC Request failed.", {
        cause: error,
        details: error.message,
        metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RpcRequestError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.code = error.code;
    }
  };
});

// node_modules/viem/_esm/errors/rpc.js
var unknownErrorCode = -1, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError;
var init_rpc = __esm(() => {
  init_base();
  init_request();
  RpcError = class RpcError extends BaseError {
    constructor(cause, { code, docsPath: docsPath3, metaMessages, shortMessage }) {
      super(shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: metaMessages || cause?.metaMessages
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RpcError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.name = cause.name;
      this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
    }
  };
  ProviderRpcError = class ProviderRpcError extends RpcError {
    constructor(cause, options2) {
      super(cause, options2);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ProviderRpcError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = options2.data;
    }
  };
  ParseRpcError = class ParseRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ParseRpcError.code,
        shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ParseRpcError"
      });
    }
  };
  Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
  });
  InvalidRequestRpcError = class InvalidRequestRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidRequestRpcError.code,
        shortMessage: "JSON is not a valid request object."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidRequestRpcError"
      });
    }
  };
  Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
  });
  MethodNotFoundRpcError = class MethodNotFoundRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: MethodNotFoundRpcError.code,
        shortMessage: "The method does not exist / is not available."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "MethodNotFoundRpcError"
      });
    }
  };
  Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
  });
  InvalidParamsRpcError = class InvalidParamsRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidParamsRpcError.code,
        shortMessage: [
          "Invalid parameters were provided to the RPC method.",
          "Double check you have provided the correct parameters."
        ].join("\n")
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParamsRpcError"
      });
    }
  };
  Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
  });
  InternalRpcError = class InternalRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InternalRpcError.code,
        shortMessage: "An internal error was received."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InternalRpcError"
      });
    }
  };
  Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
  });
  InvalidInputRpcError = class InvalidInputRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidInputRpcError.code,
        shortMessage: [
          "Missing or invalid parameters.",
          "Double check you have provided the correct parameters."
        ].join("\n")
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidInputRpcError"
      });
    }
  };
  Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
  });
  ResourceNotFoundRpcError = class ResourceNotFoundRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceNotFoundRpcError.code,
        shortMessage: "Requested resource not found."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ResourceNotFoundRpcError"
      });
    }
  };
  Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
  });
  ResourceUnavailableRpcError = class ResourceUnavailableRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceUnavailableRpcError.code,
        shortMessage: "Requested resource not available."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ResourceUnavailableRpcError"
      });
    }
  };
  Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
  });
  TransactionRejectedRpcError = class TransactionRejectedRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: TransactionRejectedRpcError.code,
        shortMessage: "Transaction creation failed."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionRejectedRpcError"
      });
    }
  };
  Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
  });
  MethodNotSupportedRpcError = class MethodNotSupportedRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: MethodNotSupportedRpcError.code,
        shortMessage: "Method is not implemented."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "MethodNotSupportedRpcError"
      });
    }
  };
  Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
  });
  LimitExceededRpcError = class LimitExceededRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: LimitExceededRpcError.code,
        shortMessage: "Request exceeds defined limit."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "LimitExceededRpcError"
      });
    }
  };
  Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
  });
  JsonRpcVersionUnsupportedError = class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: JsonRpcVersionUnsupportedError.code,
        shortMessage: "Version of JSON-RPC protocol is not supported."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "JsonRpcVersionUnsupportedError"
      });
    }
  };
  Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
  });
  UserRejectedRequestError = class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UserRejectedRequestError.code,
        shortMessage: "User rejected the request."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UserRejectedRequestError"
      });
    }
  };
  Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
  });
  UnauthorizedProviderError = class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnauthorizedProviderError.code,
        shortMessage: "The requested method and/or account has not been authorized by the user."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnauthorizedProviderError"
      });
    }
  };
  Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
  });
  UnsupportedProviderMethodError = class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnsupportedProviderMethodError.code,
        shortMessage: "The Provider does not support the requested method."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnsupportedProviderMethodError"
      });
    }
  };
  Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
  });
  ProviderDisconnectedError = class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ProviderDisconnectedError.code,
        shortMessage: "The Provider is disconnected from all chains."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ProviderDisconnectedError"
      });
    }
  };
  Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
  });
  ChainDisconnectedError = class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ChainDisconnectedError.code,
        shortMessage: "The Provider is not connected to the requested chain."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainDisconnectedError"
      });
    }
  };
  Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
  });
  SwitchChainError = class SwitchChainError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: SwitchChainError.code,
        shortMessage: "An error occurred when attempting to switch chain."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SwitchChainError"
      });
    }
  };
  Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
  });
});

// node_modules/viem/_esm/errors/node.js
var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
var init_node = __esm(() => {
  init_formatGwei();
  init_base();
  ExecutionRevertedError = class ExecutionRevertedError extends BaseError {
    constructor({ cause, message } = {}) {
      const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
      super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ExecutionRevertedError"
      });
    }
  };
  Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
  });
  Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
  });
  FeeCapTooHighError = class FeeCapTooHighError extends BaseError {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FeeCapTooHigh"
      });
    }
  };
  Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  });
  FeeCapTooLowError = class FeeCapTooLowError extends BaseError {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FeeCapTooLow"
      });
    }
  };
  Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  });
  NonceTooHighError = class NonceTooHighError extends BaseError {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NonceTooHighError"
      });
    }
  };
  Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
  });
  NonceTooLowError = class NonceTooLowError extends BaseError {
    constructor({ cause, nonce } = {}) {
      super([
        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
      ].join("\n"), { cause });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NonceTooLowError"
      });
    }
  };
  Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
  });
  NonceMaxValueError = class NonceMaxValueError extends BaseError {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NonceMaxValueError"
      });
    }
  };
  Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
  });
  InsufficientFundsError = class InsufficientFundsError extends BaseError {
    constructor({ cause } = {}) {
      super([
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
      ].join("\n"), {
        cause,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InsufficientFundsError"
      });
    }
  };
  Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds/
  });
  IntrinsicGasTooHighError = class IntrinsicGasTooHighError extends BaseError {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "IntrinsicGasTooHighError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
  });
  IntrinsicGasTooLowError = class IntrinsicGasTooLowError extends BaseError {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "IntrinsicGasTooLowError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
  });
  TransactionTypeNotSupportedError = class TransactionTypeNotSupportedError extends BaseError {
    constructor({ cause }) {
      super("The transaction type is not supported for this chain.", {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionTypeNotSupportedError"
      });
    }
  };
  Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
  });
  TipAboveFeeCapError = class TipAboveFeeCapError extends BaseError {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
      super([
        `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
      ].join("\n"), {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TipAboveFeeCapError"
      });
    }
  };
  Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  });
  UnknownNodeError = class UnknownNodeError extends BaseError {
    constructor({ cause }) {
      super(`An error occurred while executing: ${cause?.shortMessage}`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownNodeError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/errors/getNodeError.js
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err instanceof BaseError ? err.walk((e) => e.code === ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof BaseError) {
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  }
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
var init_getNodeError = __esm(() => {
  init_base();
  init_node();
});

// node_modules/viem/_esm/utils/formatters/extract.js
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key of keys) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}

// node_modules/viem/_esm/utils/formatters/transactionRequest.js
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.accessList !== "undefined")
    rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== "undefined")
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined") {
    if (typeof request.blobs[0] !== "string")
      rpcRequest.blobs = request.blobs.map((x) => bytesToHex(x));
    else
      rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== "undefined")
    rpcRequest.data = request.data;
  if (typeof request.from !== "undefined")
    rpcRequest.from = request.from;
  if (typeof request.gas !== "undefined")
    rpcRequest.gas = numberToHex(request.gas);
  if (typeof request.gasPrice !== "undefined")
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request.nonce);
  if (typeof request.to !== "undefined")
    rpcRequest.to = request.to;
  if (typeof request.type !== "undefined")
    rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== "undefined")
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
var rpcTransactionType;
var init_transactionRequest = __esm(() => {
  init_toHex();
  rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2",
    eip4844: "0x3"
  };
});

// node_modules/viem/_esm/utils/transaction/assertRequest.js
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError;
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
var init_assertRequest = __esm(() => {
  init_address();
  init_node();
  init_transaction();
  init_isAddress();
});

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2;
var init__sha2 = __esm(() => {
  init__assert();
  init_utils2();
  SHA2 = class SHA2 extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };
});

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c, Maj = (a, b, c) => a & b ^ a & c ^ b & c, SHA256_K, IV, SHA256_W, SHA256, sha256;
var init_sha256 = __esm(() => {
  init__sha2();
  init_utils2();
  SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  SHA256 = class SHA256 extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256);
});

// node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
function decodeFunctionResult(parameters) {
  const { abi, args, functionName, data } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({ abi, args, name: functionName });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath4 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
  const values = decodeAbiParameters(abiItem.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return;
}
var docsPath4 = "/docs/contract/decodeFunctionResult";
var init_decodeFunctionResult = __esm(() => {
  init_abi();
  init_decodeAbiParameters();
  init_getAbiItem();
});

// node_modules/viem/_esm/constants/abis.js
var multicall3Abi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi;
var init_abis = __esm(() => {
  multicall3Abi = [
    {
      inputs: [
        {
          components: [
            {
              name: "target",
              type: "address"
            },
            {
              name: "allowFailure",
              type: "bool"
            },
            {
              name: "callData",
              type: "bytes"
            }
          ],
          name: "calls",
          type: "tuple[]"
        }
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            {
              name: "success",
              type: "bool"
            },
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "returnData",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ];
  universalResolverErrors = [
    {
      inputs: [],
      name: "ResolverNotFound",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverWildcardNotSupported",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverNotContract",
      type: "error"
    },
    {
      inputs: [
        {
          name: "returnData",
          type: "bytes"
        }
      ],
      name: "ResolverError",
      type: "error"
    },
    {
      inputs: [
        {
          components: [
            {
              name: "status",
              type: "uint16"
            },
            {
              name: "message",
              type: "string"
            }
          ],
          name: "errors",
          type: "tuple[]"
        }
      ],
      name: "HttpError",
      type: "error"
    }
  ];
  universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    },
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
        { name: "gateways", type: "string[]" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    }
  ];
  universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    },
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [
        { type: "bytes", name: "reverseName" },
        { type: "string[]", name: "gateways" }
      ],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    }
  ];
});

// node_modules/viem/_esm/constants/contract.js
var aggregate3Signature = "0x82ad56cb";

// node_modules/viem/_esm/errors/chain.js
var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError;
var init_chain = __esm(() => {
  init_base();
  ChainDoesNotSupportContract = class ChainDoesNotSupportContract extends BaseError {
    constructor({ blockNumber, chain, contract }) {
      super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
        metaMessages: [
          "This could be due to any of the following:",
          ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
          ] : [
            `- The chain does not have the contract "${contract.name}" configured.`
          ]
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainDoesNotSupportContract"
      });
    }
  };
  ChainMismatchError = class ChainMismatchError extends BaseError {
    constructor({ chain, currentChainId }) {
      super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
        metaMessages: [
          `Current Chain ID:  ${currentChainId}`,
          `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainMismatchError"
      });
    }
  };
  ChainNotFoundError = class ChainNotFoundError extends BaseError {
    constructor() {
      super([
        "No chain was provided to the request.",
        "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainNotFoundError"
      });
    }
  };
  ClientChainNotConfiguredError = class ClientChainNotConfiguredError extends BaseError {
    constructor() {
      super("No chain was provided to the Client.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ClientChainNotConfiguredError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/chain/getChainContractAddress.js
function getChainContractAddress({ blockNumber, chain, contract: name }) {
  const contract = chain?.contracts?.[name];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
var init_getChainContractAddress = __esm(() => {
  init_chain();
});

// node_modules/viem/_esm/utils/errors/getCallError.js
function getCallError(err, { docsPath: docsPath5, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath5,
    ...args
  });
}
var init_getCallError = __esm(() => {
  init_contract();
  init_node();
  init_getNodeError();
});

// node_modules/viem/_esm/utils/promise/createBatchScheduler.js
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush();
    const args = scheduler.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data) => {
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (let i = 0;i < scheduler.length; i++) {
        const { pendingPromise } = scheduler[i];
        pendingPromise.resolve?.([data[i], data]);
      }
    }).catch((err) => {
      for (let i = 0;i < scheduler.length; i++) {
        const { pendingPromise } = scheduler[i];
        pendingPromise.reject?.(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id) || [];
  const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve, reject) => {
        pendingPromise.resolve = resolve;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait);
      return promise;
    }
  };
}
var schedulerCache;
var init_createBatchScheduler = __esm(() => {
  schedulerCache = /* @__PURE__ */ new Map;
});

// node_modules/viem/_esm/errors/ccip.js
var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
var init_ccip = __esm(() => {
  init_base();
  init_utils();
  OffchainLookupError = class OffchainLookupError extends BaseError {
    constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
      super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
        cause,
        metaMessages: [
          ...cause.metaMessages || [],
          cause.metaMessages?.length ? "" : [],
          "Offchain Gateway Call:",
          urls && [
            "  Gateway URL(s):",
            ...urls.map((url) => `    ${getUrl(url)}`)
          ],
          `  Sender: ${sender}`,
          `  Data: ${data}`,
          `  Callback selector: ${callbackSelector}`,
          `  Extra data: ${extraData}`
        ].flat()
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OffchainLookupError"
      });
    }
  };
  OffchainLookupResponseMalformedError = class OffchainLookupResponseMalformedError extends BaseError {
    constructor({ result, url }) {
      super("Offchain gateway response is malformed. Response data must be a hex value.", {
        metaMessages: [
          `Gateway URL: ${getUrl(url)}`,
          `Response: ${stringify(result)}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OffchainLookupResponseMalformedError"
      });
    }
  };
  OffchainLookupSenderMismatchError = class OffchainLookupSenderMismatchError extends BaseError {
    constructor({ sender, to }) {
      super("Reverted sender address does not match target contract address (`to`).", {
        metaMessages: [
          `Contract address: ${to}`,
          `OffchainLookup sender address: ${sender}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OffchainLookupSenderMismatchError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/address/isAddressEqual.js
function isAddressEqual(a, b) {
  if (!isAddress(a, { strict: false }))
    throw new InvalidAddressError({ address: a });
  if (!isAddress(b, { strict: false }))
    throw new InvalidAddressError({ address: b });
  return a.toLowerCase() === b.toLowerCase();
}
var init_isAddressEqual = __esm(() => {
  init_address();
  init_isAddress();
});

// node_modules/viem/_esm/utils/ccip.js
var exports_ccip = {};
__export(exports_ccip, {
  offchainLookupSignature: () => offchainLookupSignature,
  offchainLookupAbiItem: () => offchainLookupAbiItem,
  offchainLookup: () => offchainLookup,
  ccipRequest: () => ccipRequest
});
async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
  const { args } = decodeErrorResult({
    data,
    abi: [offchainLookupAbiItem]
  });
  const [sender, urls, callData, callbackSelector, extraData] = args;
  const { ccipRead } = client;
  const ccipRequest_ = ccipRead && typeof ccipRead?.request === "function" ? ccipRead.request : ccipRequest;
  try {
    if (!isAddressEqual(to, sender))
      throw new OffchainLookupSenderMismatchError({ sender, to });
    const result = await ccipRequest_({ data: callData, sender, urls });
    const { data: data_ } = await call(client, {
      blockNumber,
      blockTag,
      data: concat([
        callbackSelector,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
      ]),
      to
    });
    return data_;
  } catch (err) {
    throw new OffchainLookupError({
      callbackSelector,
      cause: err,
      data,
      extraData,
      sender,
      urls
    });
  }
}
async function ccipRequest({ data, sender, urls }) {
  let error = new Error("An unknown error occurred.");
  for (let i = 0;i < urls.length; i++) {
    const url = urls[i];
    const method = url.includes("{data}") ? "GET" : "POST";
    const body = method === "POST" ? { data, sender } : undefined;
    try {
      const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
        body: JSON.stringify(body),
        method
      });
      let result;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        result = (await response.json()).data;
      } else {
        result = await response.text();
      }
      if (!response.ok) {
        error = new HttpRequestError({
          body,
          details: result?.error ? stringify(result.error) : response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
        continue;
      }
      if (!isHex(result)) {
        error = new OffchainLookupResponseMalformedError({
          result,
          url
        });
        continue;
      }
      return result;
    } catch (err) {
      error = new HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  throw error;
}
var offchainLookupSignature = "0x556f1830", offchainLookupAbiItem;
var init_ccip2 = __esm(() => {
  init_call();
  init_ccip();
  init_request();
  init_decodeErrorResult();
  init_encodeAbiParameters();
  init_isAddressEqual();
  offchainLookupAbiItem = {
    name: "OffchainLookup",
    type: "error",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "urls",
        type: "string[]"
      },
      {
        name: "callData",
        type: "bytes"
      },
      {
        name: "callbackFunction",
        type: "bytes4"
      },
      {
        name: "extraData",
        type: "bytes"
      }
    ]
  };
});

// node_modules/viem/_esm/actions/public/call.js
async function call(client, args) {
  const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = parseStateOverride(stateOverride);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {
      try {
        return await scheduleMulticall(client, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client.request({
      method: "eth_call",
      params: rpcStateOverride ? [
        request,
        block,
        rpcStateOverride
      ] : [request, block]
    });
    if (response === "0x")
      return { data: undefined };
    return { data: response };
  } catch (err) {
    const data2 = getRevertErrorData(err);
    const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), exports_ccip));
    if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)
      return { data: await offchainLookup2(client, { data: data2, to }) };
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data, to, ...request_ } = request;
  if (!data)
    return false;
  if (data.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client, args) {
  const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new ClientChainNotConfiguredError;
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client.uid}.${block}`,
    wait,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data2 }) => size3 + (data2.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data2 = await client.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data2 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: undefined };
  return { data: returnData };
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError))
    return;
  const error = err.walk();
  return typeof error?.data === "object" ? error.data?.data : error.data;
}
function parseStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0)
    return;
  return stateMapping.reduce((acc, { slot, value }) => {
    if (slot.length !== 66)
      throw new InvalidBytesLengthError({
        size: slot.length,
        targetSize: 66,
        type: "hex"
      });
    if (value.length !== 66)
      throw new InvalidBytesLengthError({
        size: value.length,
        targetSize: 66,
        type: "hex"
      });
    acc[slot] = value;
    return acc;
  }, {});
}
function parseAccountStateOverride(args) {
  const { balance, nonce, state, stateDiff, code } = args;
  const rpcAccountStateOverride = {};
  if (code !== undefined)
    rpcAccountStateOverride.code = code;
  if (balance !== undefined)
    rpcAccountStateOverride.balance = numberToHex(balance);
  if (nonce !== undefined)
    rpcAccountStateOverride.nonce = numberToHex(nonce);
  if (state !== undefined)
    rpcAccountStateOverride.state = parseStateMapping(state);
  if (stateDiff !== undefined) {
    if (rpcAccountStateOverride.state)
      throw new StateAssignmentConflictError;
    rpcAccountStateOverride.stateDiff = parseStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
function parseStateOverride(args) {
  if (!args)
    return;
  const rpcStateOverride = {};
  for (const { address, ...accountState } of args) {
    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address });
    if (rpcStateOverride[address])
      throw new AccountStateConflictError({ address });
    rpcStateOverride[address] = parseAccountStateOverride(accountState);
  }
  return rpcStateOverride;
}
var init_call = __esm(() => {
  init_abis();
  init_address();
  init_base();
  init_chain();
  init_contract();
  init_data();
  init_stateOverride();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_isAddress();
  init_getChainContractAddress();
  init_toHex();
  init_getCallError();
  init_transactionRequest();
  init_createBatchScheduler();
  init_assertRequest();
});

// node_modules/viem/_cjs/utils/chain/defineChain.js
var require_defineChain = __commonJS((exports) => {
  function defineChain(chain) {
    return {
      formatters: undefined,
      fees: undefined,
      serializers: undefined,
      ...chain
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineChain = undefined;
  exports.defineChain = defineChain;
});

// node_modules/viem/_cjs/chains/definitions/acala.js
var require_acala = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.acala = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.acala = (0, defineChain_js_1.defineChain)({
    id: 787,
    name: "Acala",
    network: "acala",
    nativeCurrency: {
      name: "Acala",
      symbol: "ACA",
      decimals: 18
    },
    rpcUrls: {
      public: {
        http: ["https://eth-rpc-acala.aca-api.network"],
        webSocket: ["wss://eth-rpc-acala.aca-api.network"]
      },
      default: {
        http: ["https://eth-rpc-acala.aca-api.network"],
        webSocket: ["wss://eth-rpc-acala.aca-api.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Acala Blockscout",
        url: "https://blockscout.acala.network",
        apiUrl: "https://blockscout.acala.network/api"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/op-stack/contracts.js
var require_contracts = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contracts = undefined;
  exports.contracts = {
    gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
    l1Block: { address: "0x4200000000000000000000000000000000000015" },
    l2CrossDomainMessenger: {
      address: "0x4200000000000000000000000000000000000007"
    },
    l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
    l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
    l2ToL1MessagePasser: {
      address: "0x4200000000000000000000000000000000000016"
    }
  };
});

// node_modules/viem/_cjs/errors/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "2.9.20";
});

// node_modules/viem/_cjs/errors/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getVersion = exports.getUrl = exports.getContractAddress = undefined;
  var version_js_1 = require_version();
  var getContractAddress2 = (address) => address;
  exports.getContractAddress = getContractAddress2;
  var getUrl2 = (url) => url;
  exports.getUrl = getUrl2;
  var getVersion2 = () => `viem@${version_js_1.version}`;
  exports.getVersion = getVersion2;
});

// node_modules/viem/_cjs/errors/base.js
var require_base = __commonJS((exports) => {
  function walk2(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err)
      return walk2(err.cause, fn);
    return fn ? null : err;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseError = undefined;
  var utils_js_1 = require_utils();

  class BaseError2 extends Error {
    constructor(shortMessage, args = {}) {
      super();
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ViemError"
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: (0, utils_js_1.getVersion)()
      });
      const details = args.cause instanceof BaseError2 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
      const docsPath5 = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
      this.message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath5 ? [
          `Docs: https://viem.sh${docsPath5}${args.docsSlug ? `#${args.docsSlug}` : ""}`
        ] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: ${this.version}`
      ].join("\n");
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath5;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
    walk(fn) {
      return walk2(this, fn);
    }
  }
  exports.BaseError = BaseError2;
});

// node_modules/viem/_cjs/errors/encoding.js
var require_encoding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SizeOverflowError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.IntegerOutOfRangeError = undefined;
  var base_js_1 = require_base();

  class IntegerOutOfRangeError2 extends base_js_1.BaseError {
    constructor({ max, min, signed, size: size2, value }) {
      super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "IntegerOutOfRangeError"
      });
    }
  }
  exports.IntegerOutOfRangeError = IntegerOutOfRangeError2;

  class InvalidBytesBooleanError2 extends base_js_1.BaseError {
    constructor(bytes2) {
      super(`Bytes value "${bytes2}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidBytesBooleanError"
      });
    }
  }
  exports.InvalidBytesBooleanError = InvalidBytesBooleanError2;

  class InvalidHexBooleanError2 extends base_js_1.BaseError {
    constructor(hex) {
      super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidHexBooleanError"
      });
    }
  }
  exports.InvalidHexBooleanError = InvalidHexBooleanError2;

  class InvalidHexValueError extends base_js_1.BaseError {
    constructor(value) {
      super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidHexValueError"
      });
    }
  }
  exports.InvalidHexValueError = InvalidHexValueError;

  class SizeOverflowError2 extends base_js_1.BaseError {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SizeOverflowError"
      });
    }
  }
  exports.SizeOverflowError = SizeOverflowError2;
});

// node_modules/viem/_cjs/utils/data/isHex.js
var require_isHex = __commonJS((exports) => {
  function isHex2(value, { strict = true } = {}) {
    if (!value)
      return false;
    if (typeof value !== "string")
      return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isHex = undefined;
  exports.isHex = isHex2;
});

// node_modules/viem/_cjs/utils/data/size.js
var require_size = __commonJS((exports) => {
  function size2(value) {
    if ((0, isHex_js_1.isHex)(value, { strict: false }))
      return Math.ceil((value.length - 2) / 2);
    return value.length;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.size = undefined;
  var isHex_js_1 = require_isHex();
  exports.size = size2;
});

// node_modules/viem/_cjs/utils/data/trim.js
var require_trim = __commonJS((exports) => {
  function trim2(hexOrBytes, { dir = "left" } = {}) {
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for (let i = 0;i < data.length - 1; i++) {
      if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
      if (data.length === 1 && dir === "right")
        data = `${data}0`;
      return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trim = undefined;
  exports.trim = trim2;
});

// node_modules/viem/_cjs/errors/data.js
var require_data = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidBytesLengthError = exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = undefined;
  var base_js_1 = require_base();

  class SliceOffsetOutOfBoundsError2 extends base_js_1.BaseError {
    constructor({ offset, position, size: size2 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SliceOffsetOutOfBoundsError"
      });
    }
  }
  exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError2;

  class SizeExceedsPaddingSizeError2 extends base_js_1.BaseError {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SizeExceedsPaddingSizeError"
      });
    }
  }
  exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError2;

  class InvalidBytesLengthError2 extends base_js_1.BaseError {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidBytesLengthError"
      });
    }
  }
  exports.InvalidBytesLengthError = InvalidBytesLengthError2;
});

// node_modules/viem/_cjs/utils/data/pad.js
var require_pad = __commonJS((exports) => {
  function pad2(hexOrBytes, { dir, size: size2 = 32 } = {}) {
    if (typeof hexOrBytes === "string")
      return padHex2(hexOrBytes, { dir, size: size2 });
    return padBytes2(hexOrBytes, { dir, size: size2 });
  }
  function padHex2(hex_, { dir, size: size2 = 32 } = {}) {
    if (size2 === null)
      return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size2 * 2)
      throw new data_js_1.SizeExceedsPaddingSizeError({
        size: Math.ceil(hex.length / 2),
        targetSize: size2,
        type: "hex"
      });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
  }
  function padBytes2(bytes2, { dir, size: size2 = 32 } = {}) {
    if (size2 === null)
      return bytes2;
    if (bytes2.length > size2)
      throw new data_js_1.SizeExceedsPaddingSizeError({
        size: bytes2.length,
        targetSize: size2,
        type: "bytes"
      });
    const paddedBytes = new Uint8Array(size2);
    for (let i = 0;i < size2; i++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i : size2 - i - 1] = bytes2[padEnd ? i : bytes2.length - i - 1];
    }
    return paddedBytes;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.padBytes = exports.padHex = exports.pad = undefined;
  var data_js_1 = require_data();
  exports.pad = pad2;
  exports.padHex = padHex2;
  exports.padBytes = padBytes2;
});

// node_modules/viem/_cjs/utils/encoding/toHex.js
var require_toHex = __commonJS((exports) => {
  function toHex2(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToHex2(value, opts);
    if (typeof value === "string") {
      return stringToHex2(value, opts);
    }
    if (typeof value === "boolean")
      return boolToHex2(value, opts);
    return bytesToHex2(value, opts);
  }
  function boolToHex2(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
      (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
      return (0, pad_js_1.pad)(hex, { size: opts.size });
    }
    return hex;
  }
  function bytesToHex2(value, opts = {}) {
    let string = "";
    for (let i = 0;i < value.length; i++) {
      string += hexes2[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === "number") {
      (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
      return (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
    }
    return hex;
  }
  function numberToHex2(value_, opts = {}) {
    const { signed, size: size2 } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size2) {
      if (signed)
        maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
    } else if (typeof value_ === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
      const suffix = typeof value_ === "bigint" ? "n" : "";
      throw new encoding_js_1.IntegerOutOfRangeError({
        max: maxValue ? `${maxValue}${suffix}` : undefined,
        min: `${minValue}${suffix}`,
        signed,
        size: size2,
        value: `${value_}${suffix}`
      });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
    if (size2)
      return (0, pad_js_1.pad)(hex, { size: size2 });
    return hex;
  }
  function stringToHex2(value_, opts = {}) {
    const value = encoder3.encode(value_);
    return bytesToHex2(value, opts);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toHex = undefined;
  var encoding_js_1 = require_encoding();
  var pad_js_1 = require_pad();
  var fromHex_js_1 = require_fromHex();
  var hexes2 = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  exports.toHex = toHex2;
  exports.boolToHex = boolToHex2;
  exports.bytesToHex = bytesToHex2;
  exports.numberToHex = numberToHex2;
  var encoder3 = new TextEncoder;
  exports.stringToHex = stringToHex2;
});

// node_modules/viem/_cjs/utils/encoding/toBytes.js
var require_toBytes = __commonJS((exports) => {
  function toBytes3(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToBytes2(value, opts);
    if (typeof value === "boolean")
      return boolToBytes2(value, opts);
    if ((0, isHex_js_1.isHex)(value))
      return hexToBytes2(value, opts);
    return stringToBytes2(value, opts);
  }
  function boolToBytes2(value, opts = {}) {
    const bytes2 = new Uint8Array(1);
    bytes2[0] = Number(value);
    if (typeof opts.size === "number") {
      (0, fromHex_js_1.assertSize)(bytes2, { size: opts.size });
      return (0, pad_js_1.pad)(bytes2, { size: opts.size });
    }
    return bytes2;
  }
  function charCodeToBase162(char) {
    if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)
      return char - charCodeMap2.zero;
    if (char >= charCodeMap2.A && char <= charCodeMap2.F)
      return char - (charCodeMap2.A - 10);
    if (char >= charCodeMap2.a && char <= charCodeMap2.f)
      return char - (charCodeMap2.a - 10);
    return;
  }
  function hexToBytes2(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
      hex = (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes2 = new Uint8Array(length);
    for (let index = 0, j = 0;index < length; index++) {
      const nibbleLeft = charCodeToBase162(hexString.charCodeAt(j++));
      const nibbleRight = charCodeToBase162(hexString.charCodeAt(j++));
      if (nibbleLeft === undefined || nibbleRight === undefined) {
        throw new base_js_1.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
      }
      bytes2[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes2;
  }
  function numberToBytes2(value, opts) {
    const hex = (0, toHex_js_1.numberToHex)(value, opts);
    return hexToBytes2(hex);
  }
  function stringToBytes2(value, opts = {}) {
    const bytes2 = encoder3.encode(value);
    if (typeof opts.size === "number") {
      (0, fromHex_js_1.assertSize)(bytes2, { size: opts.size });
      return (0, pad_js_1.pad)(bytes2, { dir: "right", size: opts.size });
    }
    return bytes2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = undefined;
  var base_js_1 = require_base();
  var isHex_js_1 = require_isHex();
  var pad_js_1 = require_pad();
  var fromHex_js_1 = require_fromHex();
  var toHex_js_1 = require_toHex();
  var encoder3 = new TextEncoder;
  exports.toBytes = toBytes3;
  exports.boolToBytes = boolToBytes2;
  var charCodeMap2 = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
  exports.hexToBytes = hexToBytes2;
  exports.numberToBytes = numberToBytes2;
  exports.stringToBytes = stringToBytes2;
});

// node_modules/viem/_cjs/utils/encoding/fromHex.js
var require_fromHex = __commonJS((exports) => {
  function assertSize2(hexOrBytes, { size: size2 }) {
    if ((0, size_js_1.size)(hexOrBytes) > size2)
      throw new encoding_js_1.SizeOverflowError({
        givenSize: (0, size_js_1.size)(hexOrBytes),
        maxSize: size2
      });
  }
  function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === "number")
      return hexToNumber2(hex, opts);
    if (to === "bigint")
      return hexToBigInt2(hex, opts);
    if (to === "string")
      return hexToString(hex, opts);
    if (to === "boolean")
      return hexToBool(hex, opts);
    return (0, toBytes_js_1.hexToBytes)(hex, opts);
  }
  function hexToBigInt2(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size)
      assertSize2(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed)
      return value;
    const size2 = (hex.length - 2) / 2;
    const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
    if (value <= max)
      return value;
    return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
  }
  function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize2(hex, { size: opts.size });
      hex = (0, trim_js_1.trim)(hex);
    }
    if ((0, trim_js_1.trim)(hex) === "0x00")
      return false;
    if ((0, trim_js_1.trim)(hex) === "0x01")
      return true;
    throw new encoding_js_1.InvalidHexBooleanError(hex);
  }
  function hexToNumber2(hex, opts = {}) {
    return Number(hexToBigInt2(hex, opts));
  }
  function hexToString(hex, opts = {}) {
    let bytes2 = (0, toBytes_js_1.hexToBytes)(hex);
    if (opts.size) {
      assertSize2(bytes2, { size: opts.size });
      bytes2 = (0, trim_js_1.trim)(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.assertSize = undefined;
  var encoding_js_1 = require_encoding();
  var size_js_1 = require_size();
  var trim_js_1 = require_trim();
  var toBytes_js_1 = require_toBytes();
  exports.assertSize = assertSize2;
  exports.fromHex = fromHex;
  exports.hexToBigInt = hexToBigInt2;
  exports.hexToBool = hexToBool;
  exports.hexToNumber = hexToNumber2;
  exports.hexToString = hexToString;
});

// node_modules/viem/_cjs/utils/formatters/formatter.js
var require_formatter = __commonJS((exports) => {
  function defineFormatter(type, format) {
    return ({ exclude, format: overrides }) => {
      return {
        exclude,
        format: (args) => {
          const formatted = format(args);
          if (exclude) {
            for (const key of exclude) {
              delete formatted[key];
            }
          }
          return {
            ...formatted,
            ...overrides(args)
          };
        },
        type
      };
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineFormatter = undefined;
  exports.defineFormatter = defineFormatter;
});

// node_modules/viem/_cjs/utils/formatters/transaction.js
var require_transaction = __commonJS((exports) => {
  function formatTransaction2(transaction) {
    const transaction_ = {
      ...transaction,
      blockHash: transaction.blockHash ? transaction.blockHash : null,
      blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
      chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : undefined,
      gas: transaction.gas ? BigInt(transaction.gas) : undefined,
      gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
      maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,
      maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
      nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : undefined,
      to: transaction.to ? transaction.to : null,
      transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
      type: transaction.type ? exports.transactionType[transaction.type] : undefined,
      typeHex: transaction.type ? transaction.type : undefined,
      value: transaction.value ? BigInt(transaction.value) : undefined,
      v: transaction.v ? BigInt(transaction.v) : undefined
    };
    transaction_.yParity = (() => {
      if (transaction.yParity)
        return Number(transaction.yParity);
      if (typeof transaction_.v === "bigint") {
        if (transaction_.v === 0n || transaction_.v === 27n)
          return 0;
        if (transaction_.v === 1n || transaction_.v === 28n)
          return 1;
        if (transaction_.v >= 35n)
          return transaction_.v % 2n === 0n ? 1 : 0;
      }
      return;
    })();
    if (transaction_.type === "legacy") {
      delete transaction_.accessList;
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
      delete transaction_.yParity;
    }
    if (transaction_.type === "eip2930") {
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
    }
    if (transaction_.type === "eip1559") {
      delete transaction_.maxFeePerBlobGas;
    }
    return transaction_;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineTransaction = exports.formatTransaction = exports.transactionType = undefined;
  var fromHex_js_1 = require_fromHex();
  var formatter_js_1 = require_formatter();
  exports.transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559",
    "0x3": "eip4844"
  };
  exports.formatTransaction = formatTransaction2;
  exports.defineTransaction = (0, formatter_js_1.defineFormatter)("transaction", formatTransaction2);
});

// node_modules/viem/_cjs/utils/formatters/block.js
var require_block = __commonJS((exports) => {
  function formatBlock2(block) {
    const transactions = block.transactions?.map((transaction) => {
      if (typeof transaction === "string")
        return transaction;
      return (0, transaction_js_1.formatTransaction)(transaction);
    });
    return {
      ...block,
      baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
      blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
      difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
      excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,
      gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
      gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
      hash: block.hash ? block.hash : null,
      logsBloom: block.logsBloom ? block.logsBloom : null,
      nonce: block.nonce ? block.nonce : null,
      number: block.number ? BigInt(block.number) : null,
      size: block.size ? BigInt(block.size) : undefined,
      timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
      transactions,
      totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineBlock = exports.formatBlock = undefined;
  var formatter_js_1 = require_formatter();
  var transaction_js_1 = require_transaction();
  exports.formatBlock = formatBlock2;
  exports.defineBlock = (0, formatter_js_1.defineFormatter)("block", formatBlock2);
});

// node_modules/viem/_cjs/utils/formatters/log.js
var require_log = __commonJS((exports) => {
  function formatLog2(log, { args, eventName } = {}) {
    return {
      ...log,
      blockHash: log.blockHash ? log.blockHash : null,
      blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
      logIndex: log.logIndex ? Number(log.logIndex) : null,
      transactionHash: log.transactionHash ? log.transactionHash : null,
      transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
      ...eventName ? { args, eventName } : {}
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLog = undefined;
  exports.formatLog = formatLog2;
});

// node_modules/viem/_cjs/utils/formatters/transactionReceipt.js
var require_transactionReceipt = __commonJS((exports) => {
  function formatTransactionReceipt(transactionReceipt) {
    const receipt = {
      ...transactionReceipt,
      blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
      contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
      cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
      effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
      gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
      logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log)) : null,
      to: transactionReceipt.to ? transactionReceipt.to : null,
      transactionIndex: transactionReceipt.transactionIndex ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex) : null,
      status: transactionReceipt.status ? exports.receiptStatuses[transactionReceipt.status] : null,
      type: transactionReceipt.type ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type : null
    };
    if (transactionReceipt.blobGasPrice)
      receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
    if (transactionReceipt.blobGasUsed)
      receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
    return receipt;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineTransactionReceipt = exports.formatTransactionReceipt = exports.receiptStatuses = undefined;
  var fromHex_js_1 = require_fromHex();
  var formatter_js_1 = require_formatter();
  var log_js_1 = require_log();
  var transaction_js_1 = require_transaction();
  exports.receiptStatuses = {
    "0x0": "reverted",
    "0x1": "success"
  };
  exports.formatTransactionReceipt = formatTransactionReceipt;
  exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)("transactionReceipt", formatTransactionReceipt);
});

// node_modules/viem/_cjs/op-stack/formatters.js
var require_formatters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatters = undefined;
  var fromHex_js_1 = require_fromHex();
  var block_js_1 = require_block();
  var transaction_js_1 = require_transaction();
  var transactionReceipt_js_1 = require_transactionReceipt();
  exports.formatters = {
    block: (0, block_js_1.defineBlock)({
      format(args) {
        const transactions = args.transactions?.map((transaction) => {
          if (typeof transaction === "string")
            return transaction;
          const formatted = (0, transaction_js_1.formatTransaction)(transaction);
          if (formatted.typeHex === "0x7e") {
            formatted.isSystemTx = transaction.isSystemTx;
            formatted.mint = transaction.mint ? (0, fromHex_js_1.hexToBigInt)(transaction.mint) : undefined;
            formatted.sourceHash = transaction.sourceHash;
            formatted.type = "deposit";
          }
          return formatted;
        });
        return {
          transactions,
          stateRoot: args.stateRoot
        };
      }
    }),
    transaction: (0, transaction_js_1.defineTransaction)({
      format(args) {
        const transaction = {};
        if (args.type === "0x7e") {
          transaction.isSystemTx = args.isSystemTx;
          transaction.mint = args.mint ? (0, fromHex_js_1.hexToBigInt)(args.mint) : undefined;
          transaction.sourceHash = args.sourceHash;
          transaction.type = "deposit";
        }
        return transaction;
      }
    }),
    transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
      format(args) {
        return {
          l1GasPrice: args.l1GasPrice ? (0, fromHex_js_1.hexToBigInt)(args.l1GasPrice) : null,
          l1GasUsed: args.l1GasUsed ? (0, fromHex_js_1.hexToBigInt)(args.l1GasUsed) : null,
          l1Fee: args.l1Fee ? (0, fromHex_js_1.hexToBigInt)(args.l1Fee) : null,
          l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
        };
      }
    })
  };
});

// node_modules/viem/_cjs/errors/address.js
var require_address = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidAddressError = undefined;
  var base_js_1 = require_base();

  class InvalidAddressError2 extends base_js_1.BaseError {
    constructor({ address }) {
      super(`Address "${address}" is invalid.`, {
        metaMessages: [
          "- Address must be a hex value of 20 bytes (40 hex characters).",
          "- Address must match its checksum counterpart."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAddressError"
      });
    }
  }
  exports.InvalidAddressError = InvalidAddressError2;
});

// node_modules/viem/_cjs/utils/lru.js
var require_lru = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LruMap = undefined;

  class LruMap2 extends Map {
    constructor(size2) {
      super();
      Object.defineProperty(this, "maxSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.maxSize = size2;
    }
    set(key, value) {
      super.set(key, value);
      if (this.maxSize && this.size > this.maxSize)
        this.delete(this.keys().next().value);
      return this;
    }
  }
  exports.LruMap = LruMap2;
});

// node_modules/@noble/hashes/_assert.js
var require__assert = __commonJS((exports) => {
  function number2(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bool(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  }
  function bytes2(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash2(hash3) {
    if (typeof hash3 !== "function" || typeof hash3.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number2(hash3.outputLen);
    number2(hash3.blockLen);
  }
  function exists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output2(out, instance) {
    bytes2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = undefined;
  exports.number = number2;
  exports.bool = bool;
  exports.bytes = bytes2;
  exports.hash = hash2;
  exports.exists = exists2;
  exports.output = output2;
  var assert = { number: number2, bool, bytes: bytes2, hash: hash2, exists: exists2, output: output2 };
  exports.default = assert;
});

// node_modules/@noble/hashes/_u64.js
var require__u64 = __commonJS((exports) => {
  function fromBig2(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
    return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
  }
  function split2(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0;i < lst.length; i++) {
      const { h, l } = fromBig2(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = undefined;
  var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n2 = /* @__PURE__ */ BigInt(32);
  exports.fromBig = fromBig2;
  exports.split = split2;
  var toBig = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
  exports.toBig = toBig;
  var shrSH = (h, _l, s) => h >>> s;
  exports.shrSH = shrSH;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.shrSL = shrSL;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  exports.rotrSH = rotrSH;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.rotrSL = rotrSL;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  exports.rotrBH = rotrBH;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  exports.rotrBL = rotrBL;
  var rotr32H = (_h, l) => l;
  exports.rotr32H = rotr32H;
  var rotr32L = (h, _l) => h;
  exports.rotr32L = rotr32L;
  var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
  exports.rotlSH = rotlSH2;
  var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
  exports.rotlSL = rotlSL2;
  var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
  exports.rotlBH = rotlBH2;
  var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
  exports.rotlBL = rotlBL2;
  exports.add = add;
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L;
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L;
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L;
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H;
  var u64 = {
    fromBig: fromBig2,
    split: split2,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH: rotlSH2,
    rotlSL: rotlSL2,
    rotlBH: rotlBH2,
    rotlBL: rotlBL2,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64;
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = undefined;
  var nc = __require("node:crypto");
  exports.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;
});

// node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS((exports) => {
  function bytesToHex2(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes2.length; i++) {
      hex += hexes2[bytes2[i]];
    }
    return hex;
  }
  function hexToBytes2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0;i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  function utf8ToBytes2(str2) {
    if (typeof str2 !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
    return new Uint8Array(new TextEncoder().encode(str2));
  }
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    if (!u8a2(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes2(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad2 = 0;
    arrays.forEach((a) => {
      if (!u8a2(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad2);
      pad2 += a.length;
    });
    return r;
  }
  function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr2.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function wrapConstructor2(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function wrapXOFConstructorWithOpts2(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = undefined;
  var crypto_1 = require_cryptoNode();
  var u8a2 = (a) => a instanceof Uint8Array;
  var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u322;
  var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView2;
  var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
  exports.rotr = rotr2;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!exports.isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  exports.bytesToHex = bytesToHex2;
  exports.hexToBytes = hexToBytes2;
  var nextTick = async () => {
  };
  exports.nextTick = nextTick;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes2;
  exports.toBytes = toBytes3;
  exports.concatBytes = concatBytes2;

  class Hash2 {
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash2;
  var toStr2 = {}.toString;
  exports.checkOpts = checkOpts;
  exports.wrapConstructor = wrapConstructor2;
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts2;
  exports.randomBytes = randomBytes;
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS((exports) => {
  function keccakP2(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds;round < 24; round++) {
      for (let x = 0;x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0;x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH2(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0;y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0;t < 24; t++) {
        const shift = SHA3_ROTL2[t];
        const Th = rotlH2(curH, curL, shift);
        const Tl = rotlL2(curH, curL, shift);
        const PI = SHA3_PI2[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0;y < 50; y += 10) {
        for (let x = 0;x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0;x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H2[round];
      s[1] ^= SHA3_IOTA_L2[round];
    }
    B.fill(0);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = undefined;
  var _assert_js_1 = require__assert();
  var _u64_js_1 = require__u64();
  var utils_js_1 = require_utils2();
  var [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
  var _0n2 = /* @__PURE__ */ BigInt(0);
  var _1n2 = /* @__PURE__ */ BigInt(1);
  var _2n2 = /* @__PURE__ */ BigInt(2);
  var _7n2 = /* @__PURE__ */ BigInt(7);
  var _256n2 = /* @__PURE__ */ BigInt(256);
  var _0x71n2 = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n2, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI2.push(2 * (5 * y + x));
    SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n2;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n2 ^ (R >> _7n2) * _0x71n2) % _256n2;
      if (R & _2n2)
        t ^= _1n2 << (_1n2 << /* @__PURE__ */ BigInt(j)) - _1n2;
    }
    _SHA3_IOTA2.push(t);
  }
  var [SHA3_IOTA_H2, SHA3_IOTA_L2] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA2, true);
  var rotlH2 = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
  var rotlL2 = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
  exports.keccakP = keccakP2;

  class Keccak2 extends utils_js_1.Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_1.number)(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
      keccakP2(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      (0, _assert_js_1.exists)(this);
      const { blockLen, state } = this;
      data = (0, utils_js_1.toBytes)(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      (0, _assert_js_1.exists)(this, false);
      (0, _assert_js_1.bytes)(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      (0, _assert_js_1.number)(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      (0, _assert_js_1.output)(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }
  exports.Keccak = Keccak2;
  var gen2 = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak2(blockLen, suffix, outputLen));
  exports.sha3_224 = gen2(6, 144, 224 / 8);
  exports.sha3_256 = gen2(6, 136, 256 / 8);
  exports.sha3_384 = gen2(6, 104, 384 / 8);
  exports.sha3_512 = gen2(6, 72, 512 / 8);
  exports.keccak_224 = gen2(1, 144, 224 / 8);
  exports.keccak_256 = gen2(1, 136, 256 / 8);
  exports.keccak_384 = gen2(1, 104, 384 / 8);
  exports.keccak_512 = gen2(1, 72, 512 / 8);
  var genShake2 = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  exports.shake128 = genShake2(31, 168, 128 / 8);
  exports.shake256 = genShake2(31, 136, 256 / 8);
});

// node_modules/viem/_cjs/utils/hash/keccak256.js
var require_keccak256 = __commonJS((exports) => {
  function keccak2562(value, to_) {
    const to = to_ || "hex";
    const bytes2 = (0, sha3_1.keccak_256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === "bytes")
      return bytes2;
    return (0, toHex_js_1.toHex)(bytes2);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.keccak256 = undefined;
  var sha3_1 = require_sha3();
  var isHex_js_1 = require_isHex();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.keccak256 = keccak2562;
});

// node_modules/viem/_cjs/utils/address/getAddress.js
var require_getAddress = __commonJS((exports) => {
  function checksumAddress2(address_, chainId) {
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash2 = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), "bytes");
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
    for (let i = 0;i < 40; i += 2) {
      if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
        address[i] = address[i].toUpperCase();
      }
      if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
        address[i + 1] = address[i + 1].toUpperCase();
      }
    }
    return `0x${address.join("")}`;
  }
  function getAddress(address, chainId) {
    if (!(0, isAddress_js_1.isAddress)(address, { strict: false }))
      throw new address_js_1.InvalidAddressError({ address });
    return checksumAddress2(address, chainId);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAddress = exports.checksumAddress = undefined;
  var address_js_1 = require_address();
  var toBytes_js_1 = require_toBytes();
  var keccak256_js_1 = require_keccak256();
  var isAddress_js_1 = require_isAddress();
  exports.checksumAddress = checksumAddress2;
  exports.getAddress = getAddress;
});

// node_modules/viem/_cjs/utils/address/isAddress.js
var require_isAddress = __commonJS((exports) => {
  function isAddress2(address, options2) {
    const { strict = true } = options2 ?? {};
    if (exports.isAddressCache.has(address))
      return exports.isAddressCache.get(address);
    const result = (() => {
      if (!addressRegex2.test(address))
        return false;
      if (address.toLowerCase() === address)
        return true;
      if (strict)
        return (0, getAddress_js_1.checksumAddress)(address) === address;
      return true;
    })();
    exports.isAddressCache.set(address, result);
    return result;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAddress = exports.isAddressCache = undefined;
  var lru_js_1 = require_lru();
  var getAddress_js_1 = require_getAddress();
  var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
  exports.isAddressCache = new lru_js_1.LruMap(8192);
  exports.isAddress = isAddress2;
});

// node_modules/viem/_cjs/utils/data/concat.js
var require_concat = __commonJS((exports) => {
  function concat2(values) {
    if (typeof values[0] === "string")
      return concatHex2(values);
    return concatBytes2(values);
  }
  function concatBytes2(values) {
    let length = 0;
    for (const arr of values) {
      length += arr.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
  function concatHex2(values) {
    return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatHex = exports.concatBytes = exports.concat = undefined;
  exports.concat = concat2;
  exports.concatBytes = concatBytes2;
  exports.concatHex = concatHex2;
});

// node_modules/abitype/dist/cjs/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "1.0.0";
});

// node_modules/abitype/dist/cjs/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseError = undefined;
  var version_js_1 = require_version2();

  class BaseError2 extends Error {
    constructor(shortMessage, args = {}) {
      const details = args.cause instanceof BaseError2 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
      const docsPath5 = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath5 ? [`Docs: https://abitype.dev${docsPath5}`] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: abitype@${version_js_1.version}`
      ].join("\n");
      super(message);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiTypeError"
      });
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath5;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
  }
  exports.BaseError = BaseError2;
});

// node_modules/abitype/dist/cjs/narrow.js
var require_narrow = __commonJS((exports) => {
  function narrow(value) {
    return value;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.narrow = undefined;
  exports.narrow = narrow;
});

// node_modules/abitype/dist/cjs/regex.js
var require_regex = __commonJS((exports) => {
  function execTyped2(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTupleRegex = exports.integerRegex = exports.bytesRegex = exports.execTyped = undefined;
  exports.execTyped = execTyped2;
  exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  exports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  exports.isTupleRegex = /^\(.+?\).*?$/;
});

// node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js
var require_formatAbiParameter = __commonJS((exports) => {
  function formatAbiParameter2(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex2.test(abiParameter.type) && "components" in abiParameter) {
      type = "(";
      const length = abiParameter.components.length;
      for (let i = 0;i < length; i++) {
        const component = abiParameter.components[i];
        type += formatAbiParameter2(component);
        if (i < length - 1)
          type += ", ";
      }
      const result = (0, regex_js_1.execTyped)(tupleRegex2, abiParameter.type);
      type += `)${result?.array ?? ""}`;
      return formatAbiParameter2({
        ...abiParameter,
        type
      });
    }
    if ("indexed" in abiParameter && abiParameter.indexed)
      type = `${type} indexed`;
    if (abiParameter.name)
      return `${type} ${abiParameter.name}`;
    return type;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatAbiParameter = undefined;
  var regex_js_1 = require_regex();
  var tupleRegex2 = /^tuple(?<array>(\[(\d*)\])*)$/;
  exports.formatAbiParameter = formatAbiParameter2;
});

// node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js
var require_formatAbiParameters = __commonJS((exports) => {
  function formatAbiParameters2(abiParameters) {
    let params = "";
    const length = abiParameters.length;
    for (let i = 0;i < length; i++) {
      const abiParameter = abiParameters[i];
      params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
      if (i !== length - 1)
        params += ", ";
    }
    return params;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatAbiParameters = undefined;
  var formatAbiParameter_js_1 = require_formatAbiParameter();
  exports.formatAbiParameters = formatAbiParameters2;
});

// node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js
var require_formatAbiItem = __commonJS((exports) => {
  function formatAbiItem3(abiItem) {
    if (abiItem.type === "function")
      return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})` : ""}`;
    else if (abiItem.type === "event")
      return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
    else if (abiItem.type === "error")
      return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
    else if (abiItem.type === "constructor")
      return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
    else if (abiItem.type === "fallback")
      return "fallback()";
    return "receive() external payable";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatAbiItem = undefined;
  var formatAbiParameters_js_1 = require_formatAbiParameters();
  exports.formatAbiItem = formatAbiItem3;
});

// node_modules/abitype/dist/cjs/human-readable/formatAbi.js
var require_formatAbi = __commonJS((exports) => {
  function formatAbi(abi) {
    const signatures = [];
    const length = abi.length;
    for (let i = 0;i < length; i++) {
      const abiItem = abi[i];
      const signature = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      signatures.push(signature);
    }
    return signatures;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatAbi = undefined;
  var formatAbiItem_js_1 = require_formatAbiItem();
  exports.formatAbi = formatAbi;
});

// node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js
var require_signatures = __commonJS((exports) => {
  function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
  }
  function execErrorSignature(signature) {
    return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
  }
  function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
  }
  function execEventSignature(signature) {
    return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
  }
  function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
  }
  function execFunctionSignature(signature) {
    return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
  }
  function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
  }
  function execStructSignature(signature) {
    return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
  }
  function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
  }
  function execConstructorSignature(signature) {
    return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
  }
  function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
  }
  function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.functionModifiers = exports.eventModifiers = exports.modifiers = exports.isReceiveSignature = exports.isFallbackSignature = exports.execConstructorSignature = exports.isConstructorSignature = exports.execStructSignature = exports.isStructSignature = exports.execFunctionSignature = exports.isFunctionSignature = exports.execEventSignature = exports.isEventSignature = exports.execErrorSignature = exports.isErrorSignature = undefined;
  var regex_js_1 = require_regex();
  var errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
  exports.isErrorSignature = isErrorSignature;
  exports.execErrorSignature = execErrorSignature;
  var eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
  exports.isEventSignature = isEventSignature;
  exports.execEventSignature = execEventSignature;
  var functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
  exports.isFunctionSignature = isFunctionSignature;
  exports.execFunctionSignature = execFunctionSignature;
  var structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
  exports.isStructSignature = isStructSignature;
  exports.execStructSignature = execStructSignature;
  var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
  exports.isConstructorSignature = isConstructorSignature;
  exports.execConstructorSignature = execConstructorSignature;
  var fallbackSignatureRegex = /^fallback\(\)$/;
  exports.isFallbackSignature = isFallbackSignature;
  var receiveSignatureRegex = /^receive\(\) external payable$/;
  exports.isReceiveSignature = isReceiveSignature;
  exports.modifiers = new Set([
    "memory",
    "indexed",
    "storage",
    "calldata"
  ]);
  exports.eventModifiers = new Set(["indexed"]);
  exports.functionModifiers = new Set([
    "calldata",
    "memory",
    "storage"
  ]);
});

// node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js
var require_abiItem = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnknownSolidityTypeError = exports.UnknownTypeError = exports.InvalidAbiItemError = undefined;
  var errors_js_1 = require_errors();

  class InvalidAbiItemError extends errors_js_1.BaseError {
    constructor({ signature }) {
      super("Failed to parse ABI item.", {
        details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
        docsPath: "/api/human#parseabiitem-1"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiItemError"
      });
    }
  }
  exports.InvalidAbiItemError = InvalidAbiItemError;

  class UnknownTypeError extends errors_js_1.BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [
          `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownTypeError"
      });
    }
  }
  exports.UnknownTypeError = UnknownTypeError;

  class UnknownSolidityTypeError extends errors_js_1.BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [`Type "${type}" is not a valid ABI type.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSolidityTypeError"
      });
    }
  }
  exports.UnknownSolidityTypeError = UnknownSolidityTypeError;
});

// node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js
var require_abiParameter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = undefined;
  var errors_js_1 = require_errors();

  class InvalidAbiParameterError extends errors_js_1.BaseError {
    constructor({ param }) {
      super("Failed to parse ABI parameter.", {
        details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
        docsPath: "/api/human#parseabiparameter-1"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiParameterError"
      });
    }
  }
  exports.InvalidAbiParameterError = InvalidAbiParameterError;

  class InvalidAbiParametersError extends errors_js_1.BaseError {
    constructor({ params }) {
      super("Failed to parse ABI parameters.", {
        details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
        docsPath: "/api/human#parseabiparameters-1"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiParametersError"
      });
    }
  }
  exports.InvalidAbiParametersError = InvalidAbiParametersError;

  class InvalidParameterError extends errors_js_1.BaseError {
    constructor({ param }) {
      super("Invalid ABI parameter.", {
        details: param
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParameterError"
      });
    }
  }
  exports.InvalidParameterError = InvalidParameterError;

  class SolidityProtectedKeywordError extends errors_js_1.BaseError {
    constructor({ param, name }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SolidityProtectedKeywordError"
      });
    }
  }
  exports.SolidityProtectedKeywordError = SolidityProtectedKeywordError;

  class InvalidModifierError extends errors_js_1.BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidModifierError"
      });
    }
  }
  exports.InvalidModifierError = InvalidModifierError;

  class InvalidFunctionModifierError extends errors_js_1.BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
          `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidFunctionModifierError"
      });
    }
  }
  exports.InvalidFunctionModifierError = InvalidFunctionModifierError;

  class InvalidAbiTypeParameterError extends errors_js_1.BaseError {
    constructor({ abiParameter }) {
      super("Invalid ABI parameter.", {
        details: JSON.stringify(abiParameter, null, 2),
        metaMessages: ["ABI parameter type is invalid."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiTypeParameterError"
      });
    }
  }
  exports.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
});

// node_modules/abitype/dist/cjs/human-readable/errors/signature.js
var require_signature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidStructSignatureError = exports.UnknownSignatureError = exports.InvalidSignatureError = undefined;
  var errors_js_1 = require_errors();

  class InvalidSignatureError extends errors_js_1.BaseError {
    constructor({ signature, type }) {
      super(`Invalid ${type} signature.`, {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSignatureError"
      });
    }
  }
  exports.InvalidSignatureError = InvalidSignatureError;

  class UnknownSignatureError extends errors_js_1.BaseError {
    constructor({ signature }) {
      super("Unknown signature.", {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSignatureError"
      });
    }
  }
  exports.UnknownSignatureError = UnknownSignatureError;

  class InvalidStructSignatureError extends errors_js_1.BaseError {
    constructor({ signature }) {
      super("Invalid struct signature.", {
        details: signature,
        metaMessages: ["No properties exist."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidStructSignatureError"
      });
    }
  }
  exports.InvalidStructSignatureError = InvalidStructSignatureError;
});

// node_modules/abitype/dist/cjs/human-readable/errors/struct.js
var require_struct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CircularReferenceError = undefined;
  var errors_js_1 = require_errors();

  class CircularReferenceError extends errors_js_1.BaseError {
    constructor({ type }) {
      super("Circular reference detected.", {
        metaMessages: [`Struct "${type}" is a circular reference.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CircularReferenceError"
      });
    }
  }
  exports.CircularReferenceError = CircularReferenceError;
});

// node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js
var require_splitParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidParenthesisError = undefined;
  var errors_js_1 = require_errors();

  class InvalidParenthesisError extends errors_js_1.BaseError {
    constructor({ current, depth }) {
      super("Unbalanced parentheses.", {
        metaMessages: [
          `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
        ],
        details: `Depth "${depth}"`
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParenthesisError"
      });
    }
  }
  exports.InvalidParenthesisError = InvalidParenthesisError;
});

// node_modules/abitype/dist/cjs/human-readable/runtime/cache.js
var require_cache = __commonJS((exports) => {
  function getParameterCacheKey(param, type) {
    if (type)
      return `${type}:${param}`;
    return param;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parameterCache = exports.getParameterCacheKey = undefined;
  exports.getParameterCacheKey = getParameterCacheKey;
  exports.parameterCache = new Map([
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: true }
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: true }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ]
  ]);
});

// node_modules/abitype/dist/cjs/human-readable/runtime/utils.js
var require_utils3 = __commonJS((exports) => {
  function parseSignature(signature, structs = {}) {
    if ((0, signatures_js_1.isFunctionSignature)(signature)) {
      const match = (0, signatures_js_1.execFunctionSignature)(signature);
      if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: "function" });
      const inputParams = splitParameters(match.parameters);
      const inputs = [];
      const inputLength = inputParams.length;
      for (let i = 0;i < inputLength; i++) {
        inputs.push(parseAbiParameter(inputParams[i], {
          modifiers: signatures_js_1.functionModifiers,
          structs,
          type: "function"
        }));
      }
      const outputs = [];
      if (match.returns) {
        const outputParams = splitParameters(match.returns);
        const outputLength = outputParams.length;
        for (let i = 0;i < outputLength; i++) {
          outputs.push(parseAbiParameter(outputParams[i], {
            modifiers: signatures_js_1.functionModifiers,
            structs,
            type: "function"
          }));
        }
      }
      return {
        name: match.name,
        type: "function",
        stateMutability: match.stateMutability ?? "nonpayable",
        inputs,
        outputs
      };
    }
    if ((0, signatures_js_1.isEventSignature)(signature)) {
      const match = (0, signatures_js_1.execEventSignature)(signature);
      if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: "event" });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], {
          modifiers: signatures_js_1.eventModifiers,
          structs,
          type: "event"
        }));
      }
      return { name: match.name, type: "event", inputs: abiParameters };
    }
    if ((0, signatures_js_1.isErrorSignature)(signature)) {
      const match = (0, signatures_js_1.execErrorSignature)(signature);
      if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: "error" });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
      }
      return { name: match.name, type: "error", inputs: abiParameters };
    }
    if ((0, signatures_js_1.isConstructorSignature)(signature)) {
      const match = (0, signatures_js_1.execConstructorSignature)(signature);
      if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: "constructor" });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
      }
      return {
        type: "constructor",
        stateMutability: match.stateMutability ?? "nonpayable",
        inputs: abiParameters
      };
    }
    if ((0, signatures_js_1.isFallbackSignature)(signature))
      return { type: "fallback" };
    if ((0, signatures_js_1.isReceiveSignature)(signature))
      return {
        type: "receive",
        stateMutability: "payable"
      };
    throw new signature_js_1.UnknownSignatureError({ signature });
  }
  function parseAbiParameter(param, options2) {
    const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options2?.type);
    if (cache_js_1.parameterCache.has(parameterCacheKey))
      return cache_js_1.parameterCache.get(parameterCacheKey);
    const isTuple = regex_js_1.isTupleRegex.test(param);
    const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
      throw new abiParameter_js_1.InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
      throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === "indexed" ? { indexed: true } : {};
    const structs = options2?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
      type = "tuple";
      const params = splitParameters(match.type);
      const components_ = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        components_.push(parseAbiParameter(params[i], { structs }));
      }
      components = { components: components_ };
    } else if (match.type in structs) {
      type = "tuple";
      components = { components: structs[match.type] };
    } else if (dynamicIntegerRegex.test(match.type)) {
      type = `${match.type}256`;
    } else {
      type = match.type;
      if (!(options2?.type === "struct") && !isSolidityType(type))
        throw new abiItem_js_1.UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
      if (!options2?.modifiers?.has?.(match.modifier))
        throw new abiParameter_js_1.InvalidModifierError({
          param,
          type: options2?.type,
          modifier: match.modifier
        });
      if (signatures_js_1.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
        throw new abiParameter_js_1.InvalidFunctionModifierError({
          param,
          type: options2?.type,
          modifier: match.modifier
        });
    }
    const abiParameter = {
      type: `${type}${match.array ?? ""}`,
      ...name,
      ...indexed,
      ...components
    };
    cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
  }
  function splitParameters(params, result = [], current = "", depth = 0) {
    const length = params.trim().length;
    for (let i = 0;i < length; i++) {
      const char = params[i];
      const tail = params.slice(i + 1);
      switch (char) {
        case ",":
          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
        case "(":
          return splitParameters(tail, result, `${current}${char}`, depth + 1);
        case ")":
          return splitParameters(tail, result, `${current}${char}`, depth - 1);
        default:
          return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
    if (current === "")
      return result;
    if (depth !== 0)
      throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
  }
  function isSolidityType(type) {
    return type === "address" || type === "bool" || type === "function" || type === "string" || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);
  }
  function isSolidityKeyword(name) {
    return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);
  }
  function isValidDataLocation(type, isArray) {
    return isArray || type === "bytes" || type === "string" || type === "tuple";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = undefined;
  var regex_js_1 = require_regex();
  var abiItem_js_1 = require_abiItem();
  var abiParameter_js_1 = require_abiParameter();
  var signature_js_1 = require_signature();
  var splitParameters_js_1 = require_splitParameters();
  var cache_js_1 = require_cache();
  var signatures_js_1 = require_signatures();
  exports.parseSignature = parseSignature;
  var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  var dynamicIntegerRegex = /^u?int$/;
  exports.parseAbiParameter = parseAbiParameter;
  exports.splitParameters = splitParameters;
  exports.isSolidityType = isSolidityType;
  var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
  exports.isSolidityKeyword = isSolidityKeyword;
  exports.isValidDataLocation = isValidDataLocation;
});

// node_modules/abitype/dist/cjs/human-readable/runtime/structs.js
var require_structs = __commonJS((exports) => {
  function parseStructs(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0;i < signaturesLength; i++) {
      const signature = signatures[i];
      if (!(0, signatures_js_1.isStructSignature)(signature))
        continue;
      const match = (0, signatures_js_1.execStructSignature)(signature);
      if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: "struct" });
      const properties = match.properties.split(";");
      const components = [];
      const propertiesLength = properties.length;
      for (let k = 0;k < propertiesLength; k++) {
        const property = properties[k];
        const trimmed = property.trim();
        if (!trimmed)
          continue;
        const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
          type: "struct"
        });
        components.push(abiParameter);
      }
      if (!components.length)
        throw new signature_js_1.InvalidStructSignatureError({ signature });
      shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0;i < entriesLength; i++) {
      const [name, parameters] = entries[i];
      resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
  }
  function resolveStructs(abiParameters, structs, ancestors = new Set) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0;i < length; i++) {
      const abiParameter = abiParameters[i];
      const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
      if (isTuple)
        components.push(abiParameter);
      else {
        const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
        if (!match?.type)
          throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter });
        const { array, type } = match;
        if (type in structs) {
          if (ancestors.has(type))
            throw new struct_js_1.CircularReferenceError({ type });
          components.push({
            ...abiParameter,
            type: `tuple${array ?? ""}`,
            components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))
          });
        } else {
          if ((0, utils_js_1.isSolidityType)(type))
            components.push(abiParameter);
          else
            throw new abiItem_js_1.UnknownTypeError({ type });
        }
      }
    }
    return components;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseStructs = undefined;
  var regex_js_1 = require_regex();
  var abiItem_js_1 = require_abiItem();
  var abiParameter_js_1 = require_abiParameter();
  var signature_js_1 = require_signature();
  var struct_js_1 = require_struct();
  var signatures_js_1 = require_signatures();
  var utils_js_1 = require_utils3();
  exports.parseStructs = parseStructs;
  var typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
});

// node_modules/abitype/dist/cjs/human-readable/parseAbi.js
var require_parseAbi = __commonJS((exports) => {
  function parseAbi(signatures) {
    const structs = (0, structs_js_1.parseStructs)(signatures);
    const abi = [];
    const length = signatures.length;
    for (let i = 0;i < length; i++) {
      const signature = signatures[i];
      if ((0, signatures_js_1.isStructSignature)(signature))
        continue;
      abi.push((0, utils_js_1.parseSignature)(signature, structs));
    }
    return abi;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAbi = undefined;
  var signatures_js_1 = require_signatures();
  var structs_js_1 = require_structs();
  var utils_js_1 = require_utils3();
  exports.parseAbi = parseAbi;
});

// node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js
var require_parseAbiItem = __commonJS((exports) => {
  function parseAbiItem(signature) {
    let abiItem;
    if (typeof signature === "string")
      abiItem = (0, utils_js_1.parseSignature)(signature);
    else {
      const structs = (0, structs_js_1.parseStructs)(signature);
      const length = signature.length;
      for (let i = 0;i < length; i++) {
        const signature_ = signature[i];
        if ((0, signatures_js_1.isStructSignature)(signature_))
          continue;
        abiItem = (0, utils_js_1.parseSignature)(signature_, structs);
        break;
      }
    }
    if (!abiItem)
      throw new abiItem_js_1.InvalidAbiItemError({ signature });
    return abiItem;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAbiItem = undefined;
  var abiItem_js_1 = require_abiItem();
  var signatures_js_1 = require_signatures();
  var structs_js_1 = require_structs();
  var utils_js_1 = require_utils3();
  exports.parseAbiItem = parseAbiItem;
});

// node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js
var require_parseAbiParameter = __commonJS((exports) => {
  function parseAbiParameter(param) {
    let abiParameter;
    if (typeof param === "string")
      abiParameter = (0, utils_js_1.parseAbiParameter)(param, {
        modifiers: signatures_js_1.modifiers
      });
    else {
      const structs = (0, structs_js_1.parseStructs)(param);
      const length = param.length;
      for (let i = 0;i < length; i++) {
        const signature = param[i];
        if ((0, signatures_js_1.isStructSignature)(signature))
          continue;
        abiParameter = (0, utils_js_1.parseAbiParameter)(signature, { modifiers: signatures_js_1.modifiers, structs });
        break;
      }
    }
    if (!abiParameter)
      throw new abiParameter_js_1.InvalidAbiParameterError({ param });
    return abiParameter;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAbiParameter = undefined;
  var abiParameter_js_1 = require_abiParameter();
  var signatures_js_1 = require_signatures();
  var structs_js_1 = require_structs();
  var utils_js_1 = require_utils3();
  exports.parseAbiParameter = parseAbiParameter;
});

// node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js
var require_parseAbiParameters = __commonJS((exports) => {
  function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === "string") {
      const parameters = (0, utils_js_1.splitParameters)(params);
      const length = parameters.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], { modifiers: signatures_js_1.modifiers }));
      }
    } else {
      const structs = (0, structs_js_1.parseStructs)(params);
      const length = params.length;
      for (let i = 0;i < length; i++) {
        const signature = params[i];
        if ((0, signatures_js_1.isStructSignature)(signature))
          continue;
        const parameters = (0, utils_js_1.splitParameters)(signature);
        const length2 = parameters.length;
        for (let k = 0;k < length2; k++) {
          abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], { modifiers: signatures_js_1.modifiers, structs }));
        }
      }
    }
    if (abiParameters.length === 0)
      throw new abiParameter_js_1.InvalidAbiParametersError({ params });
    return abiParameters;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAbiParameters = undefined;
  var abiParameter_js_1 = require_abiParameter();
  var signatures_js_1 = require_signatures();
  var structs_js_1 = require_structs();
  var utils_js_1 = require_utils3();
  var utils_js_2 = require_utils3();
  exports.parseAbiParameters = parseAbiParameters;
});

// node_modules/abitype/dist/cjs/exports/index.js
var require_exports = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = undefined;
  var errors_js_1 = require_errors();
  Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
    return errors_js_1.BaseError;
  } });
  var narrow_js_1 = require_narrow();
  Object.defineProperty(exports, "narrow", { enumerable: true, get: function() {
    return narrow_js_1.narrow;
  } });
  var formatAbi_js_1 = require_formatAbi();
  Object.defineProperty(exports, "formatAbi", { enumerable: true, get: function() {
    return formatAbi_js_1.formatAbi;
  } });
  var formatAbiItem_js_1 = require_formatAbiItem();
  Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
    return formatAbiItem_js_1.formatAbiItem;
  } });
  var formatAbiParameter_js_1 = require_formatAbiParameter();
  Object.defineProperty(exports, "formatAbiParameter", { enumerable: true, get: function() {
    return formatAbiParameter_js_1.formatAbiParameter;
  } });
  var formatAbiParameters_js_1 = require_formatAbiParameters();
  Object.defineProperty(exports, "formatAbiParameters", { enumerable: true, get: function() {
    return formatAbiParameters_js_1.formatAbiParameters;
  } });
  var parseAbi_js_1 = require_parseAbi();
  Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
    return parseAbi_js_1.parseAbi;
  } });
  var parseAbiItem_js_1 = require_parseAbiItem();
  Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
    return parseAbiItem_js_1.parseAbiItem;
  } });
  var parseAbiParameter_js_1 = require_parseAbiParameter();
  Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
    return parseAbiParameter_js_1.parseAbiParameter;
  } });
  var parseAbiParameters_js_1 = require_parseAbiParameters();
  Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
    return parseAbiParameters_js_1.parseAbiParameters;
  } });
  var abiItem_js_1 = require_abiItem();
  Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
    return abiItem_js_1.UnknownTypeError;
  } });
  Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
    return abiItem_js_1.InvalidAbiItemError;
  } });
  Object.defineProperty(exports, "UnknownSolidityTypeError", { enumerable: true, get: function() {
    return abiItem_js_1.UnknownSolidityTypeError;
  } });
  var abiParameter_js_1 = require_abiParameter();
  Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
    return abiParameter_js_1.InvalidAbiTypeParameterError;
  } });
  Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
    return abiParameter_js_1.InvalidFunctionModifierError;
  } });
  Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
    return abiParameter_js_1.InvalidModifierError;
  } });
  Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
    return abiParameter_js_1.SolidityProtectedKeywordError;
  } });
  Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
    return abiParameter_js_1.InvalidParameterError;
  } });
  Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
    return abiParameter_js_1.InvalidAbiParametersError;
  } });
  Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
    return abiParameter_js_1.InvalidAbiParameterError;
  } });
  var signature_js_1 = require_signature();
  Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
    return signature_js_1.InvalidStructSignatureError;
  } });
  Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
    return signature_js_1.InvalidSignatureError;
  } });
  Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
    return signature_js_1.UnknownSignatureError;
  } });
  var splitParameters_js_1 = require_splitParameters();
  Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
    return splitParameters_js_1.InvalidParenthesisError;
  } });
  var struct_js_1 = require_struct();
  Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
    return struct_js_1.CircularReferenceError;
  } });
});

// node_modules/viem/_cjs/utils/getAction.js
var require_getAction = __commonJS((exports) => {
  function getAction2(client, action, name) {
    return (params) => client[action.name]?.(params) ?? client[name]?.(params) ?? action(client, params);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAction = undefined;
  exports.getAction = getAction2;
});

// node_modules/viem/_cjs/utils/abi/formatAbiItem.js
var require_formatAbiItem2 = __commonJS((exports) => {
  function formatAbiItem3(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
      throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams2(abiItem.inputs, { includeName })})`;
  }
  function formatAbiParams2(params, { includeName = false } = {}) {
    if (!params)
      return "";
    return params.map((param) => formatAbiParam2(param, { includeName })).join(includeName ? ", " : ",");
  }
  function formatAbiParam2(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams2(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatAbiParams = exports.formatAbiItem = undefined;
  var abi_js_1 = require_abi();
  exports.formatAbiItem = formatAbiItem3;
  exports.formatAbiParams = formatAbiParams2;
});

// node_modules/viem/_cjs/errors/abi.js
var require_abi = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiDecodingTypeError = exports.InvalidAbiEncodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiItemAmbiguityError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingOffsetOutOfBoundsError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = undefined;
  var formatAbiItem_js_1 = require_formatAbiItem2();
  var size_js_1 = require_size();
  var base_js_1 = require_base();

  class AbiConstructorNotFoundError2 extends base_js_1.BaseError {
    constructor({ docsPath: docsPath5 }) {
      super([
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it."
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiConstructorNotFoundError"
      });
    }
  }
  exports.AbiConstructorNotFoundError = AbiConstructorNotFoundError2;

  class AbiConstructorParamsNotFoundError2 extends base_js_1.BaseError {
    constructor({ docsPath: docsPath5 }) {
      super([
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiConstructorParamsNotFoundError"
      });
    }
  }
  exports.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError2;

  class AbiDecodingDataSizeInvalidError2 extends base_js_1.BaseError {
    constructor({ data, size: size2 }) {
      super([
        `Data size of ${size2} bytes is invalid.`,
        "Size must be in increments of 32 bytes (size % 32 === 0)."
      ].join("\n"), { metaMessages: [`Data: ${data} (${size2} bytes)`] });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingDataSizeInvalidError"
      });
    }
  }
  exports.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError2;

  class AbiDecodingDataSizeTooSmallError2 extends base_js_1.BaseError {
    constructor({ data, params, size: size2 }) {
      super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
        metaMessages: [
          `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingDataSizeTooSmallError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  }
  exports.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError2;

  class AbiDecodingOffsetOutOfBoundsError extends base_js_1.BaseError {
    constructor({ offset, position }) {
      super(`Offset at "${offset}" is out-of-bounds (current position: "${position}").`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingOffsetOutOfBoundsError"
      });
    }
  }
  exports.AbiDecodingOffsetOutOfBoundsError = AbiDecodingOffsetOutOfBoundsError;

  class AbiDecodingZeroDataError2 extends base_js_1.BaseError {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.');
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingZeroDataError"
      });
    }
  }
  exports.AbiDecodingZeroDataError = AbiDecodingZeroDataError2;

  class AbiEncodingArrayLengthMismatchError2 extends base_js_1.BaseError {
    constructor({ expectedLength, givenLength, type }) {
      super([
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingArrayLengthMismatchError"
      });
    }
  }
  exports.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError2;

  class AbiEncodingBytesSizeMismatchError2 extends base_js_1.BaseError {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingBytesSizeMismatchError"
      });
    }
  }
  exports.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError2;

  class AbiEncodingLengthMismatchError2 extends base_js_1.BaseError {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingLengthMismatchError"
      });
    }
  }
  exports.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError2;

  class AbiErrorInputsNotFoundError2 extends base_js_1.BaseError {
    constructor(errorName, { docsPath: docsPath5 }) {
      super([
        `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
        "Cannot encode error result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the inputs exist on it."
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiErrorInputsNotFoundError"
      });
    }
  }
  exports.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError2;

  class AbiErrorNotFoundError2 extends base_js_1.BaseError {
    constructor(errorName, { docsPath: docsPath5 } = {}) {
      super([
        `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it."
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiErrorNotFoundError"
      });
    }
  }
  exports.AbiErrorNotFoundError = AbiErrorNotFoundError2;

  class AbiErrorSignatureNotFoundError2 extends base_js_1.BaseError {
    constructor(signature, { docsPath: docsPath5 }) {
      super([
        `Encoded error signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiErrorSignatureNotFoundError"
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.signature = signature;
    }
  }
  exports.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError2;

  class AbiEventSignatureEmptyTopicsError2 extends base_js_1.BaseError {
    constructor({ docsPath: docsPath5 }) {
      super("Cannot extract event signature from empty topics.", {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventSignatureEmptyTopicsError"
      });
    }
  }
  exports.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError2;

  class AbiEventSignatureNotFoundError2 extends base_js_1.BaseError {
    constructor(signature, { docsPath: docsPath5 }) {
      super([
        `Encoded event signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventSignatureNotFoundError"
      });
    }
  }
  exports.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError2;

  class AbiEventNotFoundError2 extends base_js_1.BaseError {
    constructor(eventName, { docsPath: docsPath5 } = {}) {
      super([
        `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it."
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventNotFoundError"
      });
    }
  }
  exports.AbiEventNotFoundError = AbiEventNotFoundError2;

  class AbiFunctionNotFoundError2 extends base_js_1.BaseError {
    constructor(functionName, { docsPath: docsPath5 } = {}) {
      super([
        `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionNotFoundError"
      });
    }
  }
  exports.AbiFunctionNotFoundError = AbiFunctionNotFoundError2;

  class AbiFunctionOutputsNotFoundError2 extends base_js_1.BaseError {
    constructor(functionName, { docsPath: docsPath5 }) {
      super([
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionOutputsNotFoundError"
      });
    }
  }
  exports.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError2;

  class AbiFunctionSignatureNotFoundError2 extends base_js_1.BaseError {
    constructor(signature, { docsPath: docsPath5 }) {
      super([
        `Encoded function signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"), {
        docsPath: docsPath5
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionSignatureNotFoundError"
      });
    }
  }
  exports.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError2;

  class AbiItemAmbiguityError2 extends base_js_1.BaseError {
    constructor(x, y) {
      super("Found ambiguous types in overloaded ABI items.", {
        metaMessages: [
          `\`${x.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(x.abiItem)}\`, and`,
          `\`${y.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(y.abiItem)}\``,
          "",
          "These types encode differently and cannot be distinguished at runtime.",
          "Remove one of the ambiguous items in the ABI."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiItemAmbiguityError"
      });
    }
  }
  exports.AbiItemAmbiguityError = AbiItemAmbiguityError2;

  class BytesSizeMismatchError2 extends base_js_1.BaseError {
    constructor({ expectedSize, givenSize }) {
      super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BytesSizeMismatchError"
      });
    }
  }
  exports.BytesSizeMismatchError = BytesSizeMismatchError2;

  class DecodeLogDataMismatch2 extends base_js_1.BaseError {
    constructor({ abiItem, data, params, size: size2 }) {
      super([
        `Data size of ${size2} bytes is too small for non-indexed event parameters.`
      ].join("\n"), {
        metaMessages: [
          `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DecodeLogDataMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  }
  exports.DecodeLogDataMismatch = DecodeLogDataMismatch2;

  class DecodeLogTopicsMismatch2 extends base_js_1.BaseError {
    constructor({ abiItem, param }) {
      super([
        `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DecodeLogTopicsMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
    }
  }
  exports.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch2;

  class InvalidAbiEncodingTypeError2 extends base_js_1.BaseError {
    constructor(type, { docsPath: docsPath5 }) {
      super([
        `Type "${type}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"), { docsPath: docsPath5 });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiEncodingType"
      });
    }
  }
  exports.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError2;

  class InvalidAbiDecodingTypeError2 extends base_js_1.BaseError {
    constructor(type, { docsPath: docsPath5 }) {
      super([
        `Type "${type}" is not a valid decoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"), { docsPath: docsPath5 });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiDecodingType"
      });
    }
  }
  exports.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError2;

  class InvalidArrayError2 extends base_js_1.BaseError {
    constructor(value) {
      super([`Value "${value}" is not a valid array.`].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidArrayError"
      });
    }
  }
  exports.InvalidArrayError = InvalidArrayError2;

  class InvalidDefinitionTypeError2 extends base_js_1.BaseError {
    constructor(type) {
      super([
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidDefinitionTypeError"
      });
    }
  }
  exports.InvalidDefinitionTypeError = InvalidDefinitionTypeError2;

  class UnsupportedPackedAbiType2 extends base_js_1.BaseError {
    constructor(type) {
      super(`Type "${type}" is not supported for packed encoding.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnsupportedPackedAbiType"
      });
    }
  }
  exports.UnsupportedPackedAbiType = UnsupportedPackedAbiType2;
});

// node_modules/viem/_cjs/errors/log.js
var require_log2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FilterTypeNotSupportedError = undefined;
  var base_js_1 = require_base();

  class FilterTypeNotSupportedError2 extends base_js_1.BaseError {
    constructor(type) {
      super(`Filter type "${type}" is not supported.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FilterTypeNotSupportedError"
      });
    }
  }
  exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError2;
});

// node_modules/viem/_cjs/utils/hash/hashSignature.js
var require_hashSignature = __commonJS((exports) => {
  function hashSignature2(sig) {
    return hash2(sig);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hashSignature = undefined;
  var toBytes_js_1 = require_toBytes();
  var keccak256_js_1 = require_keccak256();
  var hash2 = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
  exports.hashSignature = hashSignature2;
});

// node_modules/viem/_cjs/utils/hash/normalizeSignature.js
var require_normalizeSignature = __commonJS((exports) => {
  function normalizeSignature2(signature) {
    let active = true;
    let current = "";
    let level = 0;
    let result = "";
    let valid = false;
    for (let i = 0;i < signature.length; i++) {
      const char = signature[i];
      if (["(", ")", ","].includes(char))
        active = true;
      if (char === "(")
        level++;
      if (char === ")")
        level--;
      if (!active)
        continue;
      if (level === 0) {
        if (char === " " && ["event", "function", ""].includes(result))
          result = "";
        else {
          result += char;
          if (char === ")") {
            valid = true;
            break;
          }
        }
        continue;
      }
      if (char === " ") {
        if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
          current = "";
          active = false;
        }
        continue;
      }
      result += char;
      current += char;
    }
    if (!valid)
      throw new base_js_1.BaseError("Unable to normalize signature.");
    return result;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizeSignature = undefined;
  var base_js_1 = require_base();
  exports.normalizeSignature = normalizeSignature2;
});

// node_modules/viem/_cjs/utils/hash/toSignature.js
var require_toSignature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toSignature = undefined;
  var abitype_1 = require_exports();
  var normalizeSignature_js_1 = require_normalizeSignature();
  var toSignature2 = (def) => {
    const def_ = (() => {
      if (typeof def === "string")
        return def;
      return (0, abitype_1.formatAbiItem)(def);
    })();
    return (0, normalizeSignature_js_1.normalizeSignature)(def_);
  };
  exports.toSignature = toSignature2;
});

// node_modules/viem/_cjs/utils/hash/toSignatureHash.js
var require_toSignatureHash = __commonJS((exports) => {
  function toSignatureHash2(fn) {
    return (0, hashSignature_js_1.hashSignature)((0, toSignature_js_1.toSignature)(fn));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toSignatureHash = undefined;
  var hashSignature_js_1 = require_hashSignature();
  var toSignature_js_1 = require_toSignature();
  exports.toSignatureHash = toSignatureHash2;
});

// node_modules/viem/_cjs/utils/hash/toEventSelector.js
var require_toEventSelector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toEventSelector = undefined;
  var toSignatureHash_js_1 = require_toSignatureHash();
  exports.toEventSelector = toSignatureHash_js_1.toSignatureHash;
});

// node_modules/viem/_cjs/utils/data/slice.js
var require_slice = __commonJS((exports) => {
  function slice2(value, start, end, { strict } = {}) {
    if ((0, isHex_js_1.isHex)(value, { strict: false }))
      return sliceHex2(value, start, end, {
        strict
      });
    return sliceBytes2(value, start, end, {
      strict
    });
  }
  function assertStartOffset2(value, start) {
    if (typeof start === "number" && start > 0 && start > (0, size_js_1.size)(value) - 1)
      throw new data_js_1.SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: (0, size_js_1.size)(value)
      });
  }
  function assertEndOffset2(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && (0, size_js_1.size)(value) !== end - start) {
      throw new data_js_1.SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: (0, size_js_1.size)(value)
      });
    }
  }
  function sliceBytes2(value_, start, end, { strict } = {}) {
    assertStartOffset2(value_, start);
    const value = value_.slice(start, end);
    if (strict)
      assertEndOffset2(value, start, end);
    return value;
  }
  function sliceHex2(value_, start, end, { strict } = {}) {
    assertStartOffset2(value_, start);
    const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
      assertEndOffset2(value, start, end);
    return value;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sliceHex = exports.sliceBytes = exports.slice = undefined;
  var data_js_1 = require_data();
  var isHex_js_1 = require_isHex();
  var size_js_1 = require_size();
  exports.slice = slice2;
  exports.sliceBytes = sliceBytes2;
  exports.sliceHex = sliceHex2;
});

// node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js
var require_encodeAbiParameters = __commonJS((exports) => {
  function encodeAbiParameters2(params, values) {
    if (params.length !== values.length)
      throw new abi_js_1.AbiEncodingLengthMismatchError({
        expectedLength: params.length,
        givenLength: values.length
      });
    const preparedParams = prepareParams2({
      params,
      values
    });
    const data = encodeParams2(preparedParams);
    if (data.length === 0)
      return "0x";
    return data;
  }
  function prepareParams2({ params, values }) {
    const preparedParams = [];
    for (let i = 0;i < params.length; i++) {
      preparedParams.push(prepareParam2({ param: params[i], value: values[i] }));
    }
    return preparedParams;
  }
  function prepareParam2({ param, value }) {
    const arrayComponents = getArrayComponents2(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray2(value, { length, param: { ...param, type } });
    }
    if (param.type === "tuple") {
      return encodeTuple2(value, {
        param
      });
    }
    if (param.type === "address") {
      return encodeAddress2(value);
    }
    if (param.type === "bool") {
      return encodeBool2(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      const signed = param.type.startsWith("int");
      return encodeNumber2(value, { signed });
    }
    if (param.type.startsWith("bytes")) {
      return encodeBytes2(value, { param });
    }
    if (param.type === "string") {
      return encodeString2(value);
    }
    throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {
      docsPath: "/docs/contract/encodeAbiParameters"
    });
  }
  function encodeParams2(preparedParams) {
    let staticSize = 0;
    for (let i = 0;i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += (0, size_js_1.size)(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i = 0;i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic) {
        staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, { size: 32 }));
        dynamicParams.push(encoded);
        dynamicSize += (0, size_js_1.size)(encoded);
      } else {
        staticParams.push(encoded);
      }
    }
    return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);
  }
  function encodeAddress2(value) {
    if (!(0, isAddress_js_1.isAddress)(value))
      throw new address_js_1.InvalidAddressError({ address: value });
    return { dynamic: false, encoded: (0, pad_js_1.padHex)(value.toLowerCase()) };
  }
  function encodeArray2(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new abi_js_1.InvalidArrayError(value);
    if (!dynamic && value.length !== length)
      throw new abi_js_1.AbiEncodingArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i = 0;i < value.length; i++) {
      const preparedParam = prepareParam2({ param, value: value[i] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encodeParams2(preparedParams);
      if (dynamic) {
        const length2 = (0, toHex_js_1.numberToHex)(preparedParams.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length2, data]) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes2(value, { param }) {
    const [, paramSize] = param.type.split("bytes");
    const bytesSize = (0, size_js_1.size)(value);
    if (!paramSize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = (0, pad_js_1.padHex)(value_, {
          dir: "right",
          size: Math.ceil((value.length - 2) / 2 / 32) * 32
        });
      return {
        dynamic: true,
        encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)(bytesSize, { size: 32 })), value_])
      };
    }
    if (bytesSize !== parseInt(paramSize))
      throw new abi_js_1.AbiEncodingBytesSizeMismatchError({
        expectedSize: parseInt(paramSize),
        value
      });
    return { dynamic: false, encoded: (0, pad_js_1.padHex)(value, { dir: "right" }) };
  }
  function encodeBool2(value) {
    if (typeof value !== "boolean")
      throw new base_js_1.BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value)) };
  }
  function encodeNumber2(value, { signed }) {
    return {
      dynamic: false,
      encoded: (0, toHex_js_1.numberToHex)(value, {
        size: 32,
        signed
      })
    };
  }
  function encodeString2(value) {
    const hexValue = (0, toHex_js_1.stringToHex)(value);
    const partsLength = Math.ceil((0, size_js_1.size)(hexValue) / 32);
    const parts = [];
    for (let i = 0;i < partsLength; i++) {
      parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue, i * 32, (i + 1) * 32), {
        dir: "right"
      }));
    }
    return {
      dynamic: true,
      encoded: (0, concat_js_1.concat)([
        (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue), { size: 32 })),
        ...parts
      ])
    };
  }
  function encodeTuple2(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i = 0;i < param.components.length; i++) {
      const param_ = param.components[i];
      const index = Array.isArray(value) ? i : param_.name;
      const preparedParam = prepareParam2({
        param: param_,
        value: value[index]
      });
      preparedParams.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encodeParams2(preparedParams) : (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents2(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getArrayComponents = exports.encodeAbiParameters = undefined;
  var abi_js_1 = require_abi();
  var address_js_1 = require_address();
  var base_js_1 = require_base();
  var isAddress_js_1 = require_isAddress();
  var concat_js_1 = require_concat();
  var pad_js_1 = require_pad();
  var size_js_1 = require_size();
  var slice_js_1 = require_slice();
  var toHex_js_1 = require_toHex();
  exports.encodeAbiParameters = encodeAbiParameters2;
  exports.getArrayComponents = getArrayComponents2;
});

// node_modules/viem/_cjs/utils/hash/toFunctionSelector.js
var require_toFunctionSelector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toFunctionSelector = undefined;
  var slice_js_1 = require_slice();
  var toSignatureHash_js_1 = require_toSignatureHash();
  var toFunctionSelector2 = (fn) => (0, slice_js_1.slice)((0, toSignatureHash_js_1.toSignatureHash)(fn), 0, 4);
  exports.toFunctionSelector = toFunctionSelector2;
});

// node_modules/viem/_cjs/utils/abi/getAbiItem.js
var require_getAbiItem = __commonJS((exports) => {
  function getAbiItem2(parameters) {
    const { abi, args = [], name } = parameters;
    const isSelector = (0, isHex_js_1.isHex)(name, { strict: false });
    const abiItems = abi.filter((abiItem) => {
      if (isSelector) {
        if (abiItem.type === "function")
          return (0, toFunctionSelector_js_1.toFunctionSelector)(abiItem) === name;
        if (abiItem.type === "event")
          return (0, toEventSelector_js_1.toEventSelector)(abiItem) === name;
        return false;
      }
      return "name" in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0)
      return;
    if (abiItems.length === 1)
      return abiItems[0];
    let matchedAbiItem = undefined;
    for (const abiItem of abiItems) {
      if (!("inputs" in abiItem))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem.inputs || abiItem.inputs.length === 0)
          return abiItem;
        continue;
      }
      if (!abiItem.inputs)
        continue;
      if (abiItem.inputs.length === 0)
        continue;
      if (abiItem.inputs.length !== args.length)
        continue;
      const matched = args.every((arg, index) => {
        const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
        if (!abiParameter)
          return false;
        return isArgOfType2(arg, abiParameter);
      });
      if (matched) {
        if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
          const ambiguousTypes = getAmbiguousTypes2(abiItem.inputs, matchedAbiItem.inputs, args);
          if (ambiguousTypes)
            throw new abi_js_1.AbiItemAmbiguityError({
              abiItem,
              type: ambiguousTypes[0]
            }, {
              abiItem: matchedAbiItem,
              type: ambiguousTypes[1]
            });
        }
        matchedAbiItem = abiItem;
      }
    }
    if (matchedAbiItem)
      return matchedAbiItem;
    return abiItems[0];
  }
  function isArgOfType2(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return (0, isAddress_js_1.isAddress)(arg, { strict: false });
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index) => {
            return isArgOfType2(Object.values(arg)[index], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x) => isArgOfType2(x, {
            ...abiParameter,
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  function getAmbiguousTypes2(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
      const sourceParameter = sourceParameters[parameterIndex];
      const targetParameter = targetParameters[parameterIndex];
      if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
        return getAmbiguousTypes2(sourceParameter.components, targetParameter.components, args[parameterIndex]);
      const types = [sourceParameter.type, targetParameter.type];
      const ambiguous = (() => {
        if (types.includes("address") && types.includes("bytes20"))
          return true;
        if (types.includes("address") && types.includes("string"))
          return (0, isAddress_js_1.isAddress)(args[parameterIndex], { strict: false });
        if (types.includes("address") && types.includes("bytes"))
          return (0, isAddress_js_1.isAddress)(args[parameterIndex], { strict: false });
        return false;
      })();
      if (ambiguous)
        return types;
    }
    return;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAmbiguousTypes = exports.isArgOfType = exports.getAbiItem = undefined;
  var abi_js_1 = require_abi();
  var isHex_js_1 = require_isHex();
  var isAddress_js_1 = require_isAddress();
  var toEventSelector_js_1 = require_toEventSelector();
  var toFunctionSelector_js_1 = require_toFunctionSelector();
  exports.getAbiItem = getAbiItem2;
  exports.isArgOfType = isArgOfType2;
  exports.getAmbiguousTypes = getAmbiguousTypes2;
});

// node_modules/viem/_cjs/utils/abi/encodeEventTopics.js
var require_encodeEventTopics = __commonJS((exports) => {
  function encodeEventTopics2(parameters) {
    const { abi, eventName, args } = parameters;
    let abiItem = abi[0];
    if (eventName) {
      const item = (0, getAbiItem_js_1.getAbiItem)({ abi, name: eventName });
      if (!item)
        throw new abi_js_1.AbiEventNotFoundError(eventName, { docsPath: docsPath5 });
      abiItem = item;
    }
    if (abiItem.type !== "event")
      throw new abi_js_1.AbiEventNotFoundError(undefined, { docsPath: docsPath5 });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, toEventSelector_js_1.toEventSelector)(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
      const indexedInputs = abiItem.inputs?.filter((param) => ("indexed" in param) && param.indexed);
      const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
      if (args_.length > 0) {
        topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg2({ param, value: args_[i][j] })) : args_[i] ? encodeArg2({ param, value: args_[i] }) : null) ?? [];
      }
    }
    return [signature, ...topics];
  }
  function encodeArg2({ param, value }) {
    if (param.type === "string" || param.type === "bytes")
      return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      throw new log_js_1.FilterTypeNotSupportedError(param.type);
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeEventTopics = undefined;
  var abi_js_1 = require_abi();
  var log_js_1 = require_log2();
  var toBytes_js_1 = require_toBytes();
  var keccak256_js_1 = require_keccak256();
  var toEventSelector_js_1 = require_toEventSelector();
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  var formatAbiItem_js_1 = require_formatAbiItem2();
  var getAbiItem_js_1 = require_getAbiItem();
  var docsPath5 = "/docs/contract/encodeEventTopics";
  exports.encodeEventTopics = encodeEventTopics2;
});

// node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js
var require_createFilterRequestScope = __commonJS((exports) => {
  function createFilterRequestScope2(client, { method }) {
    const requestMap = {};
    if (client.transport.type === "fallback")
      client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
        if (status === "success" && method === method_)
          requestMap[id] = transport.request;
      });
    return (id) => requestMap[id] || client.request;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFilterRequestScope = undefined;
  exports.createFilterRequestScope = createFilterRequestScope2;
});

// node_modules/viem/_cjs/actions/public/createContractEventFilter.js
var require_createContractEventFilter = __commonJS((exports) => {
  async function createContractEventFilter2(client, parameters) {
    const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
      method: "eth_newFilter"
    });
    const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
      abi,
      args,
      eventName
    }) : undefined;
    const id = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
          topics
        }
      ]
    });
    return {
      abi,
      args,
      eventName,
      id,
      request: getRequest(id),
      strict: Boolean(strict),
      type: "event"
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createContractEventFilter = undefined;
  var encodeEventTopics_js_1 = require_encodeEventTopics();
  var toHex_js_1 = require_toHex();
  var createFilterRequestScope_js_1 = require_createFilterRequestScope();
  exports.createContractEventFilter = createContractEventFilter2;
});

// node_modules/viem/_cjs/accounts/utils/parseAccount.js
var require_parseAccount = __commonJS((exports) => {
  function parseAccount2(account) {
    if (typeof account === "string")
      return { address: account, type: "json-rpc" };
    return account;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAccount = undefined;
  exports.parseAccount = parseAccount2;
});

// node_modules/viem/_cjs/utils/abi/prepareEncodeFunctionData.js
var require_prepareEncodeFunctionData = __commonJS((exports) => {
  function prepareEncodeFunctionData2(parameters) {
    const { abi, args, functionName } = parameters;
    let abiItem = abi[0];
    if (functionName) {
      const item = (0, getAbiItem_js_1.getAbiItem)({
        abi,
        args,
        name: functionName
      });
      if (!item)
        throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath: docsPath5 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new abi_js_1.AbiFunctionNotFoundError(undefined, { docsPath: docsPath5 });
    return {
      abi: [abiItem],
      functionName: (0, toFunctionSelector_js_1.toFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(abiItem))
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareEncodeFunctionData = undefined;
  var abi_js_1 = require_abi();
  var toFunctionSelector_js_1 = require_toFunctionSelector();
  var formatAbiItem_js_1 = require_formatAbiItem2();
  var getAbiItem_js_1 = require_getAbiItem();
  var docsPath5 = "/docs/contract/encodeFunctionData";
  exports.prepareEncodeFunctionData = prepareEncodeFunctionData2;
});

// node_modules/viem/_cjs/utils/abi/encodeFunctionData.js
var require_encodeFunctionData = __commonJS((exports) => {
  function encodeFunctionData2(parameters) {
    const { args } = parameters;
    const { abi, functionName } = (() => {
      if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
        return parameters;
      return (0, prepareEncodeFunctionData_js_1.prepareEncodeFunctionData)(parameters);
    })();
    const abiItem = abi[0];
    const signature = functionName;
    const data = "inputs" in abiItem && abiItem.inputs ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args ?? []) : undefined;
    return (0, concat_js_1.concatHex)([signature, data ?? "0x"]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeFunctionData = undefined;
  var concat_js_1 = require_concat();
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  var prepareEncodeFunctionData_js_1 = require_prepareEncodeFunctionData();
  exports.encodeFunctionData = encodeFunctionData2;
});

// node_modules/viem/_cjs/constants/solidity.js
var require_solidity = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.solidityPanic = exports.solidityError = exports.panicReasons = undefined;
  exports.panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmetic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
  };
  exports.solidityError = {
    inputs: [
      {
        name: "message",
        type: "string"
      }
    ],
    name: "Error",
    type: "error"
  };
  exports.solidityPanic = {
    inputs: [
      {
        name: "reason",
        type: "uint256"
      }
    ],
    name: "Panic",
    type: "error"
  };
});

// node_modules/viem/_cjs/errors/cursor.js
var require_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RecursiveReadLimitExceededError = exports.PositionOutOfBoundsError = exports.NegativeOffsetError = undefined;
  var base_js_1 = require_base();

  class NegativeOffsetError2 extends base_js_1.BaseError {
    constructor({ offset }) {
      super(`Offset \`${offset}\` cannot be negative.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NegativeOffsetError"
      });
    }
  }
  exports.NegativeOffsetError = NegativeOffsetError2;

  class PositionOutOfBoundsError2 extends base_js_1.BaseError {
    constructor({ length, position }) {
      super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PositionOutOfBoundsError"
      });
    }
  }
  exports.PositionOutOfBoundsError = PositionOutOfBoundsError2;

  class RecursiveReadLimitExceededError2 extends base_js_1.BaseError {
    constructor({ count, limit }) {
      super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RecursiveReadLimitExceededError"
      });
    }
  }
  exports.RecursiveReadLimitExceededError = RecursiveReadLimitExceededError2;
});

// node_modules/viem/_cjs/utils/cursor.js
var require_cursor2 = __commonJS((exports) => {
  function createCursor2(bytes2, { recursiveReadLimit = 8192 } = {}) {
    const cursor = Object.create(staticCursor2);
    cursor.bytes = bytes2;
    cursor.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    cursor.positionReadCount = new Map;
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCursor = undefined;
  var cursor_js_1 = require_cursor();
  var staticCursor2 = {
    bytes: new Uint8Array,
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map,
    recursiveReadCount: 0,
    recursiveReadLimit: Infinity,
    assertReadLimit() {
      if (this.recursiveReadCount >= this.recursiveReadLimit)
        throw new cursor_js_1.RecursiveReadLimitExceededError({
          count: this.recursiveReadCount + 1,
          limit: this.recursiveReadLimit
        });
    },
    assertPosition(position) {
      if (position < 0 || position > this.bytes.length - 1)
        throw new cursor_js_1.PositionOutOfBoundsError({
          length: this.bytes.length,
          position
        });
    },
    decrementPosition(offset) {
      if (offset < 0)
        throw new cursor_js_1.NegativeOffsetError({ offset });
      const position = this.position - offset;
      this.assertPosition(position);
      this.position = position;
    },
    getReadCount(position) {
      return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
      if (offset < 0)
        throw new cursor_js_1.NegativeOffsetError({ offset });
      const position = this.position + offset;
      this.assertPosition(position);
      this.position = position;
    },
    inspectByte(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectBytes(length, position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + length - 1);
      return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectUint16(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 1);
      return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 2);
      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 3);
      return this.dataView.getUint32(position);
    },
    pushByte(byte) {
      this.assertPosition(this.position);
      this.bytes[this.position] = byte;
      this.position++;
    },
    pushBytes(bytes2) {
      this.assertPosition(this.position + bytes2.length - 1);
      this.bytes.set(bytes2, this.position);
      this.position += bytes2.length;
    },
    pushUint8(value) {
      this.assertPosition(this.position);
      this.bytes[this.position] = value;
      this.position++;
    },
    pushUint16(value) {
      this.assertPosition(this.position + 1);
      this.dataView.setUint16(this.position, value);
      this.position += 2;
    },
    pushUint24(value) {
      this.assertPosition(this.position + 2);
      this.dataView.setUint16(this.position, value >> 8);
      this.dataView.setUint8(this.position + 2, value & ~4294967040);
      this.position += 3;
    },
    pushUint32(value) {
      this.assertPosition(this.position + 3);
      this.dataView.setUint32(this.position, value);
      this.position += 4;
    },
    readByte() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectByte();
      this.position++;
      return value;
    },
    readBytes(length, size2) {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectBytes(length);
      this.position += size2 ?? length;
      return value;
    },
    readUint8() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint8();
      this.position += 1;
      return value;
    },
    readUint16() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint16();
      this.position += 2;
      return value;
    },
    readUint24() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint24();
      this.position += 3;
      return value;
    },
    readUint32() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint32();
      this.position += 4;
      return value;
    },
    get remaining() {
      return this.bytes.length - this.position;
    },
    setPosition(position) {
      const oldPosition = this.position;
      this.assertPosition(position);
      this.position = position;
      return () => this.position = oldPosition;
    },
    _touch() {
      if (this.recursiveReadLimit === Infinity)
        return;
      const count = this.getReadCount();
      this.positionReadCount.set(this.position, count + 1);
      if (count > 0)
        this.recursiveReadCount++;
    }
  };
  exports.createCursor = createCursor2;
});

// node_modules/viem/_cjs/utils/encoding/fromBytes.js
var require_fromBytes = __commonJS((exports) => {
  function fromBytes(bytes2, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === "number")
      return bytesToNumber2(bytes2, opts);
    if (to === "bigint")
      return bytesToBigInt2(bytes2, opts);
    if (to === "boolean")
      return bytesToBool2(bytes2, opts);
    if (to === "string")
      return bytesToString2(bytes2, opts);
    return (0, toHex_js_1.bytesToHex)(bytes2, opts);
  }
  function bytesToBigInt2(bytes2, opts = {}) {
    if (typeof opts.size !== "undefined")
      (0, fromHex_js_1.assertSize)(bytes2, { size: opts.size });
    const hex = (0, toHex_js_1.bytesToHex)(bytes2, opts);
    return (0, fromHex_js_1.hexToBigInt)(hex, opts);
  }
  function bytesToBool2(bytes_, opts = {}) {
    let bytes2 = bytes_;
    if (typeof opts.size !== "undefined") {
      (0, fromHex_js_1.assertSize)(bytes2, { size: opts.size });
      bytes2 = (0, trim_js_1.trim)(bytes2);
    }
    if (bytes2.length > 1 || bytes2[0] > 1)
      throw new encoding_js_1.InvalidBytesBooleanError(bytes2);
    return Boolean(bytes2[0]);
  }
  function bytesToNumber2(bytes2, opts = {}) {
    if (typeof opts.size !== "undefined")
      (0, fromHex_js_1.assertSize)(bytes2, { size: opts.size });
    const hex = (0, toHex_js_1.bytesToHex)(bytes2, opts);
    return (0, fromHex_js_1.hexToNumber)(hex, opts);
  }
  function bytesToString2(bytes_, opts = {}) {
    let bytes2 = bytes_;
    if (typeof opts.size !== "undefined") {
      (0, fromHex_js_1.assertSize)(bytes2, { size: opts.size });
      bytes2 = (0, trim_js_1.trim)(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigInt = exports.fromBytes = undefined;
  var encoding_js_1 = require_encoding();
  var trim_js_1 = require_trim();
  var fromHex_js_1 = require_fromHex();
  var toHex_js_1 = require_toHex();
  exports.fromBytes = fromBytes;
  exports.bytesToBigInt = bytesToBigInt2;
  exports.bytesToBool = bytesToBool2;
  exports.bytesToNumber = bytesToNumber2;
  exports.bytesToString = bytesToString2;
});

// node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js
var require_decodeAbiParameters = __commonJS((exports) => {
  function decodeAbiParameters2(params, data) {
    const bytes2 = typeof data === "string" ? (0, toBytes_js_1.hexToBytes)(data) : data;
    const cursor = (0, cursor_js_1.createCursor)(bytes2);
    if ((0, size_js_1.size)(bytes2) === 0 && params.length > 0)
      throw new abi_js_1.AbiDecodingZeroDataError;
    if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32)
      throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
        data: typeof data === "string" ? data : (0, toHex_js_1.bytesToHex)(data),
        params,
        size: (0, size_js_1.size)(data)
      });
    let consumed = 0;
    const values = [];
    for (let i = 0;i < params.length; ++i) {
      const param = params[i];
      cursor.setPosition(consumed);
      const [data2, consumed_] = decodeParameter2(cursor, param, {
        staticPosition: 0
      });
      consumed += consumed_;
      values.push(data2);
    }
    return values;
  }
  function decodeParameter2(cursor, param, { staticPosition }) {
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return decodeArray2(cursor, { ...param, type }, { length, staticPosition });
    }
    if (param.type === "tuple")
      return decodeTuple2(cursor, param, { staticPosition });
    if (param.type === "address")
      return decodeAddress2(cursor);
    if (param.type === "bool")
      return decodeBool2(cursor);
    if (param.type.startsWith("bytes"))
      return decodeBytes2(cursor, param, { staticPosition });
    if (param.type.startsWith("uint") || param.type.startsWith("int"))
      return decodeNumber2(cursor, param);
    if (param.type === "string")
      return decodeString2(cursor, { staticPosition });
    throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {
      docsPath: "/docs/contract/decodeAbiParameters"
    });
  }
  function decodeAddress2(cursor) {
    const value = cursor.readBytes(32);
    return [(0, getAddress_js_1.checksumAddress)((0, toHex_js_1.bytesToHex)((0, slice_js_1.sliceBytes)(value, -20))), 32];
  }
  function decodeArray2(cursor, param, { length, staticPosition }) {
    if (!length) {
      const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset2));
      const start = staticPosition + offset;
      const startOfData = start + sizeOfLength2;
      cursor.setPosition(start);
      const length2 = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfLength2));
      const dynamicChild = hasDynamicChild2(param);
      let consumed2 = 0;
      const value2 = [];
      for (let i = 0;i < length2; ++i) {
        cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
        const [data, consumed_] = decodeParameter2(cursor, param, {
          staticPosition: startOfData
        });
        consumed2 += consumed_;
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    if (hasDynamicChild2(param)) {
      const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset2));
      const start = staticPosition + offset;
      const value2 = [];
      for (let i = 0;i < length; ++i) {
        cursor.setPosition(start + i * 32);
        const [data] = decodeParameter2(cursor, param, {
          staticPosition: start
        });
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    let consumed = 0;
    const value = [];
    for (let i = 0;i < length; ++i) {
      const [data, consumed_] = decodeParameter2(cursor, param, {
        staticPosition: staticPosition + consumed
      });
      consumed += consumed_;
      value.push(data);
    }
    return [value, consumed];
  }
  function decodeBool2(cursor) {
    return [(0, fromBytes_js_1.bytesToBool)(cursor.readBytes(32), { size: 32 }), 32];
  }
  function decodeBytes2(cursor, param, { staticPosition }) {
    const [_, size2] = param.type.split("bytes");
    if (!size2) {
      const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
      cursor.setPosition(staticPosition + offset);
      const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
      if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return ["0x", 32];
      }
      const data = cursor.readBytes(length);
      cursor.setPosition(staticPosition + 32);
      return [(0, toHex_js_1.bytesToHex)(data), 32];
    }
    const value = (0, toHex_js_1.bytesToHex)(cursor.readBytes(parseInt(size2), 32));
    return [value, 32];
  }
  function decodeNumber2(cursor, param) {
    const signed = param.type.startsWith("int");
    const size2 = parseInt(param.type.split("int")[1] || "256");
    const value = cursor.readBytes(32);
    return [
      size2 > 48 ? (0, fromBytes_js_1.bytesToBigInt)(value, { signed }) : (0, fromBytes_js_1.bytesToNumber)(value, { signed }),
      32
    ];
  }
  function decodeTuple2(cursor, param, { staticPosition }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild2(param)) {
      const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset2));
      const start = staticPosition + offset;
      for (let i = 0;i < param.components.length; ++i) {
        const component = param.components[i];
        cursor.setPosition(start + consumed);
        const [data, consumed_] = decodeParameter2(cursor, component, {
          staticPosition: start
        });
        consumed += consumed_;
        value[hasUnnamedChild ? i : component?.name] = data;
      }
      cursor.setPosition(staticPosition + 32);
      return [value, 32];
    }
    for (let i = 0;i < param.components.length; ++i) {
      const component = param.components[i];
      const [data, consumed_] = decodeParameter2(cursor, component, {
        staticPosition
      });
      value[hasUnnamedChild ? i : component?.name] = data;
      consumed += consumed_;
    }
    return [value, consumed];
  }
  function decodeString2(cursor, { staticPosition }) {
    const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["", 32];
    }
    const data = cursor.readBytes(length, 32);
    const value = (0, fromBytes_js_1.bytesToString)((0, trim_js_1.trim)(data));
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  function hasDynamicChild2(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild2);
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents && hasDynamicChild2({ ...param, type: arrayComponents[1] }))
      return true;
    return false;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeAbiParameters = undefined;
  var abi_js_1 = require_abi();
  var getAddress_js_1 = require_getAddress();
  var cursor_js_1 = require_cursor2();
  var size_js_1 = require_size();
  var slice_js_1 = require_slice();
  var trim_js_1 = require_trim();
  var fromBytes_js_1 = require_fromBytes();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  exports.decodeAbiParameters = decodeAbiParameters2;
  var sizeOfLength2 = 32;
  var sizeOfOffset2 = 32;
});

// node_modules/viem/_cjs/utils/abi/decodeErrorResult.js
var require_decodeErrorResult = __commonJS((exports) => {
  function decodeErrorResult2(parameters) {
    const { abi, data } = parameters;
    const signature = (0, slice_js_1.slice)(data, 0, 4);
    if (signature === "0x")
      throw new abi_js_1.AbiDecodingZeroDataError;
    const abi_ = [...abi || [], solidity_js_1.solidityError, solidity_js_1.solidityPanic];
    const abiItem = abi_.find((x) => x.type === "error" && signature === (0, toFunctionSelector_js_1.toFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!abiItem)
      throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {
        docsPath: "/docs/contract/decodeErrorResult"
      });
    return {
      abiItem,
      args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4)) : undefined,
      errorName: abiItem.name
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeErrorResult = undefined;
  var solidity_js_1 = require_solidity();
  var abi_js_1 = require_abi();
  var slice_js_1 = require_slice();
  var toFunctionSelector_js_1 = require_toFunctionSelector();
  var decodeAbiParameters_js_1 = require_decodeAbiParameters();
  var formatAbiItem_js_1 = require_formatAbiItem2();
  exports.decodeErrorResult = decodeErrorResult2;
});

// node_modules/viem/_cjs/utils/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringify = undefined;
  var stringify2 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
    const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
    return typeof replacer === "function" ? replacer(key, value2) : value2;
  }, space);
  exports.stringify = stringify2;
});

// node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js
var require_formatAbiItemWithArgs = __commonJS((exports) => {
  function formatAbiItemWithArgs2({ abiItem, args, includeFunctionName = true, includeName = false }) {
    if (!("name" in abiItem))
      return;
    if (!("inputs" in abiItem))
      return;
    if (!abiItem.inputs)
      return;
    return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? (0, stringify_js_1.stringify)(args[i]) : args[i]}`).join(", ")})`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatAbiItemWithArgs = undefined;
  var stringify_js_1 = require_stringify();
  exports.formatAbiItemWithArgs = formatAbiItemWithArgs2;
});

// node_modules/viem/_cjs/constants/unit.js
var require_unit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.weiUnits = exports.gweiUnits = exports.etherUnits = undefined;
  exports.etherUnits = {
    gwei: 9,
    wei: 18
  };
  exports.gweiUnits = {
    ether: -9,
    wei: 9
  };
  exports.weiUnits = {
    ether: -18,
    gwei: -9
  };
});

// node_modules/viem/_cjs/utils/unit/formatUnits.js
var require_formatUnits = __commonJS((exports) => {
  function formatUnits2(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith("-");
    if (negative)
      display = display.slice(1);
    display = display.padStart(decimals, "0");
    let [integer, fraction] = [
      display.slice(0, display.length - decimals),
      display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, "");
    return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatUnits = undefined;
  exports.formatUnits = formatUnits2;
});

// node_modules/viem/_cjs/utils/unit/formatEther.js
var require_formatEther = __commonJS((exports) => {
  function formatEther2(wei, unit = "wei") {
    return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.etherUnits[unit]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatEther = undefined;
  var unit_js_1 = require_unit();
  var formatUnits_js_1 = require_formatUnits();
  exports.formatEther = formatEther2;
});

// node_modules/viem/_cjs/utils/unit/formatGwei.js
var require_formatGwei = __commonJS((exports) => {
  function formatGwei2(wei, unit = "wei") {
    return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.gweiUnits[unit]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatGwei = undefined;
  var unit_js_1 = require_unit();
  var formatUnits_js_1 = require_formatUnits();
  exports.formatGwei = formatGwei2;
});

// node_modules/viem/_cjs/errors/stateOverride.js
var require_stateOverride = __commonJS((exports) => {
  function prettyStateMapping2(stateMapping) {
    return stateMapping.reduce((pretty, { slot, value }) => {
      return `${pretty}        ${slot}: ${value}\n`;
    }, "");
  }
  function prettyStateOverride2(stateOverride) {
    return stateOverride.reduce((pretty, { address, ...state }) => {
      let val = `${pretty}    ${address}:\n`;
      if (state.nonce)
        val += `      nonce: ${state.nonce}\n`;
      if (state.balance)
        val += `      balance: ${state.balance}\n`;
      if (state.code)
        val += `      code: ${state.code}\n`;
      if (state.state) {
        val += "      state:\n";
        val += prettyStateMapping2(state.state);
      }
      if (state.stateDiff) {
        val += "      stateDiff:\n";
        val += prettyStateMapping2(state.stateDiff);
      }
      return val;
    }, "  State Override:\n").slice(0, -1);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prettyStateOverride = exports.prettyStateMapping = exports.StateAssignmentConflictError = exports.AccountStateConflictError = undefined;
  var base_js_1 = require_base();

  class AccountStateConflictError2 extends base_js_1.BaseError {
    constructor({ address }) {
      super(`State for account "${address}" is set multiple times.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AccountStateConflictError"
      });
    }
  }
  exports.AccountStateConflictError = AccountStateConflictError2;

  class StateAssignmentConflictError2 extends base_js_1.BaseError {
    constructor() {
      super("state and stateDiff are set on the same account.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "StateAssignmentConflictError"
      });
    }
  }
  exports.StateAssignmentConflictError = StateAssignmentConflictError2;
  exports.prettyStateMapping = prettyStateMapping2;
  exports.prettyStateOverride = prettyStateOverride2;
});

// node_modules/viem/_cjs/errors/transaction.js
var require_transaction2 = __commonJS((exports) => {
  function prettyPrint2(args) {
    const entries = Object.entries(args).map(([key, value]) => {
      if (value === undefined || value === false)
        return null;
      return [key, value];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.prettyPrint = undefined;
  var formatEther_js_1 = require_formatEther();
  var formatGwei_js_1 = require_formatGwei();
  var base_js_1 = require_base();
  exports.prettyPrint = prettyPrint2;

  class FeeConflictError2 extends base_js_1.BaseError {
    constructor() {
      super([
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FeeConflictError"
      });
    }
  }
  exports.FeeConflictError = FeeConflictError2;

  class InvalidLegacyVError extends base_js_1.BaseError {
    constructor({ v }) {
      super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidLegacyVError"
      });
    }
  }
  exports.InvalidLegacyVError = InvalidLegacyVError;

  class InvalidSerializableTransactionError2 extends base_js_1.BaseError {
    constructor({ transaction }) {
      super("Cannot infer a transaction type from provided transaction.", {
        metaMessages: [
          "Provided Transaction:",
          "{",
          prettyPrint2(transaction),
          "}",
          "",
          "To infer the type, either provide:",
          "- a `type` to the Transaction, or",
          "- an EIP-1559 Transaction with `maxFeePerGas`, or",
          "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
          "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
          "- a Legacy Transaction with `gasPrice`"
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSerializableTransactionError"
      });
    }
  }
  exports.InvalidSerializableTransactionError = InvalidSerializableTransactionError2;

  class InvalidSerializedTransactionTypeError extends base_js_1.BaseError {
    constructor({ serializedType }) {
      super(`Serialized transaction type "${serializedType}" is invalid.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSerializedTransactionType"
      });
      Object.defineProperty(this, "serializedType", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.serializedType = serializedType;
    }
  }
  exports.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;

  class InvalidSerializedTransactionError extends base_js_1.BaseError {
    constructor({ attributes, serializedTransaction, type }) {
      const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : undefined).filter(Boolean);
      super(`Invalid serialized transaction of type "${type}" was provided.`, {
        metaMessages: [
          `Serialized Transaction: "${serializedTransaction}"`,
          missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
        ].filter(Boolean)
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSerializedTransactionError"
      });
      Object.defineProperty(this, "serializedTransaction", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "type", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.serializedTransaction = serializedTransaction;
      this.type = type;
    }
  }
  exports.InvalidSerializedTransactionError = InvalidSerializedTransactionError;

  class InvalidStorageKeySizeError extends base_js_1.BaseError {
    constructor({ storageKey }) {
      super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidStorageKeySizeError"
      });
    }
  }
  exports.InvalidStorageKeySizeError = InvalidStorageKeySizeError;

  class TransactionExecutionError2 extends base_js_1.BaseError {
    constructor(cause, { account, docsPath: docsPath5, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
      const prettyArgs = prettyPrint2({
        chain: chain && `${chain?.name} (id: ${chain?.id})`,
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath5,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Request Arguments:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionExecutionError"
      });
      this.cause = cause;
    }
  }
  exports.TransactionExecutionError = TransactionExecutionError2;

  class TransactionNotFoundError extends base_js_1.BaseError {
    constructor({ blockHash, blockNumber, blockTag, hash: hash2, index }) {
      let identifier = "Transaction";
      if (blockTag && index !== undefined)
        identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
      if (blockHash && index !== undefined)
        identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
      if (blockNumber && index !== undefined)
        identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
      if (hash2)
        identifier = `Transaction with hash "${hash2}"`;
      super(`${identifier} could not be found.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionNotFoundError"
      });
    }
  }
  exports.TransactionNotFoundError = TransactionNotFoundError;

  class TransactionReceiptNotFoundError extends base_js_1.BaseError {
    constructor({ hash: hash2 }) {
      super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionReceiptNotFoundError"
      });
    }
  }
  exports.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;

  class WaitForTransactionReceiptTimeoutError extends base_js_1.BaseError {
    constructor({ hash: hash2 }) {
      super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "WaitForTransactionReceiptTimeoutError"
      });
    }
  }
  exports.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;
});

// node_modules/viem/_cjs/errors/contract.js
var require_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var solidity_js_1 = require_solidity();
  var decodeErrorResult_js_1 = require_decodeErrorResult();
  var formatAbiItem_js_1 = require_formatAbiItem2();
  var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
  var getAbiItem_js_1 = require_getAbiItem();
  var formatEther_js_1 = require_formatEther();
  var formatGwei_js_1 = require_formatGwei();
  var abi_js_1 = require_abi();
  var base_js_1 = require_base();
  var stateOverride_js_1 = require_stateOverride();
  var transaction_js_1 = require_transaction2();
  var utils_js_1 = require_utils();

  class CallExecutionError2 extends base_js_1.BaseError {
    constructor(cause, { account: account_, docsPath: docsPath5, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
      let prettyArgs = (0, transaction_js_1.prettyPrint)({
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      if (stateOverride) {
        prettyArgs += `\n${(0, stateOverride_js_1.prettyStateOverride)(stateOverride)}`;
      }
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath5,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Raw Call Arguments:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CallExecutionError"
      });
      this.cause = cause;
    }
  }
  exports.CallExecutionError = CallExecutionError2;

  class ContractFunctionExecutionError2 extends base_js_1.BaseError {
    constructor(cause, { abi, args, contractAddress, docsPath: docsPath5, functionName, sender }) {
      const abiItem = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
      const formattedArgs = abiItem ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
        abiItem,
        args,
        includeFunctionName: false,
        includeName: false
      }) : undefined;
      const functionWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : undefined;
      const prettyArgs = (0, transaction_js_1.prettyPrint)({
        address: contractAddress && (0, utils_js_1.getContractAddress)(contractAddress),
        function: functionWithParams,
        args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
        sender
      });
      super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
        cause,
        docsPath: docsPath5,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Contract Call:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "abi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "args", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "contractAddress", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "formattedArgs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "functionName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "sender", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ContractFunctionExecutionError"
      });
      this.abi = abi;
      this.args = args;
      this.cause = cause;
      this.contractAddress = contractAddress;
      this.functionName = functionName;
      this.sender = sender;
    }
  }
  exports.ContractFunctionExecutionError = ContractFunctionExecutionError2;

  class ContractFunctionRevertedError2 extends base_js_1.BaseError {
    constructor({ abi, data, functionName, message }) {
      let cause;
      let decodedData = undefined;
      let metaMessages;
      let reason;
      if (data && data !== "0x") {
        try {
          decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
          const { abiItem, errorName, args: errorArgs } = decodedData;
          if (errorName === "Error") {
            reason = errorArgs[0];
          } else if (errorName === "Panic") {
            const [firstArg] = errorArgs;
            reason = solidity_js_1.panicReasons[firstArg];
          } else {
            const errorWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : undefined;
            const formattedArgs = abiItem && errorArgs ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
              abiItem,
              args: errorArgs,
              includeFunctionName: false,
              includeName: false
            }) : undefined;
            metaMessages = [
              errorWithParams ? `Error: ${errorWithParams}` : "",
              formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
            ];
          }
        } catch (err) {
          cause = err;
        }
      } else if (message)
        reason = message;
      let signature;
      if (cause instanceof abi_js_1.AbiErrorSignatureNotFoundError) {
        signature = cause.signature;
        metaMessages = [
          `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ];
      }
      super(reason && reason !== "execution reverted" || signature ? [
        `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
        reason || signature
      ].join("\n") : `The contract function "${functionName}" reverted.`, {
        cause,
        metaMessages
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ContractFunctionRevertedError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "reason", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = decodedData;
      this.reason = reason;
      this.signature = signature;
    }
  }
  exports.ContractFunctionRevertedError = ContractFunctionRevertedError2;

  class ContractFunctionZeroDataError2 extends base_js_1.BaseError {
    constructor({ functionName }) {
      super(`The contract function "${functionName}" returned no data ("0x").`, {
        metaMessages: [
          "This could be due to any of the following:",
          `  - The contract does not have the function "${functionName}",`,
          "  - The parameters passed to the contract function may be invalid, or",
          "  - The address is not a contract."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ContractFunctionZeroDataError"
      });
    }
  }
  exports.ContractFunctionZeroDataError = ContractFunctionZeroDataError2;

  class RawContractError2 extends base_js_1.BaseError {
    constructor({ data, message }) {
      super(message || "");
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RawContractError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
    }
  }
  exports.RawContractError = RawContractError2;
});

// node_modules/viem/_cjs/errors/request.js
var require_request = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeoutError = exports.RpcRequestError = exports.WebSocketRequestError = exports.HttpRequestError = undefined;
  var stringify_js_1 = require_stringify();
  var base_js_1 = require_base();
  var utils_js_1 = require_utils();

  class HttpRequestError2 extends base_js_1.BaseError {
    constructor({ body, details, headers, status, url }) {
      super("HTTP request failed.", {
        details,
        metaMessages: [
          status && `Status: ${status}`,
          `URL: ${(0, utils_js_1.getUrl)(url)}`,
          body && `Request body: ${(0, stringify_js_1.stringify)(body)}`
        ].filter(Boolean)
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "HttpRequestError"
      });
      Object.defineProperty(this, "body", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "headers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "status", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "url", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.body = body;
      this.headers = headers;
      this.status = status;
      this.url = url;
    }
  }
  exports.HttpRequestError = HttpRequestError2;

  class WebSocketRequestError extends base_js_1.BaseError {
    constructor({ body, details, url }) {
      super("WebSocket request failed.", {
        details,
        metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "WebSocketRequestError"
      });
    }
  }
  exports.WebSocketRequestError = WebSocketRequestError;

  class RpcRequestError2 extends base_js_1.BaseError {
    constructor({ body, error, url }) {
      super("RPC Request failed.", {
        cause: error,
        details: error.message,
        metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RpcRequestError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.code = error.code;
    }
  }
  exports.RpcRequestError = RpcRequestError2;

  class TimeoutError extends base_js_1.BaseError {
    constructor({ body, url }) {
      super("The request took too long to respond.", {
        details: "The request timed out.",
        metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TimeoutError"
      });
    }
  }
  exports.TimeoutError = TimeoutError;
});

// node_modules/viem/_cjs/errors/rpc.js
var require_rpc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnknownRpcError = exports.SwitchChainError = exports.ChainDisconnectedError = exports.ProviderDisconnectedError = exports.UnsupportedProviderMethodError = exports.UnauthorizedProviderError = exports.UserRejectedRequestError = exports.JsonRpcVersionUnsupportedError = exports.LimitExceededRpcError = exports.MethodNotSupportedRpcError = exports.TransactionRejectedRpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.InvalidParamsRpcError = exports.MethodNotFoundRpcError = exports.InvalidRequestRpcError = exports.ParseRpcError = exports.ProviderRpcError = exports.RpcError = undefined;
  var base_js_1 = require_base();
  var request_js_1 = require_request();
  var unknownErrorCode2 = -1;

  class RpcError2 extends base_js_1.BaseError {
    constructor(cause, { code, docsPath: docsPath5, metaMessages, shortMessage }) {
      super(shortMessage, {
        cause,
        docsPath: docsPath5,
        metaMessages: metaMessages || cause?.metaMessages
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RpcError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.name = cause.name;
      this.code = cause instanceof request_js_1.RpcRequestError ? cause.code : code ?? unknownErrorCode2;
    }
  }
  exports.RpcError = RpcError2;

  class ProviderRpcError2 extends RpcError2 {
    constructor(cause, options2) {
      super(cause, options2);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ProviderRpcError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = options2.data;
    }
  }
  exports.ProviderRpcError = ProviderRpcError2;

  class ParseRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: ParseRpcError2.code,
        shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ParseRpcError"
      });
    }
  }
  exports.ParseRpcError = ParseRpcError2;
  Object.defineProperty(ParseRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
  });

  class InvalidRequestRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: InvalidRequestRpcError2.code,
        shortMessage: "JSON is not a valid request object."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidRequestRpcError"
      });
    }
  }
  exports.InvalidRequestRpcError = InvalidRequestRpcError2;
  Object.defineProperty(InvalidRequestRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
  });

  class MethodNotFoundRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: MethodNotFoundRpcError2.code,
        shortMessage: "The method does not exist / is not available."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "MethodNotFoundRpcError"
      });
    }
  }
  exports.MethodNotFoundRpcError = MethodNotFoundRpcError2;
  Object.defineProperty(MethodNotFoundRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
  });

  class InvalidParamsRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: InvalidParamsRpcError2.code,
        shortMessage: [
          "Invalid parameters were provided to the RPC method.",
          "Double check you have provided the correct parameters."
        ].join("\n")
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParamsRpcError"
      });
    }
  }
  exports.InvalidParamsRpcError = InvalidParamsRpcError2;
  Object.defineProperty(InvalidParamsRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
  });

  class InternalRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: InternalRpcError2.code,
        shortMessage: "An internal error was received."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InternalRpcError"
      });
    }
  }
  exports.InternalRpcError = InternalRpcError2;
  Object.defineProperty(InternalRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
  });

  class InvalidInputRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: InvalidInputRpcError2.code,
        shortMessage: [
          "Missing or invalid parameters.",
          "Double check you have provided the correct parameters."
        ].join("\n")
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidInputRpcError"
      });
    }
  }
  exports.InvalidInputRpcError = InvalidInputRpcError2;
  Object.defineProperty(InvalidInputRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
  });

  class ResourceNotFoundRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: ResourceNotFoundRpcError2.code,
        shortMessage: "Requested resource not found."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ResourceNotFoundRpcError"
      });
    }
  }
  exports.ResourceNotFoundRpcError = ResourceNotFoundRpcError2;
  Object.defineProperty(ResourceNotFoundRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
  });

  class ResourceUnavailableRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: ResourceUnavailableRpcError2.code,
        shortMessage: "Requested resource not available."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ResourceUnavailableRpcError"
      });
    }
  }
  exports.ResourceUnavailableRpcError = ResourceUnavailableRpcError2;
  Object.defineProperty(ResourceUnavailableRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
  });

  class TransactionRejectedRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: TransactionRejectedRpcError2.code,
        shortMessage: "Transaction creation failed."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionRejectedRpcError"
      });
    }
  }
  exports.TransactionRejectedRpcError = TransactionRejectedRpcError2;
  Object.defineProperty(TransactionRejectedRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
  });

  class MethodNotSupportedRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: MethodNotSupportedRpcError2.code,
        shortMessage: "Method is not implemented."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "MethodNotSupportedRpcError"
      });
    }
  }
  exports.MethodNotSupportedRpcError = MethodNotSupportedRpcError2;
  Object.defineProperty(MethodNotSupportedRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
  });

  class LimitExceededRpcError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: LimitExceededRpcError2.code,
        shortMessage: "Request exceeds defined limit."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "LimitExceededRpcError"
      });
    }
  }
  exports.LimitExceededRpcError = LimitExceededRpcError2;
  Object.defineProperty(LimitExceededRpcError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
  });

  class JsonRpcVersionUnsupportedError2 extends RpcError2 {
    constructor(cause) {
      super(cause, {
        code: JsonRpcVersionUnsupportedError2.code,
        shortMessage: "Version of JSON-RPC protocol is not supported."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "JsonRpcVersionUnsupportedError"
      });
    }
  }
  exports.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError2;
  Object.defineProperty(JsonRpcVersionUnsupportedError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
  });

  class UserRejectedRequestError2 extends ProviderRpcError2 {
    constructor(cause) {
      super(cause, {
        code: UserRejectedRequestError2.code,
        shortMessage: "User rejected the request."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UserRejectedRequestError"
      });
    }
  }
  exports.UserRejectedRequestError = UserRejectedRequestError2;
  Object.defineProperty(UserRejectedRequestError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
  });

  class UnauthorizedProviderError2 extends ProviderRpcError2 {
    constructor(cause) {
      super(cause, {
        code: UnauthorizedProviderError2.code,
        shortMessage: "The requested method and/or account has not been authorized by the user."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnauthorizedProviderError"
      });
    }
  }
  exports.UnauthorizedProviderError = UnauthorizedProviderError2;
  Object.defineProperty(UnauthorizedProviderError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
  });

  class UnsupportedProviderMethodError2 extends ProviderRpcError2 {
    constructor(cause) {
      super(cause, {
        code: UnsupportedProviderMethodError2.code,
        shortMessage: "The Provider does not support the requested method."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnsupportedProviderMethodError"
      });
    }
  }
  exports.UnsupportedProviderMethodError = UnsupportedProviderMethodError2;
  Object.defineProperty(UnsupportedProviderMethodError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
  });

  class ProviderDisconnectedError2 extends ProviderRpcError2 {
    constructor(cause) {
      super(cause, {
        code: ProviderDisconnectedError2.code,
        shortMessage: "The Provider is disconnected from all chains."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ProviderDisconnectedError"
      });
    }
  }
  exports.ProviderDisconnectedError = ProviderDisconnectedError2;
  Object.defineProperty(ProviderDisconnectedError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
  });

  class ChainDisconnectedError2 extends ProviderRpcError2 {
    constructor(cause) {
      super(cause, {
        code: ChainDisconnectedError2.code,
        shortMessage: "The Provider is not connected to the requested chain."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainDisconnectedError"
      });
    }
  }
  exports.ChainDisconnectedError = ChainDisconnectedError2;
  Object.defineProperty(ChainDisconnectedError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
  });

  class SwitchChainError2 extends ProviderRpcError2 {
    constructor(cause) {
      super(cause, {
        code: SwitchChainError2.code,
        shortMessage: "An error occurred when attempting to switch chain."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SwitchChainError"
      });
    }
  }
  exports.SwitchChainError = SwitchChainError2;
  Object.defineProperty(SwitchChainError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
  });

  class UnknownRpcError extends RpcError2 {
    constructor(cause) {
      super(cause, {
        shortMessage: "An unknown RPC error occurred."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownRpcError"
      });
    }
  }
  exports.UnknownRpcError = UnknownRpcError;
});

// node_modules/viem/_cjs/utils/errors/getContractError.js
var require_getContractError = __commonJS((exports) => {
  function getContractError2(err, { abi, address, args, docsPath: docsPath5, functionName, sender }) {
    const { code, data, message, shortMessage } = err instanceof contract_js_1.RawContractError ? err : err instanceof base_js_1.BaseError ? err.walk((err2) => ("data" in err2)) || err.walk() : {};
    const cause = (() => {
      if (err instanceof abi_js_1.AbiDecodingZeroDataError)
        return new contract_js_1.ContractFunctionZeroDataError({ functionName });
      if ([EXECUTION_REVERTED_ERROR_CODE2, rpc_js_1.InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
        return new contract_js_1.ContractFunctionRevertedError({
          abi,
          data: typeof data === "object" ? data.data : data,
          functionName,
          message: shortMessage ?? message
        });
      }
      return err;
    })();
    return new contract_js_1.ContractFunctionExecutionError(cause, {
      abi,
      args,
      contractAddress: address,
      docsPath: docsPath5,
      functionName,
      sender
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getContractError = undefined;
  var abi_js_1 = require_abi();
  var base_js_1 = require_base();
  var contract_js_1 = require_contract();
  var rpc_js_1 = require_rpc();
  var EXECUTION_REVERTED_ERROR_CODE2 = 3;
  exports.getContractError = getContractError2;
});

// node_modules/viem/_cjs/errors/estimateGas.js
var require_estimateGas = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EstimateGasExecutionError = undefined;
  var formatEther_js_1 = require_formatEther();
  var formatGwei_js_1 = require_formatGwei();
  var base_js_1 = require_base();
  var transaction_js_1 = require_transaction2();

  class EstimateGasExecutionError2 extends base_js_1.BaseError {
    constructor(cause, { account, docsPath: docsPath5, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
      const prettyArgs = (0, transaction_js_1.prettyPrint)({
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath5,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Estimate Gas Arguments:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EstimateGasExecutionError"
      });
      this.cause = cause;
    }
  }
  exports.EstimateGasExecutionError = EstimateGasExecutionError2;
});

// node_modules/viem/_cjs/errors/node.js
var require_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnknownNodeError = exports.TipAboveFeeCapError = exports.TransactionTypeNotSupportedError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.NonceMaxValueError = exports.NonceTooLowError = exports.NonceTooHighError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = undefined;
  var formatGwei_js_1 = require_formatGwei();
  var base_js_1 = require_base();

  class ExecutionRevertedError2 extends base_js_1.BaseError {
    constructor({ cause, message } = {}) {
      const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
      super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ExecutionRevertedError"
      });
    }
  }
  exports.ExecutionRevertedError = ExecutionRevertedError2;
  Object.defineProperty(ExecutionRevertedError2, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
  });
  Object.defineProperty(ExecutionRevertedError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
  });

  class FeeCapTooHighError2 extends base_js_1.BaseError {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FeeCapTooHigh"
      });
    }
  }
  exports.FeeCapTooHighError = FeeCapTooHighError2;
  Object.defineProperty(FeeCapTooHighError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  });

  class FeeCapTooLowError2 extends base_js_1.BaseError {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FeeCapTooLow"
      });
    }
  }
  exports.FeeCapTooLowError = FeeCapTooLowError2;
  Object.defineProperty(FeeCapTooLowError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  });

  class NonceTooHighError2 extends base_js_1.BaseError {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NonceTooHighError"
      });
    }
  }
  exports.NonceTooHighError = NonceTooHighError2;
  Object.defineProperty(NonceTooHighError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
  });

  class NonceTooLowError2 extends base_js_1.BaseError {
    constructor({ cause, nonce } = {}) {
      super([
        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
      ].join("\n"), { cause });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NonceTooLowError"
      });
    }
  }
  exports.NonceTooLowError = NonceTooLowError2;
  Object.defineProperty(NonceTooLowError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
  });

  class NonceMaxValueError2 extends base_js_1.BaseError {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "NonceMaxValueError"
      });
    }
  }
  exports.NonceMaxValueError = NonceMaxValueError2;
  Object.defineProperty(NonceMaxValueError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
  });

  class InsufficientFundsError2 extends base_js_1.BaseError {
    constructor({ cause } = {}) {
      super([
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
      ].join("\n"), {
        cause,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InsufficientFundsError"
      });
    }
  }
  exports.InsufficientFundsError = InsufficientFundsError2;
  Object.defineProperty(InsufficientFundsError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds/
  });

  class IntrinsicGasTooHighError2 extends base_js_1.BaseError {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "IntrinsicGasTooHighError"
      });
    }
  }
  exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError2;
  Object.defineProperty(IntrinsicGasTooHighError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
  });

  class IntrinsicGasTooLowError2 extends base_js_1.BaseError {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "IntrinsicGasTooLowError"
      });
    }
  }
  exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError2;
  Object.defineProperty(IntrinsicGasTooLowError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
  });

  class TransactionTypeNotSupportedError2 extends base_js_1.BaseError {
    constructor({ cause }) {
      super("The transaction type is not supported for this chain.", {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TransactionTypeNotSupportedError"
      });
    }
  }
  exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError2;
  Object.defineProperty(TransactionTypeNotSupportedError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
  });

  class TipAboveFeeCapError2 extends base_js_1.BaseError {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
      super([
        `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}).`
      ].join("\n"), {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "TipAboveFeeCapError"
      });
    }
  }
  exports.TipAboveFeeCapError = TipAboveFeeCapError2;
  Object.defineProperty(TipAboveFeeCapError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  });

  class UnknownNodeError2 extends base_js_1.BaseError {
    constructor({ cause }) {
      super(`An error occurred while executing: ${cause?.shortMessage}`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownNodeError"
      });
    }
  }
  exports.UnknownNodeError = UnknownNodeError2;
});

// node_modules/viem/_cjs/utils/errors/getNodeError.js
var require_getNodeError = __commonJS((exports) => {
  function containsNodeError(err) {
    return err instanceof rpc_js_1.TransactionRejectedRpcError || err instanceof rpc_js_1.InvalidInputRpcError || err instanceof request_js_1.RpcRequestError && err.code === node_js_1.ExecutionRevertedError.code;
  }
  function getNodeError2(err, args) {
    const message = (err.details || "").toLowerCase();
    const executionRevertedError = err instanceof base_js_1.BaseError ? err.walk((e) => e.code === node_js_1.ExecutionRevertedError.code) : err;
    if (executionRevertedError instanceof base_js_1.BaseError) {
      return new node_js_1.ExecutionRevertedError({
        cause: err,
        message: executionRevertedError.details
      });
    }
    if (node_js_1.ExecutionRevertedError.nodeMessage.test(message))
      return new node_js_1.ExecutionRevertedError({
        cause: err,
        message: err.details
      });
    if (node_js_1.FeeCapTooHighError.nodeMessage.test(message))
      return new node_js_1.FeeCapTooHighError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    if (node_js_1.FeeCapTooLowError.nodeMessage.test(message))
      return new node_js_1.FeeCapTooLowError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    if (node_js_1.NonceTooHighError.nodeMessage.test(message))
      return new node_js_1.NonceTooHighError({ cause: err, nonce: args?.nonce });
    if (node_js_1.NonceTooLowError.nodeMessage.test(message))
      return new node_js_1.NonceTooLowError({ cause: err, nonce: args?.nonce });
    if (node_js_1.NonceMaxValueError.nodeMessage.test(message))
      return new node_js_1.NonceMaxValueError({ cause: err, nonce: args?.nonce });
    if (node_js_1.InsufficientFundsError.nodeMessage.test(message))
      return new node_js_1.InsufficientFundsError({ cause: err });
    if (node_js_1.IntrinsicGasTooHighError.nodeMessage.test(message))
      return new node_js_1.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
    if (node_js_1.IntrinsicGasTooLowError.nodeMessage.test(message))
      return new node_js_1.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
    if (node_js_1.TransactionTypeNotSupportedError.nodeMessage.test(message))
      return new node_js_1.TransactionTypeNotSupportedError({ cause: err });
    if (node_js_1.TipAboveFeeCapError.nodeMessage.test(message))
      return new node_js_1.TipAboveFeeCapError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas,
        maxPriorityFeePerGas: args?.maxPriorityFeePerGas
      });
    return new node_js_1.UnknownNodeError({
      cause: err
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getNodeError = exports.containsNodeError = undefined;
  var base_js_1 = require_base();
  var node_js_1 = require_node();
  var request_js_1 = require_request();
  var rpc_js_1 = require_rpc();
  exports.containsNodeError = containsNodeError;
  exports.getNodeError = getNodeError2;
});

// node_modules/viem/_cjs/utils/errors/getEstimateGasError.js
var require_getEstimateGasError = __commonJS((exports) => {
  function getEstimateGasError2(err, { docsPath: docsPath5, ...args }) {
    const cause = (() => {
      const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
      if (cause2 instanceof node_js_1.UnknownNodeError)
        return err;
      return cause2;
    })();
    return new estimateGas_js_1.EstimateGasExecutionError(cause, {
      docsPath: docsPath5,
      ...args
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEstimateGasError = undefined;
  var estimateGas_js_1 = require_estimateGas();
  var node_js_1 = require_node();
  var getNodeError_js_1 = require_getNodeError();
  exports.getEstimateGasError = getEstimateGasError2;
});

// node_modules/viem/_cjs/utils/formatters/extract.js
var require_extract = __commonJS((exports) => {
  function extract2(value_, { format }) {
    if (!format)
      return {};
    const value = {};
    function extract_(formatted2) {
      const keys = Object.keys(formatted2);
      for (const key of keys) {
        if (key in value_)
          value[key] = value_[key];
        if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
          extract_(formatted2[key]);
      }
    }
    const formatted = format(value_ || {});
    extract_(formatted);
    return value;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extract = undefined;
  exports.extract = extract2;
});

// node_modules/viem/_cjs/utils/formatters/transactionRequest.js
var require_transactionRequest = __commonJS((exports) => {
  function formatTransactionRequest2(request) {
    const rpcRequest = {};
    if (typeof request.accessList !== "undefined")
      rpcRequest.accessList = request.accessList;
    if (typeof request.blobVersionedHashes !== "undefined")
      rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
    if (typeof request.blobs !== "undefined") {
      if (typeof request.blobs[0] !== "string")
        rpcRequest.blobs = request.blobs.map((x) => (0, toHex_js_1.bytesToHex)(x));
      else
        rpcRequest.blobs = request.blobs;
    }
    if (typeof request.data !== "undefined")
      rpcRequest.data = request.data;
    if (typeof request.from !== "undefined")
      rpcRequest.from = request.from;
    if (typeof request.gas !== "undefined")
      rpcRequest.gas = (0, toHex_js_1.numberToHex)(request.gas);
    if (typeof request.gasPrice !== "undefined")
      rpcRequest.gasPrice = (0, toHex_js_1.numberToHex)(request.gasPrice);
    if (typeof request.maxFeePerBlobGas !== "undefined")
      rpcRequest.maxFeePerBlobGas = (0, toHex_js_1.numberToHex)(request.maxFeePerBlobGas);
    if (typeof request.maxFeePerGas !== "undefined")
      rpcRequest.maxFeePerGas = (0, toHex_js_1.numberToHex)(request.maxFeePerGas);
    if (typeof request.maxPriorityFeePerGas !== "undefined")
      rpcRequest.maxPriorityFeePerGas = (0, toHex_js_1.numberToHex)(request.maxPriorityFeePerGas);
    if (typeof request.nonce !== "undefined")
      rpcRequest.nonce = (0, toHex_js_1.numberToHex)(request.nonce);
    if (typeof request.to !== "undefined")
      rpcRequest.to = request.to;
    if (typeof request.type !== "undefined")
      rpcRequest.type = exports.rpcTransactionType[request.type];
    if (typeof request.value !== "undefined")
      rpcRequest.value = (0, toHex_js_1.numberToHex)(request.value);
    return rpcRequest;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineTransactionRequest = exports.formatTransactionRequest = exports.rpcTransactionType = undefined;
  var toHex_js_1 = require_toHex();
  var formatter_js_1 = require_formatter();
  exports.rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2",
    eip4844: "0x3"
  };
  exports.formatTransactionRequest = formatTransactionRequest2;
  exports.defineTransactionRequest = (0, formatter_js_1.defineFormatter)("transactionRequest", formatTransactionRequest2);
});

// node_modules/viem/_cjs/utils/transaction/assertRequest.js
var require_assertRequest = __commonJS((exports) => {
  function assertRequest2(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    if (account && !(0, isAddress_js_1.isAddress)(account.address))
      throw new address_js_1.InvalidAddressError({ address: account.address });
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
    if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
      throw new transaction_js_1.FeeConflictError;
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
      throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertRequest = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var address_js_1 = require_address();
  var node_js_1 = require_node();
  var transaction_js_1 = require_transaction2();
  var isAddress_js_1 = require_isAddress();
  exports.assertRequest = assertRequest2;
});

// node_modules/viem/_cjs/errors/fee.js
var require_fee = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = undefined;
  var formatGwei_js_1 = require_formatGwei();
  var base_js_1 = require_base();

  class BaseFeeScalarError2 extends base_js_1.BaseError {
    constructor() {
      super("`baseFeeMultiplier` must be greater than 1.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseFeeScalarError"
      });
    }
  }
  exports.BaseFeeScalarError = BaseFeeScalarError2;

  class Eip1559FeesNotSupportedError2 extends base_js_1.BaseError {
    constructor() {
      super("Chain does not support EIP-1559 fees.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Eip1559FeesNotSupportedError"
      });
    }
  }
  exports.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError2;

  class MaxFeePerGasTooLowError2 extends base_js_1.BaseError {
    constructor({ maxPriorityFeePerGas }) {
      super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "MaxFeePerGasTooLowError"
      });
    }
  }
  exports.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError2;
});

// node_modules/viem/_cjs/errors/block.js
var require_block2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlockNotFoundError = undefined;
  var base_js_1 = require_base();

  class BlockNotFoundError2 extends base_js_1.BaseError {
    constructor({ blockHash, blockNumber }) {
      let identifier = "Block";
      if (blockHash)
        identifier = `Block at hash "${blockHash}"`;
      if (blockNumber)
        identifier = `Block at number "${blockNumber}"`;
      super(`${identifier} could not be found.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BlockNotFoundError"
      });
    }
  }
  exports.BlockNotFoundError = BlockNotFoundError2;
});

// node_modules/viem/_cjs/actions/public/getBlock.js
var require_getBlock = __commonJS((exports) => {
  async function getBlock2(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
    const blockTag = blockTag_ ?? "latest";
    const includeTransactions = includeTransactions_ ?? false;
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let block = null;
    if (blockHash) {
      block = await client.request({
        method: "eth_getBlockByHash",
        params: [blockHash, includeTransactions]
      });
    } else {
      block = await client.request({
        method: "eth_getBlockByNumber",
        params: [blockNumberHex || blockTag, includeTransactions]
      });
    }
    if (!block)
      throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
    const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
    return format(block);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBlock = undefined;
  var block_js_1 = require_block2();
  var toHex_js_1 = require_toHex();
  var block_js_2 = require_block();
  exports.getBlock = getBlock2;
});

// node_modules/viem/_cjs/actions/public/getGasPrice.js
var require_getGasPrice = __commonJS((exports) => {
  async function getGasPrice2(client) {
    const gasPrice = await client.request({
      method: "eth_gasPrice"
    });
    return BigInt(gasPrice);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getGasPrice = undefined;
  exports.getGasPrice = getGasPrice2;
});

// node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js
var require_estimateMaxPriorityFeePerGas = __commonJS((exports) => {
  async function estimateMaxPriorityFeePerGas(client, args) {
    return internal_estimateMaxPriorityFeePerGas2(client, args);
  }
  async function internal_estimateMaxPriorityFeePerGas2(client, args) {
    const { block: block_, chain = client.chain, request } = args || {};
    if (typeof chain?.fees?.defaultPriorityFee === "function") {
      const block = block_ || await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({});
      return chain.fees.defaultPriorityFee({
        block,
        client,
        request
      });
    }
    if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
      return chain?.fees?.defaultPriorityFee;
    try {
      const maxPriorityFeePerGasHex = await client.request({
        method: "eth_maxPriorityFeePerGas"
      });
      return (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGasHex);
    } catch {
      const [block, gasPrice] = await Promise.all([
        block_ ? Promise.resolve(block_) : (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({}),
        (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, "getGasPrice")({})
      ]);
      if (typeof block.baseFeePerGas !== "bigint")
        throw new fee_js_1.Eip1559FeesNotSupportedError;
      const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
      if (maxPriorityFeePerGas < 0n)
        return 0n;
      return maxPriorityFeePerGas;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.internal_estimateMaxPriorityFeePerGas = exports.estimateMaxPriorityFeePerGas = undefined;
  var fee_js_1 = require_fee();
  var fromHex_js_1 = require_fromHex();
  var getAction_js_1 = require_getAction();
  var getBlock_js_1 = require_getBlock();
  var getGasPrice_js_1 = require_getGasPrice();
  exports.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
  exports.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas2;
});

// node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js
var require_estimateFeesPerGas = __commonJS((exports) => {
  async function estimateFeesPerGas(client, args) {
    return internal_estimateFeesPerGas2(client, args);
  }
  async function internal_estimateFeesPerGas2(client, args) {
    const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
    const baseFeeMultiplier = await (async () => {
      if (typeof chain?.fees?.baseFeeMultiplier === "function")
        return chain.fees.baseFeeMultiplier({
          block: block_,
          client,
          request
        });
      return chain?.fees?.baseFeeMultiplier ?? 1.2;
    })();
    if (baseFeeMultiplier < 1)
      throw new fee_js_1.BaseFeeScalarError;
    const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
    const denominator = 10 ** decimals;
    const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
    const block = block_ ? block_ : await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({});
    if (typeof chain?.fees?.estimateFeesPerGas === "function") {
      const fees = await chain.fees.estimateFeesPerGas({
        block: block_,
        client,
        multiply,
        request,
        type
      });
      if (fees !== null)
        return fees;
    }
    if (type === "eip1559") {
      if (typeof block.baseFeePerGas !== "bigint")
        throw new fee_js_1.Eip1559FeesNotSupportedError;
      const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await (0, estimateMaxPriorityFeePerGas_js_1.internal_estimateMaxPriorityFeePerGas)(client, {
        block,
        chain,
        request
      });
      const baseFeePerGas = multiply(block.baseFeePerGas);
      const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
      return {
        maxFeePerGas,
        maxPriorityFeePerGas
      };
    }
    const gasPrice = request?.gasPrice ?? multiply(await (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, "getGasPrice")({}));
    return {
      gasPrice
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.internal_estimateFeesPerGas = exports.estimateFeesPerGas = undefined;
  var fee_js_1 = require_fee();
  var getAction_js_1 = require_getAction();
  var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
  var getBlock_js_1 = require_getBlock();
  var getGasPrice_js_1 = require_getGasPrice();
  exports.estimateFeesPerGas = estimateFeesPerGas;
  exports.internal_estimateFeesPerGas = internal_estimateFeesPerGas2;
});

// node_modules/viem/_cjs/actions/public/getTransactionCount.js
var require_getTransactionCount = __commonJS((exports) => {
  async function getTransactionCount2(client, { address, blockTag = "latest", blockNumber }) {
    const count = await client.request({
      method: "eth_getTransactionCount",
      params: [address, blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag]
    });
    return (0, fromHex_js_1.hexToNumber)(count);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTransactionCount = undefined;
  var fromHex_js_1 = require_fromHex();
  var toHex_js_1 = require_toHex();
  exports.getTransactionCount = getTransactionCount2;
});

// node_modules/viem/_cjs/utils/blob/blobsToCommitments.js
var require_blobsToCommitments = __commonJS((exports) => {
  function blobsToCommitments2(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => (0, toBytes_js_1.hexToBytes)(x)) : parameters.blobs;
    const commitments = [];
    for (const blob of blobs)
      commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
    return to === "bytes" ? commitments : commitments.map((x) => (0, toHex_js_1.bytesToHex)(x));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.blobsToCommitments = undefined;
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.blobsToCommitments = blobsToCommitments2;
});

// node_modules/viem/_cjs/utils/blob/blobsToProofs.js
var require_blobsToProofs = __commonJS((exports) => {
  function blobsToProofs2(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => (0, toBytes_js_1.hexToBytes)(x)) : parameters.blobs;
    const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => (0, toBytes_js_1.hexToBytes)(x)) : parameters.commitments;
    const proofs = [];
    for (let i = 0;i < blobs.length; i++) {
      const blob = blobs[i];
      const commitment = commitments[i];
      proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
    }
    return to === "bytes" ? proofs : proofs.map((x) => (0, toHex_js_1.bytesToHex)(x));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.blobsToProofs = undefined;
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.blobsToProofs = blobsToProofs2;
});

// node_modules/@noble/hashes/_sha2.js
var require__sha2 = __commonJS((exports) => {
  function setBigUint642(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SHA2 = undefined;
  var _assert_js_1 = require__assert();
  var utils_js_1 = require_utils2();

  class SHA22 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
      (0, _assert_js_1.exists)(this);
      const { view, buffer, blockLen } = this;
      data = (0, utils_js_1.toBytes)(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = (0, utils_js_1.createView)(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.output)(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = (0, utils_js_1.createView)(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  }
  exports.SHA2 = SHA22;
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha224 = exports.sha256 = undefined;
  var _sha2_js_1 = require__sha2();
  var utils_js_1 = require_utils2();
  var Chi2 = (a, b, c) => a & b ^ ~a & c;
  var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV2 = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);

  class SHA2562 extends _sha2_js_1.SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV2[0] | 0;
      this.B = IV2[1] | 0;
      this.C = IV2[2] | 0;
      this.D = IV2[3] | 0;
      this.E = IV2[4] | 0;
      this.F = IV2[5] | 0;
      this.G = IV2[6] | 0;
      this.H = IV2[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W2[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W2[i - 15];
        const W2 = SHA256_W2[i - 2];
        const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
        const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
        const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
        const T2 = sigma0 + Maj2(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W2.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }

  class SHA224 extends SHA2562 {
    constructor() {
      super();
      this.A = 3238371032 | 0;
      this.B = 914150663 | 0;
      this.C = 812702999 | 0;
      this.D = 4144912697 | 0;
      this.E = 4290775857 | 0;
      this.F = 1750603025 | 0;
      this.G = 1694076839 | 0;
      this.H = 3204075428 | 0;
      this.outputLen = 28;
    }
  }
  exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2562);
  exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224);
});

// node_modules/viem/_cjs/utils/hash/sha256.js
var require_sha2562 = __commonJS((exports) => {
  function sha2563(value, to_) {
    const to = to_ || "hex";
    const bytes2 = (0, sha256_1.sha256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === "bytes")
      return bytes2;
    return (0, toHex_js_1.toHex)(bytes2);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha256 = undefined;
  var sha256_1 = require_sha256();
  var isHex_js_1 = require_isHex();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.sha256 = sha2563;
});

// node_modules/viem/_cjs/utils/blob/commitmentToVersionedHash.js
var require_commitmentToVersionedHash = __commonJS((exports) => {
  function commitmentToVersionedHash2(parameters) {
    const { commitment, version: version2 = 1 } = parameters;
    const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
    const versionedHash = (0, sha256_js_1.sha256)(commitment, "bytes");
    versionedHash.set([version2], 0);
    return to === "bytes" ? versionedHash : (0, toHex_js_1.bytesToHex)(versionedHash);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commitmentToVersionedHash = undefined;
  var toHex_js_1 = require_toHex();
  var sha256_js_1 = require_sha2562();
  exports.commitmentToVersionedHash = commitmentToVersionedHash2;
});

// node_modules/viem/_cjs/utils/blob/commitmentsToVersionedHashes.js
var require_commitmentsToVersionedHashes = __commonJS((exports) => {
  function commitmentsToVersionedHashes2(parameters) {
    const { commitments, version: version2 } = parameters;
    const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
    const hashes = [];
    for (const commitment of commitments) {
      hashes.push((0, commitmentToVersionedHash_js_1.commitmentToVersionedHash)({
        commitment,
        to,
        version: version2
      }));
    }
    return hashes;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commitmentsToVersionedHashes = undefined;
  var commitmentToVersionedHash_js_1 = require_commitmentToVersionedHash();
  exports.commitmentsToVersionedHashes = commitmentsToVersionedHashes2;
});

// node_modules/viem/_cjs/constants/blob.js
var require_blob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.maxBytesPerTransaction = exports.bytesPerBlob = exports.fieldElementsPerBlob = exports.bytesPerFieldElement = exports.blobsPerTransaction = undefined;
  exports.blobsPerTransaction = 6;
  exports.bytesPerFieldElement = 32;
  exports.fieldElementsPerBlob = 4096;
  exports.bytesPerBlob = exports.bytesPerFieldElement * exports.fieldElementsPerBlob;
  exports.maxBytesPerTransaction = exports.bytesPerBlob * exports.blobsPerTransaction - 1 - 1 * exports.fieldElementsPerBlob * exports.blobsPerTransaction;
});

// node_modules/viem/_cjs/constants/kzg.js
var require_kzg = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.versionedHashVersionKzg = exports.bytesPerProof = exports.bytesPerCommitment = undefined;
  exports.bytesPerCommitment = 48;
  exports.bytesPerProof = 48;
  exports.versionedHashVersionKzg = 1;
});

// node_modules/viem/_cjs/errors/blob.js
var require_blob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidVersionedHashVersionError = exports.InvalidVersionedHashSizeError = exports.EmptyBlobError = exports.BlobSizeTooLargeError = undefined;
  var kzg_js_1 = require_kzg();
  var base_js_1 = require_base();

  class BlobSizeTooLargeError2 extends base_js_1.BaseError {
    constructor({ maxSize, size: size2 }) {
      super("Blob size is too large.", {
        metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BlobSizeTooLargeError"
      });
    }
  }
  exports.BlobSizeTooLargeError = BlobSizeTooLargeError2;

  class EmptyBlobError2 extends base_js_1.BaseError {
    constructor() {
      super("Blob data must not be empty.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EmptyBlobError"
      });
    }
  }
  exports.EmptyBlobError = EmptyBlobError2;

  class InvalidVersionedHashSizeError extends base_js_1.BaseError {
    constructor({ hash: hash2, size: size2 }) {
      super(`Versioned hash "${hash2}" size is invalid.`, {
        metaMessages: ["Expected: 32", `Received: ${size2}`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidVersionedHashSizeError"
      });
    }
  }
  exports.InvalidVersionedHashSizeError = InvalidVersionedHashSizeError;

  class InvalidVersionedHashVersionError extends base_js_1.BaseError {
    constructor({ hash: hash2, version: version2 }) {
      super(`Versioned hash "${hash2}" version is invalid.`, {
        metaMessages: [
          `Expected: ${kzg_js_1.versionedHashVersionKzg}`,
          `Received: ${version2}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidVersionedHashVersionError"
      });
    }
  }
  exports.InvalidVersionedHashVersionError = InvalidVersionedHashVersionError;
});

// node_modules/viem/_cjs/utils/blob/toBlobs.js
var require_toBlobs = __commonJS((exports) => {
  function toBlobs2(parameters) {
    const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
    const data = typeof parameters.data === "string" ? (0, toBytes_js_1.hexToBytes)(parameters.data) : parameters.data;
    const size_ = (0, size_js_1.size)(data);
    if (!size_)
      throw new blob_js_2.EmptyBlobError;
    if (size_ > blob_js_1.maxBytesPerTransaction)
      throw new blob_js_2.BlobSizeTooLargeError({
        maxSize: blob_js_1.maxBytesPerTransaction,
        size: size_
      });
    const blobs = [];
    let active = true;
    let position = 0;
    while (active) {
      const blob = (0, cursor_js_1.createCursor)(new Uint8Array(blob_js_1.bytesPerBlob));
      let size2 = 0;
      while (size2 < blob_js_1.fieldElementsPerBlob) {
        const bytes2 = data.slice(position, position + (blob_js_1.bytesPerFieldElement - 1));
        blob.pushByte(0);
        blob.pushBytes(bytes2);
        if (bytes2.length < 31) {
          blob.pushByte(128);
          active = false;
          break;
        }
        size2++;
        position += 31;
      }
      blobs.push(blob);
    }
    return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => (0, toHex_js_1.bytesToHex)(x.bytes));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBlobs = undefined;
  var blob_js_1 = require_blob();
  var blob_js_2 = require_blob2();
  var cursor_js_1 = require_cursor2();
  var size_js_1 = require_size();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.toBlobs = toBlobs2;
});

// node_modules/viem/_cjs/utils/blob/toBlobSidecars.js
var require_toBlobSidecars = __commonJS((exports) => {
  function toBlobSidecars2(parameters) {
    const { data, kzg, to } = parameters;
    const blobs = parameters.blobs ?? (0, toBlobs_js_1.toBlobs)({ data, to });
    const commitments = parameters.commitments ?? (0, blobsToCommitments_js_1.blobsToCommitments)({ blobs, kzg, to });
    const proofs = parameters.proofs ?? (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg, to });
    const sidecars = [];
    for (let i = 0;i < blobs.length; i++)
      sidecars.push({
        blob: blobs[i],
        commitment: commitments[i],
        proof: proofs[i]
      });
    return sidecars;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBlobSidecars = undefined;
  var blobsToCommitments_js_1 = require_blobsToCommitments();
  var blobsToProofs_js_1 = require_blobsToProofs();
  var toBlobs_js_1 = require_toBlobs();
  exports.toBlobSidecars = toBlobSidecars2;
});

// node_modules/viem/_cjs/utils/transaction/getTransactionType.js
var require_getTransactionType = __commonJS((exports) => {
  function getTransactionType2(transaction) {
    if (transaction.type)
      return transaction.type;
    if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
      return "eip4844";
    if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
      return "eip1559";
    }
    if (typeof transaction.gasPrice !== "undefined") {
      if (typeof transaction.accessList !== "undefined")
        return "eip2930";
      return "legacy";
    }
    throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTransactionType = undefined;
  var transaction_js_1 = require_transaction2();
  exports.getTransactionType = getTransactionType2;
});

// node_modules/viem/_cjs/actions/public/getChainId.js
var require_getChainId = __commonJS((exports) => {
  async function getChainId2(client) {
    const chainIdHex = await client.request({
      method: "eth_chainId"
    });
    return (0, fromHex_js_1.hexToNumber)(chainIdHex);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChainId = undefined;
  var fromHex_js_1 = require_fromHex();
  exports.getChainId = getChainId2;
});

// node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js
var require_prepareTransactionRequest = __commonJS((exports) => {
  async function prepareTransactionRequest2(client, args) {
    const { account: account_ = client.account, blobs, chain, chainId, gas, kzg, nonce, parameters = exports.defaultParameters, type } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    const request = { ...args, ...account ? { from: account?.address } : {} };
    let block;
    async function getBlock2() {
      if (block)
        return block;
      block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({ blockTag: "latest" });
      return block;
    }
    if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
      const commitments = (0, blobsToCommitments_js_1.blobsToCommitments)({ blobs, kzg });
      if (parameters.includes("blobVersionedHashes")) {
        const versionedHashes = (0, commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes)({
          commitments,
          to: "hex"
        });
        request.blobVersionedHashes = versionedHashes;
      }
      if (parameters.includes("sidecars")) {
        const proofs = (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg });
        const sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({
          blobs,
          commitments,
          proofs,
          to: "hex"
        });
        request.sidecars = sidecars;
      }
    }
    if (parameters.includes("chainId")) {
      if (chain)
        request.chainId = chain.id;
      else if (typeof chainId !== "undefined")
        request.chainId = chainId;
      else
        request.chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
    }
    if (parameters.includes("nonce") && typeof nonce === "undefined" && account)
      request.nonce = await (0, getAction_js_1.getAction)(client, getTransactionCount_js_1.getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
      try {
        request.type = (0, getTransactionType_js_1.getTransactionType)(request);
      } catch {
        const block2 = await getBlock2();
        request.type = typeof block2?.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
      }
    }
    if (parameters.includes("fees")) {
      if (request.type === "eip1559" || request.type === "eip4844") {
        if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
          const block2 = await getBlock2();
          const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
            block: block2,
            chain,
            request
          });
          if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
            throw new fee_js_1.MaxFeePerGasTooLowError({
              maxPriorityFeePerGas
            });
          request.maxPriorityFeePerGas = maxPriorityFeePerGas;
          request.maxFeePerGas = maxFeePerGas;
        }
      } else {
        if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
          throw new fee_js_1.Eip1559FeesNotSupportedError;
        const block2 = await getBlock2();
        const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
          block: block2,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
    }
    if (parameters.includes("gas") && typeof gas === "undefined")
      request.gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, "estimateGas")({
        ...request,
        account: account ? { address: account.address, type: "json-rpc" } : undefined
      });
    (0, assertRequest_js_1.assertRequest)(request);
    delete request.parameters;
    return request;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareTransactionRequest = exports.defaultParameters = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
  var estimateGas_js_1 = require_estimateGas2();
  var getBlock_js_1 = require_getBlock();
  var getTransactionCount_js_1 = require_getTransactionCount();
  var fee_js_1 = require_fee();
  var blobsToCommitments_js_1 = require_blobsToCommitments();
  var blobsToProofs_js_1 = require_blobsToProofs();
  var commitmentsToVersionedHashes_js_1 = require_commitmentsToVersionedHashes();
  var toBlobSidecars_js_1 = require_toBlobSidecars();
  var getAction_js_1 = require_getAction();
  var assertRequest_js_1 = require_assertRequest();
  var getTransactionType_js_1 = require_getTransactionType();
  var getChainId_js_1 = require_getChainId();
  exports.defaultParameters = [
    "blobVersionedHashes",
    "chainId",
    "fees",
    "gas",
    "nonce",
    "type"
  ];
  exports.prepareTransactionRequest = prepareTransactionRequest2;
});

// node_modules/viem/_cjs/actions/public/estimateGas.js
var require_estimateGas2 = __commonJS((exports) => {
  async function estimateGas2(client, args) {
    const account_ = args.account ?? client.account;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    try {
      const { accessList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, {
        ...args,
        parameters: account?.type === "local" ? undefined : ["blobVersionedHashes"]
      });
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
      const block = blockNumberHex || blockTag;
      (0, assertRequest_js_1.assertRequest)(args);
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
      const request = format({
        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
        from: account?.address,
        accessList,
        blobs,
        blobVersionedHashes,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const balance = await client.request({
        method: "eth_estimateGas",
        params: block ? [request, block] : [request]
      });
      return BigInt(balance);
    } catch (err) {
      throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.estimateGas = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var toHex_js_1 = require_toHex();
  var getEstimateGasError_js_1 = require_getEstimateGasError();
  var extract_js_1 = require_extract();
  var transactionRequest_js_1 = require_transactionRequest();
  var assertRequest_js_1 = require_assertRequest();
  var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
  exports.estimateGas = estimateGas2;
});

// node_modules/viem/_cjs/actions/public/estimateContractGas.js
var require_estimateContractGas = __commonJS((exports) => {
  async function estimateContractGas2(client, parameters) {
    const { abi, address, args, functionName, ...request } = parameters;
    const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
      abi,
      args,
      functionName
    });
    try {
      const gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, "estimateGas")({
        data,
        to: address,
        ...request
      });
      return gas;
    } catch (error) {
      const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : undefined;
      throw (0, getContractError_js_1.getContractError)(error, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/estimateContractGas",
        functionName,
        sender: account?.address
      });
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.estimateContractGas = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var getContractError_js_1 = require_getContractError();
  var getAction_js_1 = require_getAction();
  var estimateGas_js_1 = require_estimateGas2();
  exports.estimateContractGas = estimateContractGas2;
});

// node_modules/viem/_cjs/utils/abi/decodeEventLog.js
var require_decodeEventLog = __commonJS((exports) => {
  function decodeEventLog2(parameters) {
    const { abi, data, strict: strict_, topics } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature)
      throw new abi_js_1.AbiEventSignatureEmptyTopicsError({ docsPath: docsPath5 });
    const abiItem = abi.find((x) => x.type === "event" && signature === (0, toEventSelector_js_1.toEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!(abiItem && ("name" in abiItem)) || abiItem.type !== "event")
      throw new abi_js_1.AbiEventSignatureNotFoundError(signature, { docsPath: docsPath5 });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x) => !(("name" in x) && x.name));
    let args = isUnnamed ? [] : {};
    const indexedInputs = inputs.filter((x) => ("indexed" in x) && x.indexed);
    for (let i = 0;i < indexedInputs.length; i++) {
      const param = indexedInputs[i];
      const topic = argTopics[i];
      if (!topic)
        throw new abi_js_1.DecodeLogTopicsMismatch({
          abiItem,
          param
        });
      args[isUnnamed ? i : param.name || i] = decodeTopic2({ param, value: topic });
    }
    const nonIndexedInputs = inputs.filter((x) => !(("indexed" in x) && x.indexed));
    if (nonIndexedInputs.length > 0) {
      if (data && data !== "0x") {
        try {
          const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
          if (decodedData) {
            if (isUnnamed)
              args = [...args, ...decodedData];
            else {
              for (let i = 0;i < nonIndexedInputs.length; i++) {
                args[nonIndexedInputs[i].name] = decodedData[i];
              }
            }
          }
        } catch (err) {
          if (strict) {
            if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError || err instanceof cursor_js_1.PositionOutOfBoundsError)
              throw new abi_js_1.DecodeLogDataMismatch({
                abiItem,
                data,
                params: nonIndexedInputs,
                size: (0, size_js_1.size)(data)
              });
            throw err;
          }
        }
      } else if (strict) {
        throw new abi_js_1.DecodeLogDataMismatch({
          abiItem,
          data: "0x",
          params: nonIndexedInputs,
          size: 0
        });
      }
    }
    return {
      eventName: name,
      args: Object.values(args).length > 0 ? args : undefined
    };
  }
  function decodeTopic2({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      return value;
    const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
    return decodedArg[0];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeEventLog = undefined;
  var abi_js_1 = require_abi();
  var size_js_1 = require_size();
  var toEventSelector_js_1 = require_toEventSelector();
  var cursor_js_1 = require_cursor();
  var decodeAbiParameters_js_1 = require_decodeAbiParameters();
  var formatAbiItem_js_1 = require_formatAbiItem2();
  var docsPath5 = "/docs/contract/decodeEventLog";
  exports.decodeEventLog = decodeEventLog2;
});

// node_modules/viem/_cjs/utils/abi/parseEventLogs.js
var require_parseEventLogs = __commonJS((exports) => {
  function parseEventLogs2({ abi, eventName, logs, strict = true }) {
    return logs.map((log) => {
      try {
        const event = (0, decodeEventLog_js_1.decodeEventLog)({
          ...log,
          abi,
          strict
        });
        if (eventName && !eventName.includes(event.eventName))
          return null;
        return { ...event, ...log };
      } catch (err) {
        let eventName2;
        let isUnnamed;
        if (err instanceof index_js_1.AbiEventSignatureNotFoundError)
          return null;
        if (err instanceof index_js_1.DecodeLogDataMismatch || err instanceof index_js_1.DecodeLogTopicsMismatch) {
          if (strict)
            return null;
          eventName2 = err.abiItem.name;
          isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
        }
        return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
      }
    }).filter(Boolean);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEventLogs = undefined;
  var index_js_1 = require__cjs2();
  var decodeEventLog_js_1 = require_decodeEventLog();
  exports.parseEventLogs = parseEventLogs2;
});

// node_modules/viem/_cjs/actions/public/getLogs.js
var require_getLogs = __commonJS((exports) => {
  async function getLogs2(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [event] : undefined);
    let topics = [];
    if (events) {
      topics = [
        events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
          abi: [event2],
          eventName: event2.name,
          args
        }))
      ];
      if (event)
        topics = topics[0];
    }
    let logs;
    if (blockHash) {
      logs = await client.request({
        method: "eth_getLogs",
        params: [{ address, topics, blockHash }]
      });
    } else {
      logs = await client.request({
        method: "eth_getLogs",
        params: [
          {
            address,
            topics,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock
          }
        ]
      });
    }
    const formattedLogs = logs.map((log) => (0, log_js_1.formatLog)(log));
    if (!events)
      return formattedLogs;
    return (0, parseEventLogs_js_1.parseEventLogs)({
      abi: events,
      logs: formattedLogs,
      strict
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getLogs = undefined;
  var encodeEventTopics_js_1 = require_encodeEventTopics();
  var parseEventLogs_js_1 = require_parseEventLogs();
  var toHex_js_1 = require_toHex();
  var log_js_1 = require_log();
  exports.getLogs = getLogs2;
});

// node_modules/viem/_cjs/actions/public/getContractEvents.js
var require_getContractEvents = __commonJS((exports) => {
  async function getContractEvents2(client, parameters) {
    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
    const event = eventName ? (0, getAbiItem_js_1.getAbiItem)({ abi, name: eventName }) : undefined;
    const events = !event ? abi.filter((x) => x.type === "event") : undefined;
    return (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, "getLogs")({
      address,
      args,
      blockHash,
      event,
      events,
      fromBlock,
      toBlock,
      strict
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getContractEvents = undefined;
  var getAbiItem_js_1 = require_getAbiItem();
  var getAction_js_1 = require_getAction();
  var getLogs_js_1 = require_getLogs();
  exports.getContractEvents = getContractEvents2;
});

// node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js
var require_decodeFunctionResult = __commonJS((exports) => {
  function decodeFunctionResult2(parameters) {
    const { abi, args, functionName, data } = parameters;
    let abiItem = abi[0];
    if (functionName) {
      const item = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
      if (!item)
        throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath: docsPath5 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new abi_js_1.AbiFunctionNotFoundError(undefined, { docsPath: docsPath5 });
    if (!abiItem.outputs)
      throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath5 });
    const values = (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.outputs, data);
    if (values && values.length > 1)
      return values;
    if (values && values.length === 1)
      return values[0];
    return;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeFunctionResult = undefined;
  var abi_js_1 = require_abi();
  var decodeAbiParameters_js_1 = require_decodeAbiParameters();
  var getAbiItem_js_1 = require_getAbiItem();
  var docsPath5 = "/docs/contract/decodeFunctionResult";
  exports.decodeFunctionResult = decodeFunctionResult2;
});

// node_modules/viem/_cjs/errors/ccip.js
var require_ccip = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OffchainLookupSenderMismatchError = exports.OffchainLookupResponseMalformedError = exports.OffchainLookupError = undefined;
  var stringify_js_1 = require_stringify();
  var base_js_1 = require_base();
  var utils_js_1 = require_utils();

  class OffchainLookupError2 extends base_js_1.BaseError {
    constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
      super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
        cause,
        metaMessages: [
          ...cause.metaMessages || [],
          cause.metaMessages?.length ? "" : [],
          "Offchain Gateway Call:",
          urls && [
            "  Gateway URL(s):",
            ...urls.map((url) => `    ${(0, utils_js_1.getUrl)(url)}`)
          ],
          `  Sender: ${sender}`,
          `  Data: ${data}`,
          `  Callback selector: ${callbackSelector}`,
          `  Extra data: ${extraData}`
        ].flat()
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OffchainLookupError"
      });
    }
  }
  exports.OffchainLookupError = OffchainLookupError2;

  class OffchainLookupResponseMalformedError2 extends base_js_1.BaseError {
    constructor({ result, url }) {
      super("Offchain gateway response is malformed. Response data must be a hex value.", {
        metaMessages: [
          `Gateway URL: ${(0, utils_js_1.getUrl)(url)}`,
          `Response: ${(0, stringify_js_1.stringify)(result)}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OffchainLookupResponseMalformedError"
      });
    }
  }
  exports.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError2;

  class OffchainLookupSenderMismatchError2 extends base_js_1.BaseError {
    constructor({ sender, to }) {
      super("Reverted sender address does not match target contract address (`to`).", {
        metaMessages: [
          `Contract address: ${to}`,
          `OffchainLookup sender address: ${sender}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OffchainLookupSenderMismatchError"
      });
    }
  }
  exports.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError2;
});

// node_modules/viem/_cjs/utils/address/isAddressEqual.js
var require_isAddressEqual = __commonJS((exports) => {
  function isAddressEqual2(a, b) {
    if (!(0, isAddress_js_1.isAddress)(a, { strict: false }))
      throw new address_js_1.InvalidAddressError({ address: a });
    if (!(0, isAddress_js_1.isAddress)(b, { strict: false }))
      throw new address_js_1.InvalidAddressError({ address: b });
    return a.toLowerCase() === b.toLowerCase();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAddressEqual = undefined;
  var address_js_1 = require_address();
  var isAddress_js_1 = require_isAddress();
  exports.isAddressEqual = isAddressEqual2;
});

// node_modules/viem/_cjs/utils/ccip.js
var require_ccip2 = __commonJS((exports) => {
  async function offchainLookup2(client, { blockNumber, blockTag, data, to }) {
    const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
      data,
      abi: [exports.offchainLookupAbiItem]
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    const { ccipRead } = client;
    const ccipRequest_ = ccipRead && typeof ccipRead?.request === "function" ? ccipRead.request : ccipRequest2;
    try {
      if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
        throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
      const result = await ccipRequest_({ data: callData, sender, urls });
      const { data: data_ } = await (0, call_js_1.call)(client, {
        blockNumber,
        blockTag,
        data: (0, concat_js_1.concat)([
          callbackSelector,
          (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
        ]),
        to
      });
      return data_;
    } catch (err) {
      throw new ccip_js_1.OffchainLookupError({
        callbackSelector,
        cause: err,
        data,
        extraData,
        sender,
        urls
      });
    }
  }
  async function ccipRequest2({ data, sender, urls }) {
    let error = new Error("An unknown error occurred.");
    for (let i = 0;i < urls.length; i++) {
      const url = urls[i];
      const method = url.includes("{data}") ? "GET" : "POST";
      const body = method === "POST" ? { data, sender } : undefined;
      try {
        const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
          body: JSON.stringify(body),
          method
        });
        let result;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          result = (await response.json()).data;
        } else {
          result = await response.text();
        }
        if (!response.ok) {
          error = new request_js_1.HttpRequestError({
            body,
            details: result?.error ? (0, stringify_js_1.stringify)(result.error) : response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
          continue;
        }
        if (!(0, isHex_js_1.isHex)(result)) {
          error = new ccip_js_1.OffchainLookupResponseMalformedError({
            result,
            url
          });
          continue;
        }
        return result;
      } catch (err) {
        error = new request_js_1.HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    throw error;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ccipRequest = exports.offchainLookup = exports.offchainLookupAbiItem = exports.offchainLookupSignature = undefined;
  var call_js_1 = require_call();
  var ccip_js_1 = require_ccip();
  var request_js_1 = require_request();
  var decodeErrorResult_js_1 = require_decodeErrorResult();
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  var isAddressEqual_js_1 = require_isAddressEqual();
  var concat_js_1 = require_concat();
  var isHex_js_1 = require_isHex();
  var stringify_js_1 = require_stringify();
  exports.offchainLookupSignature = "0x556f1830";
  exports.offchainLookupAbiItem = {
    name: "OffchainLookup",
    type: "error",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "urls",
        type: "string[]"
      },
      {
        name: "callData",
        type: "bytes"
      },
      {
        name: "callbackFunction",
        type: "bytes4"
      },
      {
        name: "extraData",
        type: "bytes"
      }
    ]
  };
  exports.offchainLookup = offchainLookup2;
  exports.ccipRequest = ccipRequest2;
});

// node_modules/viem/_cjs/constants/abis.js
var require_abis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.erc4626Abi = exports.erc721Abi = exports.erc20Abi_bytes32 = exports.erc20Abi = exports.universalSignatureValidatorAbi = exports.smartAccountAbi = exports.addressResolverAbi = exports.textResolverAbi = exports.universalResolverReverseAbi = exports.universalResolverResolveAbi = exports.multicall3Abi = undefined;
  exports.multicall3Abi = [
    {
      inputs: [
        {
          components: [
            {
              name: "target",
              type: "address"
            },
            {
              name: "allowFailure",
              type: "bool"
            },
            {
              name: "callData",
              type: "bytes"
            }
          ],
          name: "calls",
          type: "tuple[]"
        }
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            {
              name: "success",
              type: "bool"
            },
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "returnData",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ];
  var universalResolverErrors2 = [
    {
      inputs: [],
      name: "ResolverNotFound",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverWildcardNotSupported",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverNotContract",
      type: "error"
    },
    {
      inputs: [
        {
          name: "returnData",
          type: "bytes"
        }
      ],
      name: "ResolverError",
      type: "error"
    },
    {
      inputs: [
        {
          components: [
            {
              name: "status",
              type: "uint16"
            },
            {
              name: "message",
              type: "string"
            }
          ],
          name: "errors",
          type: "tuple[]"
        }
      ],
      name: "HttpError",
      type: "error"
    }
  ];
  exports.universalResolverResolveAbi = [
    ...universalResolverErrors2,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    },
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
        { name: "gateways", type: "string[]" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    }
  ];
  exports.universalResolverReverseAbi = [
    ...universalResolverErrors2,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    },
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [
        { type: "bytes", name: "reverseName" },
        { type: "string[]", name: "gateways" }
      ],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    }
  ];
  exports.textResolverAbi = [
    {
      name: "text",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "key", type: "string" }
      ],
      outputs: [{ name: "", type: "string" }]
    }
  ];
  exports.addressResolverAbi = [
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [{ name: "name", type: "bytes32" }],
      outputs: [{ name: "", type: "address" }]
    },
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "coinType", type: "uint256" }
      ],
      outputs: [{ name: "", type: "bytes" }]
    }
  ];
  exports.smartAccountAbi = [
    {
      name: "isValidSignature",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "hash", type: "bytes32" },
        { name: "signature", type: "bytes" }
      ],
      outputs: [{ name: "", type: "bytes4" }]
    }
  ];
  exports.universalSignatureValidatorAbi = [
    {
      inputs: [
        {
          internalType: "address",
          name: "_signer",
          type: "address"
        },
        {
          internalType: "bytes32",
          name: "_hash",
          type: "bytes32"
        },
        {
          internalType: "bytes",
          name: "_signature",
          type: "bytes"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    }
  ];
  exports.erc20Abi = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        {
          indexed: true,
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "allowance",
      stateMutability: "view",
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "spender",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "spender",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [
        {
          name: "account",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "decimals",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "uint8"
        }
      ]
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    }
  ];
  exports.erc20Abi_bytes32 = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        {
          indexed: true,
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "allowance",
      stateMutability: "view",
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "spender",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "spender",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [
        {
          name: "account",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "decimals",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "uint8"
        }
      ]
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "bytes32"
        }
      ]
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "bytes32"
        }
      ]
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    }
  ];
  exports.erc721Abi = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "spender",
          type: "address"
        },
        {
          indexed: true,
          name: "tokenId",
          type: "uint256"
        }
      ]
    },
    {
      type: "event",
      name: "ApprovalForAll",
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "operator",
          type: "address"
        },
        {
          indexed: false,
          name: "approved",
          type: "bool"
        }
      ]
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        {
          indexed: true,
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          name: "to",
          type: "address"
        },
        {
          indexed: true,
          name: "tokenId",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "payable",
      inputs: [
        {
          name: "spender",
          type: "address"
        },
        {
          name: "tokenId",
          type: "uint256"
        }
      ],
      outputs: []
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [
        {
          name: "account",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "getApproved",
      stateMutability: "view",
      inputs: [
        {
          name: "tokenId",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "address"
        }
      ]
    },
    {
      type: "function",
      name: "isApprovedForAll",
      stateMutability: "view",
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "operator",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "ownerOf",
      stateMutability: "view",
      inputs: [
        {
          name: "tokenId",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "owner",
          type: "address"
        }
      ]
    },
    {
      type: "function",
      name: "safeTransferFrom",
      stateMutability: "payable",
      inputs: [
        {
          name: "from",
          type: "address"
        },
        {
          name: "to",
          type: "address"
        },
        {
          name: "tokenId",
          type: "uint256"
        }
      ],
      outputs: []
    },
    {
      type: "function",
      name: "safeTransferFrom",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "from",
          type: "address"
        },
        {
          name: "to",
          type: "address"
        },
        {
          name: "id",
          type: "uint256"
        },
        {
          name: "data",
          type: "bytes"
        }
      ],
      outputs: []
    },
    {
      type: "function",
      name: "setApprovalForAll",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "operator",
          type: "address"
        },
        {
          name: "approved",
          type: "bool"
        }
      ],
      outputs: []
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "tokenByIndex",
      stateMutability: "view",
      inputs: [
        {
          name: "index",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "tokenByIndex",
      stateMutability: "view",
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "index",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "tokenId",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "tokenURI",
      stateMutability: "view",
      inputs: [
        {
          name: "tokenId",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "payable",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "tokeId",
          type: "uint256"
        }
      ],
      outputs: []
    }
  ];
  exports.erc4626Abi = [
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ],
      name: "Approval",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          name: "sender",
          type: "address"
        },
        {
          indexed: true,
          name: "receiver",
          type: "address"
        },
        {
          indexed: false,
          name: "assets",
          type: "uint256"
        },
        {
          indexed: false,
          name: "shares",
          type: "uint256"
        }
      ],
      name: "Deposit",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ],
      name: "Transfer",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          name: "sender",
          type: "address"
        },
        {
          indexed: true,
          name: "receiver",
          type: "address"
        },
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: false,
          name: "assets",
          type: "uint256"
        },
        {
          indexed: false,
          name: "shares",
          type: "uint256"
        }
      ],
      name: "Withdraw",
      type: "event"
    },
    {
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "spender",
          type: "address"
        }
      ],
      name: "allowance",
      outputs: [
        {
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "spender",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      name: "approve",
      outputs: [
        {
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "asset",
      outputs: [
        {
          name: "assetTokenAddress",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "account",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      name: "convertToAssets",
      outputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      name: "convertToShares",
      outputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "assets",
          type: "uint256"
        },
        {
          name: "receiver",
          type: "address"
        }
      ],
      name: "deposit",
      outputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          name: "caller",
          type: "address"
        }
      ],
      name: "maxDeposit",
      outputs: [
        {
          name: "maxAssets",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "caller",
          type: "address"
        }
      ],
      name: "maxMint",
      outputs: [
        {
          name: "maxShares",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "owner",
          type: "address"
        }
      ],
      name: "maxRedeem",
      outputs: [
        {
          name: "maxShares",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "owner",
          type: "address"
        }
      ],
      name: "maxWithdraw",
      outputs: [
        {
          name: "maxAssets",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "shares",
          type: "uint256"
        },
        {
          name: "receiver",
          type: "address"
        }
      ],
      name: "mint",
      outputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      name: "previewDeposit",
      outputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      name: "previewMint",
      outputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      name: "previewRedeem",
      outputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      name: "previewWithdraw",
      outputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "shares",
          type: "uint256"
        },
        {
          name: "receiver",
          type: "address"
        },
        {
          name: "owner",
          type: "address"
        }
      ],
      name: "redeem",
      outputs: [
        {
          name: "assets",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "totalAssets",
      outputs: [
        {
          name: "totalManagedAssets",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          name: "to",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transfer",
      outputs: [
        {
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          name: "from",
          type: "address"
        },
        {
          name: "to",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transferFrom",
      outputs: [
        {
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          name: "assets",
          type: "uint256"
        },
        {
          name: "receiver",
          type: "address"
        },
        {
          name: "owner",
          type: "address"
        }
      ],
      name: "withdraw",
      outputs: [
        {
          name: "shares",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    }
  ];
});

// node_modules/viem/_cjs/constants/contract.js
var require_contract2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aggregate3Signature = undefined;
  exports.aggregate3Signature = "0x82ad56cb";
});

// node_modules/viem/_cjs/errors/chain.js
var require_chain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = undefined;
  var base_js_1 = require_base();

  class ChainDoesNotSupportContract2 extends base_js_1.BaseError {
    constructor({ blockNumber, chain, contract }) {
      super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
        metaMessages: [
          "This could be due to any of the following:",
          ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
          ] : [
            `- The chain does not have the contract "${contract.name}" configured.`
          ]
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainDoesNotSupportContract"
      });
    }
  }
  exports.ChainDoesNotSupportContract = ChainDoesNotSupportContract2;

  class ChainMismatchError2 extends base_js_1.BaseError {
    constructor({ chain, currentChainId }) {
      super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
        metaMessages: [
          `Current Chain ID:  ${currentChainId}`,
          `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainMismatchError"
      });
    }
  }
  exports.ChainMismatchError = ChainMismatchError2;

  class ChainNotFoundError2 extends base_js_1.BaseError {
    constructor() {
      super([
        "No chain was provided to the request.",
        "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ChainNotFoundError"
      });
    }
  }
  exports.ChainNotFoundError = ChainNotFoundError2;

  class ClientChainNotConfiguredError2 extends base_js_1.BaseError {
    constructor() {
      super("No chain was provided to the Client.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ClientChainNotConfiguredError"
      });
    }
  }
  exports.ClientChainNotConfiguredError = ClientChainNotConfiguredError2;

  class InvalidChainIdError extends base_js_1.BaseError {
    constructor({ chainId }) {
      super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidChainIdError"
      });
    }
  }
  exports.InvalidChainIdError = InvalidChainIdError;
});

// node_modules/viem/_cjs/utils/chain/getChainContractAddress.js
var require_getChainContractAddress = __commonJS((exports) => {
  function getChainContractAddress2({ blockNumber, chain, contract: name }) {
    const contract = chain?.contracts?.[name];
    if (!contract)
      throw new chain_js_1.ChainDoesNotSupportContract({
        chain,
        contract: { name }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new chain_js_1.ChainDoesNotSupportContract({
        blockNumber,
        chain,
        contract: {
          name,
          blockCreated: contract.blockCreated
        }
      });
    return contract.address;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChainContractAddress = undefined;
  var chain_js_1 = require_chain();
  exports.getChainContractAddress = getChainContractAddress2;
});

// node_modules/viem/_cjs/utils/errors/getCallError.js
var require_getCallError = __commonJS((exports) => {
  function getCallError2(err, { docsPath: docsPath5, ...args }) {
    const cause = (() => {
      const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
      if (cause2 instanceof node_js_1.UnknownNodeError)
        return err;
      return cause2;
    })();
    return new contract_js_1.CallExecutionError(cause, {
      docsPath: docsPath5,
      ...args
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCallError = undefined;
  var contract_js_1 = require_contract();
  var node_js_1 = require_node();
  var getNodeError_js_1 = require_getNodeError();
  exports.getCallError = getCallError2;
});

// node_modules/viem/_cjs/utils/promise/createBatchScheduler.js
var require_createBatchScheduler = __commonJS((exports) => {
  function createBatchScheduler2({ fn, id, shouldSplitBatch, wait: wait2 = 0, sort }) {
    const exec = async () => {
      const scheduler = getScheduler();
      flush();
      const args = scheduler.map(({ args: args2 }) => args2);
      if (args.length === 0)
        return;
      fn(args).then((data) => {
        if (sort && Array.isArray(data))
          data.sort(sort);
        for (let i = 0;i < scheduler.length; i++) {
          const { pendingPromise } = scheduler[i];
          pendingPromise.resolve?.([data[i], data]);
        }
      }).catch((err) => {
        for (let i = 0;i < scheduler.length; i++) {
          const { pendingPromise } = scheduler[i];
          pendingPromise.reject?.(err);
        }
      });
    };
    const flush = () => schedulerCache2.delete(id);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache2.get(id) || [];
    const setScheduler = (item) => schedulerCache2.set(id, [...getScheduler(), item]);
    return {
      flush,
      async schedule(args) {
        const pendingPromise = {};
        const promise = new Promise((resolve, reject) => {
          pendingPromise.resolve = resolve;
          pendingPromise.reject = reject;
        });
        const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
        if (split2)
          exec();
        const hasActiveScheduler = getScheduler().length > 0;
        if (hasActiveScheduler) {
          setScheduler({ args, pendingPromise });
          return promise;
        }
        setScheduler({ args, pendingPromise });
        setTimeout(exec, wait2);
        return promise;
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createBatchScheduler = undefined;
  var schedulerCache2 = new Map;
  exports.createBatchScheduler = createBatchScheduler2;
});

// node_modules/viem/_cjs/actions/public/call.js
var require_call = __commonJS((exports) => {
  async function call2(client, args) {
    const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    try {
      (0, assertRequest_js_1.assertRequest)(args);
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
      const block = blockNumberHex || blockTag;
      const rpcStateOverride = parseStateOverride2(stateOverride);
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
      const request = format({
        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
        from: account?.address,
        accessList,
        blobs,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      if (batch && shouldPerformMulticall2({ request }) && !rpcStateOverride) {
        try {
          return await scheduleMulticall2(client, {
            ...request,
            blockNumber,
            blockTag
          });
        } catch (err) {
          if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) && !(err instanceof chain_js_1.ChainDoesNotSupportContract))
            throw err;
        }
      }
      const response = await client.request({
        method: "eth_call",
        params: rpcStateOverride ? [
          request,
          block,
          rpcStateOverride
        ] : [request, block]
      });
      if (response === "0x")
        return { data: undefined };
      return { data: response };
    } catch (err) {
      const data2 = getRevertErrorData2(err);
      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => require_ccip2());
      if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)
        return { data: await offchainLookup2(client, { data: data2, to }) };
      throw (0, getCallError_js_1.getCallError)(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  function shouldPerformMulticall2({ request }) {
    const { data, to, ...request_ } = request;
    if (!data)
      return false;
    if (data.startsWith(contract_js_1.aggregate3Signature))
      return false;
    if (!to)
      return false;
    if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
      return false;
    return true;
  }
  async function scheduleMulticall2(client, args) {
    const { batchSize = 1024, wait: wait2 = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
    const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new chain_js_1.ClientChainNotConfiguredError;
      multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
      id: `${client.uid}.${block}`,
      wait: wait2,
      shouldSplitBatch(args2) {
        const size2 = args2.reduce((size3, { data: data2 }) => size3 + (data2.length - 2), 0);
        return size2 > batchSize * 2;
      },
      fn: async (requests) => {
        const calls = requests.map((request) => ({
          allowFailure: true,
          callData: request.data,
          target: request.to
        }));
        const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
          abi: abis_js_1.multicall3Abi,
          args: [calls],
          functionName: "aggregate3"
        });
        const data2 = await client.request({
          method: "eth_call",
          params: [
            {
              data: calldata,
              to: multicallAddress
            },
            block
          ]
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.multicall3Abi,
          args: [calls],
          functionName: "aggregate3",
          data: data2 || "0x"
        });
      }
    });
    const [{ returnData, success }] = await schedule({ data, to });
    if (!success)
      throw new contract_js_2.RawContractError({ data: returnData });
    if (returnData === "0x")
      return { data: undefined };
    return { data: returnData };
  }
  function getRevertErrorData2(err) {
    if (!(err instanceof base_js_1.BaseError))
      return;
    const error = err.walk();
    return typeof error?.data === "object" ? error.data?.data : error.data;
  }
  function parseStateMapping2(stateMapping) {
    if (!stateMapping || stateMapping.length === 0)
      return;
    return stateMapping.reduce((acc, { slot, value }) => {
      if (slot.length !== 66)
        throw new data_js_1.InvalidBytesLengthError({
          size: slot.length,
          targetSize: 66,
          type: "hex"
        });
      if (value.length !== 66)
        throw new data_js_1.InvalidBytesLengthError({
          size: value.length,
          targetSize: 66,
          type: "hex"
        });
      acc[slot] = value;
      return acc;
    }, {});
  }
  function parseAccountStateOverride2(args) {
    const { balance, nonce, state, stateDiff, code } = args;
    const rpcAccountStateOverride = {};
    if (code !== undefined)
      rpcAccountStateOverride.code = code;
    if (balance !== undefined)
      rpcAccountStateOverride.balance = (0, toHex_js_1.numberToHex)(balance);
    if (nonce !== undefined)
      rpcAccountStateOverride.nonce = (0, toHex_js_1.numberToHex)(nonce);
    if (state !== undefined)
      rpcAccountStateOverride.state = parseStateMapping2(state);
    if (stateDiff !== undefined) {
      if (rpcAccountStateOverride.state)
        throw new stateOverride_js_1.StateAssignmentConflictError;
      rpcAccountStateOverride.stateDiff = parseStateMapping2(stateDiff);
    }
    return rpcAccountStateOverride;
  }
  function parseStateOverride2(args) {
    if (!args)
      return;
    const rpcStateOverride = {};
    for (const { address, ...accountState } of args) {
      if (!(0, isAddress_js_1.isAddress)(address, { strict: false }))
        throw new address_js_1.InvalidAddressError({ address });
      if (rpcStateOverride[address])
        throw new stateOverride_js_1.AccountStateConflictError({ address });
      rpcStateOverride[address] = parseAccountStateOverride2(accountState);
    }
    return rpcStateOverride;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseStateOverride = exports.parseAccountStateOverride = exports.parseStateMapping = exports.getRevertErrorData = exports.call = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var abis_js_1 = require_abis();
  var contract_js_1 = require_contract2();
  var address_js_1 = require_address();
  var base_js_1 = require_base();
  var chain_js_1 = require_chain();
  var contract_js_2 = require_contract();
  var data_js_1 = require_data();
  var stateOverride_js_1 = require_stateOverride();
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var isAddress_js_1 = require_isAddress();
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  var toHex_js_1 = require_toHex();
  var getCallError_js_1 = require_getCallError();
  var extract_js_1 = require_extract();
  var transactionRequest_js_1 = require_transactionRequest();
  var createBatchScheduler_js_1 = require_createBatchScheduler();
  var assertRequest_js_1 = require_assertRequest();
  exports.call = call2;
  exports.getRevertErrorData = getRevertErrorData2;
  exports.parseStateMapping = parseStateMapping2;
  exports.parseAccountStateOverride = parseAccountStateOverride2;
  exports.parseStateOverride = parseStateOverride2;
});

// node_modules/viem/_cjs/actions/public/readContract.js
var require_readContract = __commonJS((exports) => {
  async function readContract2(client, parameters) {
    const { abi, address, args, functionName, ...rest } = parameters;
    const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
      abi,
      args,
      functionName
    });
    try {
      const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
        ...rest,
        data: calldata,
        to: address
      });
      return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
        abi,
        args,
        functionName,
        data: data || "0x"
      });
    } catch (error) {
      throw (0, getContractError_js_1.getContractError)(error, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/readContract",
        functionName
      });
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readContract = undefined;
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var getContractError_js_1 = require_getContractError();
  var getAction_js_1 = require_getAction();
  var call_js_1 = require_call();
  exports.readContract = readContract2;
});

// node_modules/viem/_cjs/actions/public/simulateContract.js
var require_simulateContract = __commonJS((exports) => {
  async function simulateContract2(client, parameters) {
    const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
    const account = callRequest.account ? (0, parseAccount_js_1.parseAccount)(callRequest.account) : client.account;
    const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({ abi, args, functionName });
    try {
      const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
        batch: false,
        data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...callRequest,
        account
      });
      const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
        abi,
        args,
        functionName,
        data: data || "0x"
      });
      const minimizedAbi = abi.filter((abiItem) => ("name" in abiItem) && abiItem.name === parameters.functionName);
      return {
        result,
        request: {
          abi: minimizedAbi,
          address,
          args,
          dataSuffix,
          functionName,
          ...callRequest,
          account
        }
      };
    } catch (error) {
      throw (0, getContractError_js_1.getContractError)(error, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/simulateContract",
        functionName,
        sender: account?.address
      });
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.simulateContract = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var getContractError_js_1 = require_getContractError();
  var getAction_js_1 = require_getAction();
  var call_js_1 = require_call();
  exports.simulateContract = simulateContract2;
});

// node_modules/viem/_cjs/utils/observe.js
var require_observe = __commonJS((exports) => {
  function observe2(observerId, callbacks, fn) {
    const callbackId = ++callbackCount2;
    const getListeners = () => exports.listenersCache.get(observerId) || [];
    const unsubscribe = () => {
      const listeners2 = getListeners();
      exports.listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
    };
    const unwatch = () => {
      const cleanup2 = exports.cleanupCache.get(observerId);
      if (getListeners().length === 1 && cleanup2)
        cleanup2();
      unsubscribe();
    };
    const listeners = getListeners();
    exports.listenersCache.set(observerId, [
      ...listeners,
      { id: callbackId, fns: callbacks }
    ]);
    if (listeners && listeners.length > 0)
      return unwatch;
    const emit = {};
    for (const key in callbacks) {
      emit[key] = (...args) => {
        const listeners2 = getListeners();
        if (listeners2.length === 0)
          return;
        for (const listener of listeners2)
          listener.fns[key]?.(...args);
      };
    }
    const cleanup = fn(emit);
    if (typeof cleanup === "function")
      exports.cleanupCache.set(observerId, cleanup);
    return unwatch;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observe = exports.cleanupCache = exports.listenersCache = undefined;
  exports.listenersCache = new Map;
  exports.cleanupCache = new Map;
  var callbackCount2 = 0;
  exports.observe = observe2;
});

// node_modules/viem/_cjs/utils/wait.js
var require_wait = __commonJS((exports) => {
  async function wait2(time) {
    return new Promise((res) => setTimeout(res, time));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wait = undefined;
  exports.wait = wait2;
});

// node_modules/viem/_cjs/utils/poll.js
var require_poll = __commonJS((exports) => {
  function poll2(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = () => active = false;
    const watch = async () => {
      let data = undefined;
      if (emitOnBegin)
        data = await fn({ unpoll: unwatch });
      const initialWait = await initialWaitTime?.(data) ?? interval;
      await (0, wait_js_1.wait)(initialWait);
      const poll3 = async () => {
        if (!active)
          return;
        await fn({ unpoll: unwatch });
        await (0, wait_js_1.wait)(interval);
        poll3();
      };
      poll3();
    };
    watch();
    return unwatch;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.poll = undefined;
  var wait_js_1 = require_wait();
  exports.poll = poll2;
});

// node_modules/viem/_cjs/utils/promise/withCache.js
var require_withCache = __commonJS((exports) => {
  function getCache2(cacheKey2) {
    const buildCache = (cacheKey3, cache) => ({
      clear: () => cache.delete(cacheKey3),
      get: () => cache.get(cacheKey3),
      set: (data) => cache.set(cacheKey3, data)
    });
    const promise = buildCache(cacheKey2, exports.promiseCache);
    const response = buildCache(cacheKey2, exports.responseCache);
    return {
      clear: () => {
        promise.clear();
        response.clear();
      },
      promise,
      response
    };
  }
  async function withCache2(fn, { cacheKey: cacheKey2, cacheTime = Infinity }) {
    const cache = getCache2(cacheKey2);
    const response = cache.response.get();
    if (response && cacheTime > 0) {
      const age = new Date().getTime() - response.created.getTime();
      if (age < cacheTime)
        return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
      promise = fn();
      cache.promise.set(promise);
    }
    try {
      const data = await promise;
      cache.response.set({ created: new Date, data });
      return data;
    } finally {
      cache.promise.clear();
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = undefined;
  exports.promiseCache = new Map;
  exports.responseCache = new Map;
  exports.getCache = getCache2;
  exports.withCache = withCache2;
});

// node_modules/viem/_cjs/actions/public/getBlockNumber.js
var require_getBlockNumber = __commonJS((exports) => {
  function getBlockNumberCache(id) {
    return (0, withCache_js_1.getCache)(cacheKey2(id));
  }
  async function getBlockNumber2(client, { cacheTime = client.cacheTime } = {}) {
    const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
      method: "eth_blockNumber"
    }), { cacheKey: cacheKey2(client.uid), cacheTime });
    return BigInt(blockNumberHex);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBlockNumber = exports.getBlockNumberCache = undefined;
  var withCache_js_1 = require_withCache();
  var cacheKey2 = (id) => `blockNumber.${id}`;
  exports.getBlockNumberCache = getBlockNumberCache;
  exports.getBlockNumber = getBlockNumber2;
});

// node_modules/viem/_cjs/actions/public/getFilterChanges.js
var require_getFilterChanges = __commonJS((exports) => {
  async function getFilterChanges2(_client, { filter }) {
    const strict = "strict" in filter && filter.strict;
    const logs = await filter.request({
      method: "eth_getFilterChanges",
      params: [filter.id]
    });
    if (typeof logs[0] === "string")
      return logs;
    const formattedLogs = logs.map((log) => (0, log_js_1.formatLog)(log));
    if (!("abi" in filter) || !filter.abi)
      return formattedLogs;
    return (0, parseEventLogs_js_1.parseEventLogs)({
      abi: filter.abi,
      logs: formattedLogs,
      strict
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFilterChanges = undefined;
  var parseEventLogs_js_1 = require_parseEventLogs();
  var log_js_1 = require_log();
  exports.getFilterChanges = getFilterChanges2;
});

// node_modules/viem/_cjs/actions/public/uninstallFilter.js
var require_uninstallFilter = __commonJS((exports) => {
  async function uninstallFilter2(_client, { filter }) {
    return filter.request({
      method: "eth_uninstallFilter",
      params: [filter.id]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uninstallFilter = undefined;
  exports.uninstallFilter = uninstallFilter2;
});

// node_modules/viem/_cjs/actions/public/watchContractEvent.js
var require_watchContractEvent = __commonJS((exports) => {
  function watchContractEvent2(client, parameters) {
    const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket" || typeof fromBlock === "number";
    const pollContractEvent = () => {
      const strict = strict_ ?? false;
      const observerId = (0, stringify_js_1.stringify)([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval,
        strict,
        fromBlock
      ]);
      return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
        let previousBlockNumber;
        if (fromBlock !== undefined)
          previousBlockNumber = fromBlock - 1n;
        let filter;
        let initialized = false;
        const unwatch = (0, poll_js_1.poll)(async () => {
          if (!initialized) {
            try {
              filter = await (0, getAction_js_1.getAction)(client, createContractEventFilter_js_1.createContractEventFilter, "createContractEventFilter")({
                abi,
                address,
                args,
                eventName,
                strict,
                fromBlock
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
            } else {
              const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({});
              if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                logs = await (0, getAction_js_1.getAction)(client, getContractEvents_js_1.getContractEvents, "getContractEvents")({
                  abi,
                  address,
                  args,
                  eventName,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber,
                  strict
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit.onLogs(logs);
            else
              for (const log of logs)
                emit.onLogs([log]);
          } catch (err) {
            if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
              initialized = false;
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribeContractEvent = () => {
      const strict = strict_ ?? false;
      const observerId = (0, stringify_js_1.stringify)([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval,
        strict
      ]);
      let active = true;
      let unsubscribe = () => active = false;
      return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
        (async () => {
          try {
            const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
              abi,
              eventName,
              args
            }) : [];
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName: eventName2, args: args2 } = (0, decodeEventLog_js_1.decodeEventLog)({
                    abi,
                    data: log.data,
                    topics: log.topics,
                    strict: strict_
                  });
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: args2,
                    eventName: eventName2
                  });
                  emit.onLogs([formatted]);
                } catch (err) {
                  let eventName2;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName2 = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
                  }
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName: eventName2
                  });
                  emit.onLogs([formatted]);
                }
              },
              onError(error) {
                emit.onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return () => unsubscribe();
      });
    };
    return enablePolling ? pollContractEvent() : subscribeContractEvent();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.watchContractEvent = undefined;
  var abi_js_1 = require_abi();
  var rpc_js_1 = require_rpc();
  var decodeEventLog_js_1 = require_decodeEventLog();
  var encodeEventTopics_js_1 = require_encodeEventTopics();
  var log_js_1 = require_log();
  var getAction_js_1 = require_getAction();
  var observe_js_1 = require_observe();
  var poll_js_1 = require_poll();
  var stringify_js_1 = require_stringify();
  var createContractEventFilter_js_1 = require_createContractEventFilter();
  var getBlockNumber_js_1 = require_getBlockNumber();
  var getContractEvents_js_1 = require_getContractEvents();
  var getFilterChanges_js_1 = require_getFilterChanges();
  var uninstallFilter_js_1 = require_uninstallFilter();
  exports.watchContractEvent = watchContractEvent2;
});

// node_modules/viem/_cjs/errors/account.js
var require_account = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AccountNotFoundError = undefined;
  var base_js_1 = require_base();

  class AccountNotFoundError2 extends base_js_1.BaseError {
    constructor({ docsPath: docsPath5 } = {}) {
      super([
        "Could not find an Account to execute with this Action.",
        "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
      ].join("\n"), {
        docsPath: docsPath5,
        docsSlug: "account"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AccountNotFoundError"
      });
    }
  }
  exports.AccountNotFoundError = AccountNotFoundError2;
});

// node_modules/viem/_cjs/utils/chain/assertCurrentChain.js
var require_assertCurrentChain = __commonJS((exports) => {
  function assertCurrentChain2({ chain, currentChainId }) {
    if (!chain)
      throw new chain_js_1.ChainNotFoundError;
    if (currentChainId !== chain.id)
      throw new chain_js_1.ChainMismatchError({ chain, currentChainId });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertCurrentChain = undefined;
  var chain_js_1 = require_chain();
  exports.assertCurrentChain = assertCurrentChain2;
});

// node_modules/viem/_cjs/utils/errors/getTransactionError.js
var require_getTransactionError = __commonJS((exports) => {
  function getTransactionError2(err, { docsPath: docsPath5, ...args }) {
    const cause = (() => {
      const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
      if (cause2 instanceof node_js_1.UnknownNodeError)
        return err;
      return cause2;
    })();
    return new transaction_js_1.TransactionExecutionError(cause, {
      docsPath: docsPath5,
      ...args
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTransactionError = undefined;
  var node_js_1 = require_node();
  var transaction_js_1 = require_transaction2();
  var getNodeError_js_1 = require_getNodeError();
  exports.getTransactionError = getTransactionError2;
});

// node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js
var require_sendRawTransaction = __commonJS((exports) => {
  async function sendRawTransaction2(client, { serializedTransaction }) {
    return client.request({
      method: "eth_sendRawTransaction",
      params: [serializedTransaction]
    }, { retryCount: 0 });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sendRawTransaction = undefined;
  exports.sendRawTransaction = sendRawTransaction2;
});

// node_modules/viem/_cjs/actions/wallet/sendTransaction.js
var require_sendTransaction = __commonJS((exports) => {
  async function sendTransaction2(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, accessList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = parameters;
    if (!account_)
      throw new account_js_1.AccountNotFoundError({
        docsPath: "/docs/actions/wallet/sendTransaction"
      });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    try {
      (0, assertRequest_js_1.assertRequest)(parameters);
      let chainId;
      if (chain !== null) {
        chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
        (0, assertCurrentChain_js_1.assertCurrentChain)({
          currentChainId: chainId,
          chain
        });
      }
      if (account.type === "local") {
        const request2 = await (0, getAction_js_1.getAction)(client, prepareTransactionRequest_js_1.prepareTransactionRequest, "prepareTransactionRequest")({
          account,
          accessList,
          blobs,
          chain,
          chainId,
          data,
          gas,
          gasPrice,
          maxFeePerBlobGas,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          parameters: [...prepareTransactionRequest_js_1.defaultParameters, "sidecars"],
          to,
          value,
          ...rest
        });
        const serializer = chain?.serializers?.transaction;
        const serializedTransaction = await account.signTransaction(request2, {
          serializer
        });
        return await (0, getAction_js_1.getAction)(client, sendRawTransaction_js_1.sendRawTransaction, "sendRawTransaction")({
          serializedTransaction
        });
      }
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
      const request = format({
        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
        accessList,
        blobs,
        data,
        from: account.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      return await client.request({
        method: "eth_sendTransaction",
        params: [request]
      }, { retryCount: 0 });
    } catch (err) {
      throw (0, getTransactionError_js_1.getTransactionError)(err, {
        ...parameters,
        account,
        chain: parameters.chain || undefined
      });
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sendTransaction = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var account_js_1 = require_account();
  var assertCurrentChain_js_1 = require_assertCurrentChain();
  var getTransactionError_js_1 = require_getTransactionError();
  var extract_js_1 = require_extract();
  var transactionRequest_js_1 = require_transactionRequest();
  var getAction_js_1 = require_getAction();
  var assertRequest_js_1 = require_assertRequest();
  var getChainId_js_1 = require_getChainId();
  var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
  var sendRawTransaction_js_1 = require_sendRawTransaction();
  exports.sendTransaction = sendTransaction2;
});

// node_modules/viem/_cjs/actions/wallet/writeContract.js
var require_writeContract = __commonJS((exports) => {
  async function writeContract2(client, parameters) {
    const { abi, address, args, dataSuffix, functionName, ...request } = parameters;
    const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
      abi,
      args,
      functionName
    });
    return (0, getAction_js_1.getAction)(client, sendTransaction_js_1.sendTransaction, "sendTransaction")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...request
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeContract = undefined;
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var getAction_js_1 = require_getAction();
  var sendTransaction_js_1 = require_sendTransaction();
  exports.writeContract = writeContract2;
});

// node_modules/viem/_cjs/actions/getContract.js
var require_getContract = __commonJS((exports) => {
  function getContract2({ abi, address, client: client_ }) {
    const client = client_;
    const [publicClient, walletClient] = (() => {
      if (!client)
        return [undefined, undefined];
      if ("public" in client && "wallet" in client)
        return [client.public, client.wallet];
      if ("public" in client)
        return [client.public, undefined];
      if ("wallet" in client)
        return [undefined, client.wallet];
      return [client, client];
    })();
    const hasPublicClient = publicClient !== undefined && publicClient !== null;
    const hasWalletClient = walletClient !== undefined && walletClient !== null;
    const contract = {};
    let hasReadFunction = false;
    let hasWriteFunction = false;
    let hasEvent = false;
    for (const item of abi) {
      if (item.type === "function")
        if (item.stateMutability === "view" || item.stateMutability === "pure")
          hasReadFunction = true;
        else
          hasWriteFunction = true;
      else if (item.type === "event")
        hasEvent = true;
      if (hasReadFunction && hasWriteFunction && hasEvent)
        break;
    }
    if (hasPublicClient) {
      if (hasReadFunction)
        contract.read = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options: options2 } = getFunctionParameters2(parameters);
              return (0, getAction_js_1.getAction)(publicClient, readContract_js_1.readContract, "readContract")({
                abi,
                address,
                functionName,
                args,
                ...options2
              });
            };
          }
        });
      if (hasWriteFunction)
        contract.simulate = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options: options2 } = getFunctionParameters2(parameters);
              return (0, getAction_js_1.getAction)(publicClient, simulateContract_js_1.simulateContract, "simulateContract")({
                abi,
                address,
                functionName,
                args,
                ...options2
              });
            };
          }
        });
      if (hasEvent) {
        contract.createEventFilter = new Proxy({}, {
          get(_, eventName) {
            return (...parameters) => {
              const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
              const { args, options: options2 } = getEventParameters2(parameters, abiEvent);
              return (0, getAction_js_1.getAction)(publicClient, createContractEventFilter_js_1.createContractEventFilter, "createContractEventFilter")({
                abi,
                address,
                eventName,
                args,
                ...options2
              });
            };
          }
        });
        contract.getEvents = new Proxy({}, {
          get(_, eventName) {
            return (...parameters) => {
              const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
              const { args, options: options2 } = getEventParameters2(parameters, abiEvent);
              return (0, getAction_js_1.getAction)(publicClient, getContractEvents_js_1.getContractEvents, "getContractEvents")({
                abi,
                address,
                eventName,
                args,
                ...options2
              });
            };
          }
        });
        contract.watchEvent = new Proxy({}, {
          get(_, eventName) {
            return (...parameters) => {
              const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
              const { args, options: options2 } = getEventParameters2(parameters, abiEvent);
              return (0, getAction_js_1.getAction)(publicClient, watchContractEvent_js_1.watchContractEvent, "watchContractEvent")({
                abi,
                address,
                eventName,
                args,
                ...options2
              });
            };
          }
        });
      }
    }
    if (hasWalletClient) {
      if (hasWriteFunction)
        contract.write = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options: options2 } = getFunctionParameters2(parameters);
              return (0, getAction_js_1.getAction)(walletClient, writeContract_js_1.writeContract, "writeContract")({
                abi,
                address,
                functionName,
                args,
                ...options2
              });
            };
          }
        });
    }
    if (hasPublicClient || hasWalletClient) {
      if (hasWriteFunction)
        contract.estimateGas = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options: options2 } = getFunctionParameters2(parameters);
              const client2 = publicClient ?? walletClient;
              return (0, getAction_js_1.getAction)(client2, estimateContractGas_js_1.estimateContractGas, "estimateContractGas")({
                abi,
                address,
                functionName,
                args,
                ...options2,
                account: options2.account ?? walletClient.account
              });
            };
          }
        });
    }
    contract.address = address;
    contract.abi = abi;
    return contract;
  }
  function getFunctionParameters2(values) {
    const hasArgs = values.length && Array.isArray(values[0]);
    const args = hasArgs ? values[0] : [];
    const options2 = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options: options2 };
  }
  function getEventParameters2(values, abiEvent) {
    let hasArgs = false;
    if (Array.isArray(values[0]))
      hasArgs = true;
    else if (values.length === 1) {
      hasArgs = abiEvent.inputs.some((x) => x.indexed);
    } else if (values.length === 2) {
      hasArgs = true;
    }
    const args = hasArgs ? values[0] : undefined;
    const options2 = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options: options2 };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEventParameters = exports.getFunctionParameters = exports.getContract = undefined;
  var getAction_js_1 = require_getAction();
  var createContractEventFilter_js_1 = require_createContractEventFilter();
  var estimateContractGas_js_1 = require_estimateContractGas();
  var getContractEvents_js_1 = require_getContractEvents();
  var readContract_js_1 = require_readContract();
  var simulateContract_js_1 = require_simulateContract();
  var watchContractEvent_js_1 = require_watchContractEvent();
  var writeContract_js_1 = require_writeContract();
  exports.getContract = getContract2;
  exports.getFunctionParameters = getFunctionParameters2;
  exports.getEventParameters = getEventParameters2;
});

// node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js
var require_publicKeyToAddress = __commonJS((exports) => {
  function publicKeyToAddress(publicKey) {
    const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
    return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publicKeyToAddress = undefined;
  var getAddress_js_1 = require_getAddress();
  var keccak256_js_1 = require_keccak256();
  exports.publicKeyToAddress = publicKeyToAddress;
});

// node_modules/viem/_cjs/utils/accounts.js
var require_accounts = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publicKeyToAddress = exports.parseAccount = undefined;
  var parseAccount_js_1 = require_parseAccount();
  Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
    return parseAccount_js_1.parseAccount;
  } });
  var publicKeyToAddress_js_1 = require_publicKeyToAddress();
  Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
    return publicKeyToAddress_js_1.publicKeyToAddress;
  } });
});

// node_modules/viem/_cjs/utils/uid.js
var require_uid = __commonJS((exports) => {
  function uid(length = 11) {
    if (!buffer || index + length > size2 * 2) {
      buffer = "";
      index = 0;
      for (let i = 0;i < size2; i++) {
        buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
      }
    }
    return buffer.substring(index, index++ + length);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uid = undefined;
  var size2 = 256;
  var index = size2;
  var buffer;
  exports.uid = uid;
});

// node_modules/viem/_cjs/clients/createClient.js
var require_createClient = __commonJS((exports) => {
  function createClient(parameters) {
    const { batch, cacheTime = parameters.pollingInterval ?? 4000, ccipRead, key = "base", name = "Base Client", pollingInterval = 4000, type = "base" } = parameters;
    const chain = parameters.chain;
    const account = parameters.account ? (0, accounts_js_1.parseAccount)(parameters.account) : undefined;
    const { config, request, value } = parameters.transport({
      chain,
      pollingInterval
    });
    const transport = { ...config, ...value };
    const client = {
      account,
      batch,
      cacheTime,
      ccipRead,
      chain,
      key,
      name,
      pollingInterval,
      request,
      transport,
      type,
      uid: (0, uid_js_1.uid)()
    };
    function extend(base) {
      return (extendFn) => {
        const extended = extendFn(base);
        for (const key2 in client)
          delete extended[key2];
        const combined = { ...base, ...extended };
        return Object.assign(combined, { extend: extend(combined) });
      };
    }
    return Object.assign(client, { extend: extend(client) });
  }
  function rpcSchema() {
    return null;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rpcSchema = exports.createClient = undefined;
  var accounts_js_1 = require_accounts();
  var uid_js_1 = require_uid();
  exports.createClient = createClient;
  exports.rpcSchema = rpcSchema;
});

// node_modules/viem/_cjs/utils/promise/withRetry.js
var require_withRetry = __commonJS((exports) => {
  function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
    return new Promise((resolve, reject) => {
      const attemptRetry = async ({ count = 0 } = {}) => {
        const retry = async ({ error }) => {
          const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
          if (delay)
            await (0, wait_js_1.wait)(delay);
          attemptRetry({ count: count + 1 });
        };
        try {
          const data = await fn();
          resolve(data);
        } catch (err) {
          if (count < retryCount && await shouldRetry({ count, error: err }))
            return retry({ error: err });
          reject(err);
        }
      };
      attemptRetry();
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withRetry = undefined;
  var wait_js_1 = require_wait();
  exports.withRetry = withRetry;
});

// node_modules/viem/_cjs/utils/buildRequest.js
var require_buildRequest = __commonJS((exports) => {
  function buildRequest(request, options2 = {}) {
    return async (args, overrideOptions = {}) => {
      const { retryDelay = 150, retryCount = 3 } = {
        ...options2,
        ...overrideOptions
      };
      return (0, withRetry_js_1.withRetry)(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            case rpc_js_1.ParseRpcError.code:
              throw new rpc_js_1.ParseRpcError(err);
            case rpc_js_1.InvalidRequestRpcError.code:
              throw new rpc_js_1.InvalidRequestRpcError(err);
            case rpc_js_1.MethodNotFoundRpcError.code:
              throw new rpc_js_1.MethodNotFoundRpcError(err);
            case rpc_js_1.InvalidParamsRpcError.code:
              throw new rpc_js_1.InvalidParamsRpcError(err);
            case rpc_js_1.InternalRpcError.code:
              throw new rpc_js_1.InternalRpcError(err);
            case rpc_js_1.InvalidInputRpcError.code:
              throw new rpc_js_1.InvalidInputRpcError(err);
            case rpc_js_1.ResourceNotFoundRpcError.code:
              throw new rpc_js_1.ResourceNotFoundRpcError(err);
            case rpc_js_1.ResourceUnavailableRpcError.code:
              throw new rpc_js_1.ResourceUnavailableRpcError(err);
            case rpc_js_1.TransactionRejectedRpcError.code:
              throw new rpc_js_1.TransactionRejectedRpcError(err);
            case rpc_js_1.MethodNotSupportedRpcError.code:
              throw new rpc_js_1.MethodNotSupportedRpcError(err);
            case rpc_js_1.LimitExceededRpcError.code:
              throw new rpc_js_1.LimitExceededRpcError(err);
            case rpc_js_1.JsonRpcVersionUnsupportedError.code:
              throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
            case rpc_js_1.UserRejectedRequestError.code:
              throw new rpc_js_1.UserRejectedRequestError(err);
            case rpc_js_1.UnauthorizedProviderError.code:
              throw new rpc_js_1.UnauthorizedProviderError(err);
            case rpc_js_1.UnsupportedProviderMethodError.code:
              throw new rpc_js_1.UnsupportedProviderMethodError(err);
            case rpc_js_1.ProviderDisconnectedError.code:
              throw new rpc_js_1.ProviderDisconnectedError(err);
            case rpc_js_1.ChainDisconnectedError.code:
              throw new rpc_js_1.ChainDisconnectedError(err);
            case rpc_js_1.SwitchChainError.code:
              throw new rpc_js_1.SwitchChainError(err);
            case 5000:
              throw new rpc_js_1.UserRejectedRequestError(err);
            default:
              if (err_ instanceof base_js_1.BaseError)
                throw err_;
              throw new rpc_js_1.UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof request_js_1.HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return parseInt(retryAfter) * 1000;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => shouldRetry(error)
      });
    };
  }
  function shouldRetry(error) {
    if ("code" in error && typeof error.code === "number") {
      if (error.code === -1)
        return true;
      if (error.code === rpc_js_1.LimitExceededRpcError.code)
        return true;
      if (error.code === rpc_js_1.InternalRpcError.code)
        return true;
      return false;
    }
    if (error instanceof request_js_1.HttpRequestError && error.status) {
      if (error.status === 403)
        return true;
      if (error.status === 408)
        return true;
      if (error.status === 413)
        return true;
      if (error.status === 429)
        return true;
      if (error.status === 500)
        return true;
      if (error.status === 502)
        return true;
      if (error.status === 503)
        return true;
      if (error.status === 504)
        return true;
      return false;
    }
    return true;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldRetry = exports.buildRequest = undefined;
  var base_js_1 = require_base();
  var request_js_1 = require_request();
  var rpc_js_1 = require_rpc();
  var withRetry_js_1 = require_withRetry();
  exports.buildRequest = buildRequest;
  exports.shouldRetry = shouldRetry;
});

// node_modules/viem/_cjs/clients/transports/createTransport.js
var require_createTransport = __commonJS((exports) => {
  function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    return {
      config: { key, name, request, retryCount, retryDelay, timeout, type },
      request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay }),
      value
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransport = undefined;
  var buildRequest_js_1 = require_buildRequest();
  exports.createTransport = createTransport;
});

// node_modules/viem/_cjs/clients/transports/custom.js
var require_custom = __commonJS((exports) => {
  function custom(provider, config = {}) {
    const { key = "custom", name = "Custom Provider", retryDelay } = config;
    return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
      key,
      name,
      request: provider.request.bind(provider),
      retryCount: config.retryCount ?? defaultRetryCount,
      retryDelay,
      type: "custom"
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.custom = undefined;
  var createTransport_js_1 = require_createTransport();
  exports.custom = custom;
});

// node_modules/viem/_cjs/clients/transports/fallback.js
var require_fallback = __commonJS((exports) => {
  function fallback(transports_, config = {}) {
    const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
    return ({ chain, pollingInterval = 4000, timeout, ...rest }) => {
      let transports = transports_;
      let onResponse = () => {
      };
      const transport = (0, createTransport_js_1.createTransport)({
        key,
        name,
        async request({ method, params }) {
          const fetch2 = async (i = 0) => {
            const transport2 = transports[i]({
              ...rest,
              chain,
              retryCount: 0,
              timeout
            });
            try {
              const response = await transport2.request({
                method,
                params
              });
              onResponse({
                method,
                params,
                response,
                transport: transport2,
                status: "success"
              });
              return response;
            } catch (err) {
              onResponse({
                error: err,
                method,
                params,
                transport: transport2,
                status: "error"
              });
              if (shouldThrow(err))
                throw err;
              if (i === transports.length - 1)
                throw err;
              return fetch2(i + 1);
            }
          };
          return fetch2();
        },
        retryCount,
        retryDelay,
        type: "fallback"
      }, {
        onResponse: (fn) => onResponse = fn,
        transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
      });
      if (rank) {
        const rankOptions = typeof rank === "object" ? rank : {};
        rankTransports({
          chain,
          interval: rankOptions.interval ?? pollingInterval,
          onTransports: (transports_2) => transports = transports_2,
          sampleCount: rankOptions.sampleCount,
          timeout: rankOptions.timeout,
          transports,
          weights: rankOptions.weights
        });
      }
      return transport;
    };
  }
  function shouldThrow(error) {
    if ("code" in error && typeof error.code === "number") {
      if (error.code === rpc_js_1.TransactionRejectedRpcError.code || error.code === rpc_js_1.UserRejectedRequestError.code || error.code === 5000)
        return true;
    }
    return false;
  }
  function rankTransports({ chain, interval = 4000, onTransports, sampleCount = 10, timeout = 1000, transports, weights = {} }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async () => {
      const sample = await Promise.all(transports.map(async (transport) => {
        const transport_ = transport({ chain, retryCount: 0, timeout });
        const start = Date.now();
        let end;
        let success;
        try {
          await transport_.request({ method: "net_listening" });
          success = 1;
        } catch {
          success = 0;
        } finally {
          end = Date.now();
        }
        const latency = end - start;
        return { latency, success };
      }));
      samples.push(sample);
      if (samples.length > sampleCount)
        samples.shift();
      const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
      const scores = transports.map((_, i) => {
        const latencies = samples.map((sample2) => sample2[i].latency);
        const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
        const latencyScore = 1 - meanLatency / maxLatency;
        const successes = samples.map((sample2) => sample2[i].success);
        const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
        if (stabilityScore === 0)
          return [0, i];
        return [
          latencyWeight * latencyScore + stabilityWeight * stabilityScore,
          i
        ];
      }).sort((a, b) => b[0] - a[0]);
      onTransports(scores.map(([, i]) => transports[i]));
      await (0, wait_js_1.wait)(interval);
      rankTransports_();
    };
    rankTransports_();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rankTransports = exports.fallback = undefined;
  var rpc_js_1 = require_rpc();
  var wait_js_1 = require_wait();
  var createTransport_js_1 = require_createTransport();
  exports.fallback = fallback;
  exports.rankTransports = rankTransports;
});

// node_modules/viem/_cjs/errors/transport.js
var require_transport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UrlRequiredError = undefined;
  var base_js_1 = require_base();

  class UrlRequiredError extends base_js_1.BaseError {
    constructor() {
      super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
        docsPath: "/docs/clients/intro"
      });
    }
  }
  exports.UrlRequiredError = UrlRequiredError;
});

// node_modules/viem/_cjs/utils/promise/withTimeout.js
var require_withTimeout = __commonJS((exports) => {
  function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
    return new Promise((resolve, reject) => {
      (async () => {
        let timeoutId;
        try {
          const controller = new AbortController;
          if (timeout > 0) {
            timeoutId = setTimeout(() => {
              if (signal) {
                controller.abort();
              } else {
                reject(errorInstance);
              }
            }, timeout);
          }
          resolve(await fn({ signal: controller?.signal || null }));
        } catch (err) {
          if (err.name === "AbortError")
            reject(errorInstance);
          reject(err);
        } finally {
          clearTimeout(timeoutId);
        }
      })();
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withTimeout = undefined;
  exports.withTimeout = withTimeout;
});

// node_modules/viem/_cjs/utils/rpc/id.js
var require_id = __commonJS((exports) => {
  function createIdStore() {
    return {
      current: 0,
      take() {
        return this.current++;
      },
      reset() {
        this.current = 0;
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.idCache = exports.createIdStore = undefined;
  exports.createIdStore = createIdStore;
  exports.idCache = createIdStore();
});

// node_modules/viem/_cjs/utils/rpc/http.js
var require_http = __commonJS((exports) => {
  function getHttpRpcClient(url, options2 = {}) {
    return {
      async request(params) {
        const { body, fetchOptions = {}, onRequest = options2.onRequest, onResponse = options2.onResponse, timeout = options2.timeout ?? 1e4 } = params;
        const { headers, method, signal: signal_ } = { ...options2.fetchOptions, ...fetchOptions };
        try {
          const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
            const init = {
              ...fetchOptions,
              body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map((body2) => ({
                jsonrpc: "2.0",
                id: body2.id ?? id_js_1.idCache.take(),
                ...body2
              }))) : (0, stringify_js_1.stringify)({
                jsonrpc: "2.0",
                id: body.id ?? id_js_1.idCache.take(),
                ...body
              }),
              headers: {
                ...headers,
                "Content-Type": "application/json"
              },
              method: method || "POST",
              signal: signal_ || (timeout > 0 ? signal : null)
            };
            const request = new Request(url, init);
            if (onRequest)
              await onRequest(request);
            const response2 = await fetch(url, init);
            return response2;
          }, {
            errorInstance: new request_js_1.TimeoutError({ body, url }),
            timeout,
            signal: true
          });
          if (onResponse)
            await onResponse(response);
          let data;
          if (response.headers.get("Content-Type")?.startsWith("application/json"))
            data = await response.json();
          else
            data = await response.text();
          if (!response.ok) {
            throw new request_js_1.HttpRequestError({
              body,
              details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
          }
          return data;
        } catch (err) {
          if (err instanceof request_js_1.HttpRequestError)
            throw err;
          if (err instanceof request_js_1.TimeoutError)
            throw err;
          throw new request_js_1.HttpRequestError({
            body,
            details: err.message,
            url
          });
        }
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHttpRpcClient = undefined;
  var request_js_1 = require_request();
  var withTimeout_js_1 = require_withTimeout();
  var stringify_js_1 = require_stringify();
  var id_js_1 = require_id();
  exports.getHttpRpcClient = getHttpRpcClient;
});

// node_modules/viem/_cjs/clients/transports/http.js
var require_http2 = __commonJS((exports) => {
  function http(url, config = {}) {
    const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const { batchSize = 1000, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
      const retryCount = config.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.http[0];
      if (!url_)
        throw new transport_js_1.UrlRequiredError;
      const rpcClient = (0, http_js_1.getHttpRpcClient)(url_, {
        fetchOptions,
        onRequest: onFetchRequest,
        onResponse: onFetchResponse,
        timeout
      });
      return (0, createTransport_js_1.createTransport)({
        key,
        name,
        async request({ method, params }) {
          const body = { method, params };
          const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
            id: `${url}`,
            wait: wait2,
            shouldSplitBatch(requests) {
              return requests.length > batchSize;
            },
            fn: (body2) => rpcClient.request({
              body: body2
            }),
            sort: (a, b) => a.id - b.id
          });
          const fn = async (body2) => batch ? schedule(body2) : [
            await rpcClient.request({
              body: body2
            })
          ];
          const [{ error, result }] = await fn(body);
          if (error)
            throw new request_js_1.RpcRequestError({
              body,
              error,
              url: url_
            });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "http"
      }, {
        fetchOptions,
        url: url_
      });
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.http = undefined;
  var request_js_1 = require_request();
  var transport_js_1 = require_transport();
  var createBatchScheduler_js_1 = require_createBatchScheduler();
  var http_js_1 = require_http();
  var createTransport_js_1 = require_createTransport();
  exports.http = http;
});

// node_modules/viem/_cjs/utils/ens/errors.js
var require_errors2 = __commonJS((exports) => {
  function isNullUniversalResolverError(err, callType) {
    if (!(err instanceof base_js_1.BaseError))
      return false;
    const cause = err.walk((e) => e instanceof contract_js_1.ContractFunctionRevertedError);
    if (!(cause instanceof contract_js_1.ContractFunctionRevertedError))
      return false;
    if (cause.data?.errorName === "ResolverNotFound")
      return true;
    if (cause.data?.errorName === "ResolverWildcardNotSupported")
      return true;
    if (cause.data?.errorName === "ResolverNotContract")
      return true;
    if (cause.data?.errorName === "ResolverError")
      return true;
    if (cause.data?.errorName === "HttpError")
      return true;
    if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
      return true;
    if (callType === "reverse" && cause.reason === solidity_js_1.panicReasons[50])
      return true;
    return false;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNullUniversalResolverError = undefined;
  var solidity_js_1 = require_solidity();
  var base_js_1 = require_base();
  var contract_js_1 = require_contract();
  exports.isNullUniversalResolverError = isNullUniversalResolverError;
});

// node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js
var require_encodedLabelToLabelhash = __commonJS((exports) => {
  function encodedLabelToLabelhash(label) {
    if (label.length !== 66)
      return null;
    if (label.indexOf("[") !== 0)
      return null;
    if (label.indexOf("]") !== 65)
      return null;
    const hash2 = `0x${label.slice(1, 65)}`;
    if (!(0, isHex_js_1.isHex)(hash2))
      return null;
    return hash2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodedLabelToLabelhash = undefined;
  var isHex_js_1 = require_isHex();
  exports.encodedLabelToLabelhash = encodedLabelToLabelhash;
});

// node_modules/viem/_cjs/utils/ens/namehash.js
var require_namehash = __commonJS((exports) => {
  function namehash(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name)
      return (0, toHex_js_1.bytesToHex)(result);
    const labels = name.split(".");
    for (let i = labels.length - 1;i >= 0; i -= 1) {
      const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i]);
      const hashed = hashFromEncodedLabel ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel) : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i]), "bytes");
      result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), "bytes");
    }
    return (0, toHex_js_1.bytesToHex)(result);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.namehash = undefined;
  var concat_js_1 = require_concat();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  var keccak256_js_1 = require_keccak256();
  var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
  exports.namehash = namehash;
});

// node_modules/viem/_cjs/utils/ens/encodeLabelhash.js
var require_encodeLabelhash = __commonJS((exports) => {
  function encodeLabelhash(hash2) {
    return `[${hash2.slice(2)}]`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeLabelhash = undefined;
  exports.encodeLabelhash = encodeLabelhash;
});

// node_modules/viem/_cjs/utils/ens/labelhash.js
var require_labelhash = __commonJS((exports) => {
  function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label)
      return (0, toHex_js_1.bytesToHex)(result);
    return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.labelhash = undefined;
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  var keccak256_js_1 = require_keccak256();
  var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
  exports.labelhash = labelhash;
});

// node_modules/viem/_cjs/utils/ens/packetToBytes.js
var require_packetToBytes = __commonJS((exports) => {
  function packetToBytes(packet) {
    const value = packet.replace(/^\.|\.$/gm, "");
    if (value.length === 0)
      return new Uint8Array(1);
    const bytes2 = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
    let offset = 0;
    const list = value.split(".");
    for (let i = 0;i < list.length; i++) {
      let encoded = (0, toBytes_js_1.stringToBytes)(list[i]);
      if (encoded.byteLength > 255)
        encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
      bytes2[offset] = encoded.length;
      bytes2.set(encoded, offset + 1);
      offset += encoded.length + 1;
    }
    if (bytes2.byteLength !== offset + 1)
      return bytes2.slice(0, offset + 1);
    return bytes2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.packetToBytes = undefined;
  var toBytes_js_1 = require_toBytes();
  var encodeLabelhash_js_1 = require_encodeLabelhash();
  var labelhash_js_1 = require_labelhash();
  exports.packetToBytes = packetToBytes;
});

// node_modules/viem/_cjs/actions/ens/getEnsAddress.js
var require_getEnsAddress = __commonJS((exports) => {
  async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    try {
      const functionData = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi: abis_js_1.addressResolverAbi,
        functionName: "addr",
        ...coinType != null ? { args: [(0, namehash_js_1.namehash)(name), BigInt(coinType)] } : { args: [(0, namehash_js_1.namehash)(name)] }
      });
      const readContractParameters = {
        address: universalResolverAddress,
        abi: abis_js_1.universalResolverResolveAbi,
        functionName: "resolve",
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)), functionData],
        blockNumber,
        blockTag
      };
      const readContractAction = (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract");
      const res = gatewayUrls ? await readContractAction({
        ...readContractParameters,
        args: [...readContractParameters.args, gatewayUrls]
      }) : await readContractAction(readContractParameters);
      if (res[0] === "0x")
        return null;
      const address = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
        abi: abis_js_1.addressResolverAbi,
        args: coinType != null ? [(0, namehash_js_1.namehash)(name), BigInt(coinType)] : undefined,
        functionName: "addr",
        data: res[0]
      });
      if (address === "0x")
        return null;
      if ((0, trim_js_1.trim)(address) === "0x00")
        return null;
      return address;
    } catch (err) {
      if (strict)
        throw err;
      if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
        return null;
      throw err;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEnsAddress = undefined;
  var abis_js_1 = require_abis();
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  var trim_js_1 = require_trim();
  var toHex_js_1 = require_toHex();
  var errors_js_1 = require_errors2();
  var namehash_js_1 = require_namehash();
  var packetToBytes_js_1 = require_packetToBytes();
  var getAction_js_1 = require_getAction();
  var readContract_js_1 = require_readContract();
  exports.getEnsAddress = getEnsAddress;
});

// node_modules/viem/_cjs/errors/ens.js
var require_ens = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarInvalidMetadataError = undefined;
  var base_js_1 = require_base();

  class EnsAvatarInvalidMetadataError extends base_js_1.BaseError {
    constructor({ data }) {
      super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
        metaMessages: [
          "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
          "",
          `Provided data: ${JSON.stringify(data)}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarInvalidMetadataError"
      });
    }
  }
  exports.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;

  class EnsAvatarInvalidNftUriError extends base_js_1.BaseError {
    constructor({ reason }) {
      super(`ENS NFT avatar URI is invalid. ${reason}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarInvalidNftUriError"
      });
    }
  }
  exports.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;

  class EnsAvatarUriResolutionError extends base_js_1.BaseError {
    constructor({ uri }) {
      super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarUriResolutionError"
      });
    }
  }
  exports.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;

  class EnsAvatarUnsupportedNamespaceError extends base_js_1.BaseError {
    constructor({ namespace }) {
      super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarUnsupportedNamespaceError"
      });
    }
  }
  exports.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;
});

// node_modules/viem/_cjs/utils/ens/avatar/utils.js
var require_utils4 = __commonJS((exports) => {
  async function isImageUri(uri) {
    try {
      const res = await fetch(uri, { method: "HEAD" });
      if (res.status === 200) {
        const contentType = res.headers.get("content-type");
        return contentType?.startsWith("image/");
      }
      return false;
    } catch (error) {
      if (typeof error === "object" && typeof error.response !== "undefined") {
        return false;
      }
      if (!globalThis.hasOwnProperty("Image"))
        return false;
      return new Promise((resolve) => {
        const img = new Image;
        img.onload = () => {
          resolve(true);
        };
        img.onerror = () => {
          resolve(false);
        };
        img.src = uri;
      });
    }
  }
  function getGateway(custom, defaultGateway) {
    if (!custom)
      return defaultGateway;
    if (custom.endsWith("/"))
      return custom.slice(0, -1);
    return custom;
  }
  function resolveAvatarUri({ uri, gatewayUrls }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded)
      return { uri, isOnChain: true, isEncoded };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
    const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
    const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
    if (uri.startsWith("http") && !isIPNS && !isIPFS) {
      let replacedUri = uri;
      if (gatewayUrls?.arweave)
        replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
      return { uri: replacedUri, isOnChain: false, isEncoded: false };
    }
    if ((isIPNS || isIPFS) && target) {
      return {
        uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    if (protocol === "ar:/" && target) {
      return {
        uri: `${arweaveGateway}/${target}${subtarget || ""}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    let parsedUri = uri.replace(dataURIRegex, "");
    if (parsedUri.startsWith("<svg")) {
      parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    }
    if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
      return {
        uri: parsedUri,
        isOnChain: true,
        isEncoded: false
      };
    }
    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
  }
  function getJsonImage(data) {
    if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
      throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
    }
    return data.image || data.image_url || data.image_data;
  }
  async function getMetadataAvatarUri({ gatewayUrls, uri }) {
    try {
      const res = await fetch(uri).then((res2) => res2.json());
      const image = await parseAvatarUri({
        gatewayUrls,
        uri: getJsonImage(res)
      });
      return image;
    } catch {
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
  }
  async function parseAvatarUri({ gatewayUrls, uri }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
    if (isOnChain)
      return resolvedURI;
    const isImage = await isImageUri(resolvedURI);
    if (isImage)
      return resolvedURI;
    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
  }
  function parseNftUri(uri_) {
    let uri = uri_;
    if (uri.startsWith("did:nft:")) {
      uri = uri.replace("did:nft:", "").replace(/_/g, "/");
    }
    const [reference, asset_namespace, tokenID] = uri.split("/");
    const [eip_namespace, chainID] = reference.split(":");
    const [erc_namespace, contractAddress] = asset_namespace.split(":");
    if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
      throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
    if (!chainID)
      throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
    if (!contractAddress)
      throw new ens_js_1.EnsAvatarInvalidNftUriError({
        reason: "Contract address not found"
      });
    if (!tokenID)
      throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
    if (!erc_namespace)
      throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
    return {
      chainID: parseInt(chainID),
      namespace: erc_namespace.toLowerCase(),
      contractAddress,
      tokenID
    };
  }
  async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === "erc721") {
      return (0, readContract_js_1.readContract)(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "tokenURI",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "tokenId", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "tokenURI",
        args: [BigInt(nft.tokenID)]
      });
    }
    if (nft.namespace === "erc1155") {
      return (0, readContract_js_1.readContract)(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "uri",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "_id", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "uri",
        args: [BigInt(nft.tokenID)]
      });
    }
    throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = undefined;
  var readContract_js_1 = require_readContract();
  var ens_js_1 = require_ens();
  var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
  var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
  var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
  var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
  exports.isImageUri = isImageUri;
  exports.getGateway = getGateway;
  exports.resolveAvatarUri = resolveAvatarUri;
  exports.getJsonImage = getJsonImage;
  exports.getMetadataAvatarUri = getMetadataAvatarUri;
  exports.parseAvatarUri = parseAvatarUri;
  exports.parseNftUri = parseNftUri;
  exports.getNftTokenUri = getNftTokenUri;
});

// node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js
var require_parseAvatarRecord = __commonJS((exports) => {
  async function parseAvatarRecord(client, { gatewayUrls, record }) {
    if (/eip155:/i.test(record))
      return parseNftAvatarUri(client, { gatewayUrls, record });
    return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
  }
  async function parseNftAvatarUri(client, { gatewayUrls, record }) {
    const nft = (0, utils_js_1.parseNftUri)(record);
    const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
    const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
    if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
      const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
      const decoded = JSON.parse(encodedJson);
      return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === "erc1155")
      uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
    return (0, utils_js_1.getMetadataAvatarUri)({
      gatewayUrls,
      uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAvatarRecord = undefined;
  var utils_js_1 = require_utils4();
  exports.parseAvatarRecord = parseAvatarRecord;
});

// node_modules/viem/_cjs/actions/ens/getEnsText.js
var require_getEnsText = __commonJS((exports) => {
  async function getEnsText(client, { blockNumber, blockTag, name, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    try {
      const readContractParameters = {
        address: universalResolverAddress,
        abi: abis_js_1.universalResolverResolveAbi,
        functionName: "resolve",
        args: [
          (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
          (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.textResolverAbi,
            functionName: "text",
            args: [(0, namehash_js_1.namehash)(name), key]
          })
        ],
        blockNumber,
        blockTag
      };
      const readContractAction = (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract");
      const res = gatewayUrls ? await readContractAction({
        ...readContractParameters,
        args: [...readContractParameters.args, gatewayUrls]
      }) : await readContractAction(readContractParameters);
      if (res[0] === "0x")
        return null;
      const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
        abi: abis_js_1.textResolverAbi,
        functionName: "text",
        data: res[0]
      });
      return record === "" ? null : record;
    } catch (err) {
      if (strict)
        throw err;
      if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
        return null;
      throw err;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEnsText = undefined;
  var abis_js_1 = require_abis();
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  var toHex_js_1 = require_toHex();
  var errors_js_1 = require_errors2();
  var namehash_js_1 = require_namehash();
  var packetToBytes_js_1 = require_packetToBytes();
  var getAction_js_1 = require_getAction();
  var readContract_js_1 = require_readContract();
  exports.getEnsText = getEnsText;
});

// node_modules/viem/_cjs/actions/ens/getEnsAvatar.js
var require_getEnsAvatar = __commonJS((exports) => {
  async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
    const record = await (0, getAction_js_1.getAction)(client, getEnsText_js_1.getEnsText, "getEnsText")({
      blockNumber,
      blockTag,
      key: "avatar",
      name,
      universalResolverAddress,
      gatewayUrls,
      strict
    });
    if (!record)
      return null;
    try {
      return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, {
        record,
        gatewayUrls: assetGatewayUrls
      });
    } catch {
      return null;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEnsAvatar = undefined;
  var parseAvatarRecord_js_1 = require_parseAvatarRecord();
  var getAction_js_1 = require_getAction();
  var getEnsText_js_1 = require_getEnsText();
  exports.getEnsAvatar = getEnsAvatar;
});

// node_modules/viem/_cjs/actions/ens/getEnsName.js
var require_getEnsName = __commonJS((exports) => {
  async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
      const readContractParameters = {
        address: universalResolverAddress,
        abi: abis_js_1.universalResolverReverseAbi,
        functionName: "reverse",
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(reverseNode))],
        blockNumber,
        blockTag
      };
      const readContractAction = (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract");
      const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
        ...readContractParameters,
        args: [...readContractParameters.args, gatewayUrls]
      }) : await readContractAction(readContractParameters);
      if (address.toLowerCase() !== resolvedAddress.toLowerCase())
        return null;
      return name;
    } catch (err) {
      if (strict)
        throw err;
      if ((0, errors_js_1.isNullUniversalResolverError)(err, "reverse"))
        return null;
      throw err;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEnsName = undefined;
  var abis_js_1 = require_abis();
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  var toHex_js_1 = require_toHex();
  var errors_js_1 = require_errors2();
  var packetToBytes_js_1 = require_packetToBytes();
  var getAction_js_1 = require_getAction();
  var readContract_js_1 = require_readContract();
  exports.getEnsName = getEnsName;
});

// node_modules/viem/_cjs/actions/ens/getEnsResolver.js
var require_getEnsResolver = __commonJS((exports) => {
  async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const [resolverAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
      address: universalResolverAddress,
      abi: [
        {
          inputs: [{ type: "bytes" }],
          name: "findResolver",
          outputs: [{ type: "address" }, { type: "bytes32" }],
          stateMutability: "view",
          type: "function"
        }
      ],
      functionName: "findResolver",
      args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
      blockNumber,
      blockTag
    });
    return resolverAddress;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEnsResolver = undefined;
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  var toHex_js_1 = require_toHex();
  var packetToBytes_js_1 = require_packetToBytes();
  var getAction_js_1 = require_getAction();
  var readContract_js_1 = require_readContract();
  exports.getEnsResolver = getEnsResolver;
});

// node_modules/viem/_cjs/actions/public/createBlockFilter.js
var require_createBlockFilter = __commonJS((exports) => {
  async function createBlockFilter(client) {
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
      method: "eth_newBlockFilter"
    });
    const id = await client.request({
      method: "eth_newBlockFilter"
    });
    return { id, request: getRequest(id), type: "block" };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createBlockFilter = undefined;
  var createFilterRequestScope_js_1 = require_createFilterRequestScope();
  exports.createBlockFilter = createBlockFilter;
});

// node_modules/viem/_cjs/actions/public/createEventFilter.js
var require_createEventFilter = __commonJS((exports) => {
  async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
    const events = events_ ?? (event ? [event] : undefined);
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
      method: "eth_newFilter"
    });
    let topics = [];
    if (events) {
      topics = [
        events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
          abi: [event2],
          eventName: event2.name,
          args
        }))
      ];
      if (event)
        topics = topics[0];
    }
    const id = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
          ...topics.length ? { topics } : {}
        }
      ]
    });
    return {
      abi: events,
      args,
      eventName: event ? event.name : undefined,
      fromBlock,
      id,
      request: getRequest(id),
      strict: Boolean(strict),
      toBlock,
      type: "event"
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createEventFilter = undefined;
  var encodeEventTopics_js_1 = require_encodeEventTopics();
  var toHex_js_1 = require_toHex();
  var createFilterRequestScope_js_1 = require_createFilterRequestScope();
  exports.createEventFilter = createEventFilter;
});

// node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js
var require_createPendingTransactionFilter = __commonJS((exports) => {
  async function createPendingTransactionFilter(client) {
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
      method: "eth_newPendingTransactionFilter"
    });
    const id = await client.request({
      method: "eth_newPendingTransactionFilter"
    });
    return { id, request: getRequest(id), type: "transaction" };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPendingTransactionFilter = undefined;
  var createFilterRequestScope_js_1 = require_createFilterRequestScope();
  exports.createPendingTransactionFilter = createPendingTransactionFilter;
});

// node_modules/viem/_cjs/actions/public/getBalance.js
var require_getBalance = __commonJS((exports) => {
  async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const balance = await client.request({
      method: "eth_getBalance",
      params: [address, blockNumberHex || blockTag]
    });
    return BigInt(balance);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBalance = undefined;
  var toHex_js_1 = require_toHex();
  exports.getBalance = getBalance;
});

// node_modules/viem/_cjs/actions/public/getBlobBaseFee.js
var require_getBlobBaseFee = __commonJS((exports) => {
  async function getBlobBaseFee(client) {
    const baseFee = await client.request({
      method: "eth_blobBaseFee"
    });
    return BigInt(baseFee);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBlobBaseFee = undefined;
  exports.getBlobBaseFee = getBlobBaseFee;
});

// node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js
var require_getBlockTransactionCount = __commonJS((exports) => {
  async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let count;
    if (blockHash) {
      count = await client.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [blockHash]
      });
    } else {
      count = await client.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [blockNumberHex || blockTag]
      });
    }
    return (0, fromHex_js_1.hexToNumber)(count);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBlockTransactionCount = undefined;
  var fromHex_js_1 = require_fromHex();
  var toHex_js_1 = require_toHex();
  exports.getBlockTransactionCount = getBlockTransactionCount;
});

// node_modules/viem/_cjs/actions/public/getBytecode.js
var require_getBytecode = __commonJS((exports) => {
  async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const hex = await client.request({
      method: "eth_getCode",
      params: [address, blockNumberHex || blockTag]
    });
    if (hex === "0x")
      return;
    return hex;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBytecode = undefined;
  var toHex_js_1 = require_toHex();
  exports.getBytecode = getBytecode;
});

// node_modules/viem/_cjs/utils/formatters/feeHistory.js
var require_feeHistory = __commonJS((exports) => {
  function formatFeeHistory(feeHistory) {
    return {
      baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
      gasUsedRatio: feeHistory.gasUsedRatio,
      oldestBlock: BigInt(feeHistory.oldestBlock),
      reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatFeeHistory = undefined;
  exports.formatFeeHistory = formatFeeHistory;
});

// node_modules/viem/_cjs/actions/public/getFeeHistory.js
var require_getFeeHistory = __commonJS((exports) => {
  async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const feeHistory = await client.request({
      method: "eth_feeHistory",
      params: [
        (0, toHex_js_1.numberToHex)(blockCount),
        blockNumberHex || blockTag,
        rewardPercentiles
      ]
    });
    return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFeeHistory = undefined;
  var toHex_js_1 = require_toHex();
  var feeHistory_js_1 = require_feeHistory();
  exports.getFeeHistory = getFeeHistory;
});

// node_modules/viem/_cjs/actions/public/getFilterLogs.js
var require_getFilterLogs = __commonJS((exports) => {
  async function getFilterLogs(_client, { filter }) {
    const strict = filter.strict ?? false;
    const logs = await filter.request({
      method: "eth_getFilterLogs",
      params: [filter.id]
    });
    const formattedLogs = logs.map((log) => (0, log_js_1.formatLog)(log));
    if (!filter.abi)
      return formattedLogs;
    return (0, parseEventLogs_js_1.parseEventLogs)({
      abi: filter.abi,
      logs: formattedLogs,
      strict
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFilterLogs = undefined;
  var parseEventLogs_js_1 = require_parseEventLogs();
  var log_js_1 = require_log();
  exports.getFilterLogs = getFilterLogs;
});

// node_modules/viem/_cjs/utils/chain/extractChain.js
var require_extractChain = __commonJS((exports) => {
  function extractChain({ chains, id }) {
    return chains.find((chain) => chain.id === id);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractChain = undefined;
  exports.extractChain = extractChain;
});

// node_modules/viem/_cjs/utils/regex.js
var require_regex2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.integerRegex = exports.bytesRegex = exports.arrayRegex = undefined;
  exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
  exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  function concat2(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output2, offset, length) {
    for (let i = 0;i < length; i++) {
      output2[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  module.exports = {
    concat: concat2,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error(`Cannot require module "bufferutil"`);})();
      module.exports.mask = function(source, mask, output2, offset, length) {
        if (length < 48)
          _mask(source, mask, output2, offset, length);
        else
          bufferUtil.mask(source, mask, output2, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options2, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options2 || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  var { isUtf8 } = __require("buffer");
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error(`Cannot require module "utf-8-validate"`);})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  function error(ErrorCtor, message, prefix, statusCode, errorCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, error);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat: concat2, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;

  class Receiver extends Writable {
    constructor(options2 = {}) {
      super();
      this._binaryType = options2.binaryType || BINARY_TYPES[0];
      this._extensions = options2.extensions || {};
      this._isServer = !!options2.isServer;
      this._maxPayload = options2.maxPayload | 0;
      this._skipUTF8Validation = !!options2.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._state = GET_INFO;
      this._loop = false;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      let err;
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;
          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;
          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            err = this.getData(cb);
            break;
          default:
            this._loop = false;
            return;
        }
      } while (this._loop);
      cb(err);
    }
    getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        this._loop = false;
        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
        }
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          this._loop = false;
          return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        }
      } else {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        return this.haveLength();
    }
    getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    haveLength() {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7)
        return this.controlMessage(data);
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      return this.dataMessage();
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
          }
          this._fragments.push(buf);
        }
        const er = this.dataMessage();
        if (er)
          return cb(er);
        this.startLoop(cb);
      });
    }
    dataMessage() {
      if (this._fin) {
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat2(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat2(fragments, messageLength));
          } else {
            data = fragments;
          }
          this.emit("message", data, true);
        } else {
          const buf = concat2(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("message", buf, false);
        }
      }
      this._state = GET_INFO;
    }
    controlMessage(data) {
      if (this._opcode === 8) {
        this._loop = false;
        if (data.length === 0) {
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("conclude", code, buf);
          this.end();
        }
      } else if (this._opcode === 9) {
        this.emit("ping", data);
      } else {
        this.emit("pong", data);
      }
      this._state = GET_INFO;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var net = __require("net");
  var tls = __require("tls");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options2) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options2.mask) {
        mask = options2.maskBuffer || maskBuffer;
        if (options2.generateMask) {
          options2.generateMask(mask);
        } else {
          randomFillSync(mask, 0, 4);
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options2.mask || skipMasking) && options2[kByteLength] !== undefined) {
          dataLength = options2[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options2.mask && options2.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
      if (options2.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options2.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options2 = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options2), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options2 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options2), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options2 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options2), cb);
      }
    }
    send(data, options2, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options2.binary ? 2 : 1;
      let rsv1 = options2.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options2.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength,
          fin: options2.fin,
          generateMask: this._generateMask,
          mask: options2.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options2.fin,
          generateMask: this._generateMask,
          mask: options2.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options2, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options2), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options2[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options2.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0;i < this._queue.length; i++) {
            const params = this._queue[i];
            const callback = params[params.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options2[kByteLength];
        this._deflating = false;
        options2.readOnly = false;
        this.sendFrame(Sender.frame(buf, options2), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kCode] = options2.code === undefined ? 0 : options2.code;
      this[kReason] = options2.reason === undefined ? "" : options2.reason;
      this[kWasClean] = options2.wasClean === undefined ? false : options2.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kError] = options2.error === undefined ? null : options2.error;
      this[kMessage] = options2.message === undefined ? "" : options2.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kData] = options2.data === undefined ? null : options2.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options2 = {}) {
      for (const listener of this.listeners(type)) {
        if (!options2[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options2[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options2.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse2(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  var { tokenChars } = require_validation();
  module.exports = { format, parse: parse2 };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  function initAsClient(websocket, address, protocols, options2) {
    const opts = {
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options2,
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL) {
      parsedUrl = address;
      websocket._url = address.href;
    } else {
      try {
        parsedUrl = new URL(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
      websocket._url = address;
    }
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options2 && options2.headers;
        options2 = { ...options2, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options2.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options2.headers.authorization) {
        options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options2);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket2.CONNECTING)
        return;
      req = websocket._req = null;
      if (res.headers.upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse2(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket2.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options2) {
    options2.path = options2.socketPath;
    return net.connect(options2);
  }
  function tlsConnect(options2) {
    options2.path = undefined;
    if (!options2.servername && options2.servername !== "") {
      options2.servername = net.isIP(options2.host) ? "" : options2.host;
    }
    return tls.connect(options2);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket2.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream) {
    stream.resume();
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket2.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket2.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket2.CLOSING;
      this.destroy();
    }
  }
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Readable } = __require("stream");
  var { URL } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse: parse2 } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket2 extends EventEmitter {
    constructor(address, protocols, options2) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket2.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options2 = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options2);
      } else {
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options2) {
      const receiver = new Receiver({
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options2.maxPayload,
        skipUTF8Validation: options2.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options2.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket2.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket2.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket2.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket2.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options2, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options2
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket2.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket2, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket2.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket2.prototype.addEventListener = addEventListener;
  WebSocket2.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket2;
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options2) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options2,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  var { Duplex } = __require("stream");
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  function parse2(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  var { tokenChars } = require_validation();
  module.exports = { parse: parse2 };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  }
  var EventEmitter = __require("events");
  var http = __require("http");
  var https = __require("https");
  var net = __require("net");
  var tls = __require("tls");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket2 = require_websocket();
  var { GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options2, callback) {
      super();
      options2 = {
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket: WebSocket2,
        ...options2
      };
      if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options2.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options2.port, options2.host, options2.backlog, callback);
      } else if (options2.server) {
        this._server = options2.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options2.perMessageDeflate === true)
        options2.perMessageDeflate = {};
      if (options2.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options2;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const version2 = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!key || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version2 !== 8 && version2 !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket2 = require_websocket();
  WebSocket2.createWebSocketStream = require_stream();
  WebSocket2.Server = require_websocket_server();
  WebSocket2.Receiver = require_receiver();
  WebSocket2.Sender = require_sender();
  WebSocket2.WebSocket = WebSocket2;
  WebSocket2.WebSocketServer = WebSocket2.Server;
  module.exports = WebSocket2;
});

// node_modules/isows/_cjs/utils.js
var require_utils5 = __commonJS((exports) => {
  function getNativeWebSocket() {
    if (typeof WebSocket !== "undefined")
      return WebSocket;
    if (typeof global.WebSocket !== "undefined")
      return global.WebSocket;
    if (typeof window.WebSocket !== "undefined")
      return window.WebSocket;
    if (typeof self.WebSocket !== "undefined")
      return self.WebSocket;
    throw new Error("`WebSocket` is not supported in this environment");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getNativeWebSocket = undefined;
  exports.getNativeWebSocket = getNativeWebSocket;
});

// node_modules/isows/_cjs/index.js
var require__cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebSocket = undefined;
  var WebSocket_ = require_ws();
  var utils_js_1 = require_utils5();
  exports.WebSocket = (() => {
    try {
      return (0, utils_js_1.getNativeWebSocket)();
    } catch {
      if (WebSocket_.WebSocket)
        return WebSocket_.WebSocket;
      return WebSocket_;
    }
  })();
});

// node_modules/viem/_cjs/utils/rpc/socket.js
var require_socket = __commonJS((exports) => {
  async function getSocketRpcClient(params) {
    const { getSocket, reconnect = true, url } = params;
    const { attempts = 5, delay = 2000 } = typeof reconnect === "object" ? reconnect : {};
    let socketClient = exports.socketClientCache.get(url);
    if (socketClient)
      return socketClient;
    let reconnectCount = 0;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
      id: url,
      fn: async () => {
        const requests = new Map;
        const subscriptions = new Map;
        let error;
        let socket;
        async function setup() {
          return getSocket({
            onError(error_) {
              error = error_;
              for (const request of requests.values())
                request.onError?.(error);
              for (const subscription of subscriptions.values())
                subscription.onError?.(error);
              requests.clear();
              subscriptions.clear();
              if (reconnect && reconnectCount < attempts)
                setTimeout(async () => {
                  reconnectCount++;
                  socket = await setup().catch(console.error);
                }, delay);
            },
            onOpen() {
              error = undefined;
              reconnectCount = 0;
            },
            onResponse(data) {
              const isSubscription = data.method === "eth_subscription";
              const id = isSubscription ? data.params.subscription : data.id;
              const cache = isSubscription ? subscriptions : requests;
              const callback = cache.get(id);
              if (callback)
                callback.onResponse(data);
              if (!isSubscription)
                cache.delete(id);
            }
          });
        }
        socket = await setup();
        error = undefined;
        socketClient = {
          close() {
            socket.close();
            exports.socketClientCache.delete(url);
          },
          socket,
          request({ body, onError, onResponse }) {
            if (error && onError)
              onError(error);
            const id = body.id ?? id_js_1.idCache.take();
            const callback = (response) => {
              if (typeof response.id === "number" && id !== response.id)
                return;
              if (body.method === "eth_subscribe" && typeof response.result === "string")
                subscriptions.set(response.result, {
                  onResponse: callback,
                  onError
                });
              if (body.method === "eth_unsubscribe")
                subscriptions.delete(body.params?.[0]);
              onResponse(response);
            };
            requests.set(id, { onResponse: callback, onError });
            try {
              socket.request({
                body: {
                  jsonrpc: "2.0",
                  id,
                  ...body
                }
              });
            } catch (error2) {
              onError?.(error2);
            }
          },
          requestAsync({ body, timeout = 1e4 }) {
            return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse, onError) => this.request({
              body,
              onError,
              onResponse
            })), {
              errorInstance: new request_js_1.TimeoutError({ body, url }),
              timeout
            });
          },
          requests,
          subscriptions,
          url
        };
        exports.socketClientCache.set(url, socketClient);
        return [socketClient];
      }
    });
    const [_, [socketClient_]] = await schedule();
    return socketClient_;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSocketRpcClient = exports.socketClientCache = undefined;
  var request_js_1 = require_request();
  var createBatchScheduler_js_1 = require_createBatchScheduler();
  var withTimeout_js_1 = require_withTimeout();
  var id_js_1 = require_id();
  exports.socketClientCache = new Map;
  exports.getSocketRpcClient = getSocketRpcClient;
});

// node_modules/viem/_cjs/utils/rpc/webSocket.js
var require_webSocket = __commonJS((exports) => {
  async function getWebSocketRpcClient(url, options2 = {}) {
    const { reconnect } = options2;
    return (0, socket_js_1.getSocketRpcClient)({
      async getSocket({ onError, onOpen, onResponse }) {
        const WebSocket2 = await Promise.resolve().then(() => require__cjs()).then((module2) => module2.WebSocket);
        const socket = new WebSocket2(url);
        function onClose() {
          socket.removeEventListener("close", onClose);
          socket.removeEventListener("message", onMessage);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("open", onOpen);
        }
        function onMessage({ data }) {
          onResponse(JSON.parse(data));
        }
        socket.addEventListener("close", onClose);
        socket.addEventListener("message", onMessage);
        socket.addEventListener("error", onError);
        socket.addEventListener("open", onOpen);
        if (socket.readyState === WebSocket2.CONNECTING) {
          await new Promise((resolve, reject) => {
            if (!socket)
              return;
            socket.onopen = resolve;
            socket.onerror = reject;
          });
        }
        const { close: close_ } = socket;
        return Object.assign(socket, {
          close() {
            close_.bind(socket)();
            onClose();
          },
          request({ body }) {
            if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
              throw new request_js_1.WebSocketRequestError({
                body,
                url: socket.url,
                details: "Socket is closed."
              });
            return socket.send(JSON.stringify(body));
          }
        });
      },
      reconnect,
      url
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getWebSocketRpcClient = undefined;
  var request_js_1 = require_request();
  var socket_js_1 = require_socket();
  exports.getWebSocketRpcClient = getWebSocketRpcClient;
});

// node_modules/viem/_cjs/utils/rpc/compat.js
var require_compat = __commonJS((exports) => {
  function webSocket(socketClient, { body, onError, onResponse }) {
    socketClient.request({
      body,
      onError,
      onResponse
    });
    return socketClient;
  }
  async function webSocketAsync(socketClient, { body, timeout = 1e4 }) {
    return socketClient.requestAsync({
      body,
      timeout
    });
  }
  async function getSocket(url) {
    const client = await (0, webSocket_js_1.getWebSocketRpcClient)(url);
    return Object.assign(client.socket, {
      requests: client.requests,
      subscriptions: client.subscriptions
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rpc = exports.getSocket = undefined;
  var http_js_1 = require_http();
  var webSocket_js_1 = require_webSocket();
  exports.getSocket = getSocket;
  exports.rpc = {
    http(url, params) {
      return (0, http_js_1.getHttpRpcClient)(url).request(params);
    },
    webSocket,
    webSocketAsync
  };
});

// node_modules/viem/_cjs/utils/signature/hashTypedData.js
var require_hashTypedData = __commonJS((exports) => {
  function hashTypedData(parameters) {
    const { domain = {}, message, primaryType } = parameters;
    const types = {
      EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
      ...parameters.types
    };
    (0, typedData_js_1.validateTypedData)({
      domain,
      message,
      primaryType,
      types
    });
    const parts = ["0x1901"];
    if (domain)
      parts.push(hashDomain({
        domain,
        types
      }));
    if (primaryType !== "EIP712Domain")
      parts.push(hashStruct({
        data: message,
        primaryType,
        types
      }));
    return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
  }
  function hashDomain({ domain, types }) {
    return hashStruct({
      data: domain,
      primaryType: "EIP712Domain",
      types
    });
  }
  function hashStruct({ data, primaryType, types }) {
    const encoded = encodeData({
      data,
      primaryType,
      types
    });
    return (0, keccak256_js_1.keccak256)(encoded);
  }
  function encodeData({ data, primaryType, types }) {
    const encodedTypes = [{ type: "bytes32" }];
    const encodedValues = [hashType({ primaryType, types })];
    for (const field of types[primaryType]) {
      const [type, value] = encodeField({
        types,
        name: field.name,
        type: field.type,
        value: data[field.name]
      });
      encodedTypes.push(type);
      encodedValues.push(value);
    }
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
  }
  function hashType({ primaryType, types }) {
    const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
    return (0, keccak256_js_1.keccak256)(encodedHashType);
  }
  function encodeType({ primaryType, types }) {
    let result = "";
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
      result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
    }
    return result;
  }
  function findTypeDependencies({ primaryType: primaryType_, types }, results = new Set) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === undefined) {
      return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
      findTypeDependencies({ primaryType: field.type, types }, results);
    }
    return results;
  }
  function encodeField({ types, name, type, value }) {
    if (types[type] !== undefined) {
      return [
        { type: "bytes32" },
        (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types }))
      ];
    }
    if (type === "bytes") {
      const prepend = value.length % 2 ? "0" : "";
      value = `0x${prepend + value.slice(2)}`;
      return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)(value)];
    }
    if (type === "string")
      return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
    if (type.lastIndexOf("]") === type.length - 1) {
      const parsedType = type.slice(0, type.lastIndexOf("["));
      const typeValuePairs = value.map((item) => encodeField({
        name,
        type: parsedType,
        types,
        value: item
      }));
      return [
        { type: "bytes32" },
        (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
      ];
    }
    return [{ type }, value];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hashDomain = exports.hashTypedData = undefined;
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  var concat_js_1 = require_concat();
  var toHex_js_1 = require_toHex();
  var keccak256_js_1 = require_keccak256();
  var typedData_js_1 = require_typedData();
  exports.hashTypedData = hashTypedData;
  exports.hashDomain = hashDomain;
});

// node_modules/viem/_cjs/utils/typedData.js
var require_typedData = __commonJS((exports) => {
  function validateTypedData(parameters) {
    const { domain, message, primaryType, types } = parameters;
    const validateData = (struct, data) => {
      for (const param of struct) {
        const { name, type } = param;
        const value = data[name];
        const integerMatch = type.match(regex_js_1.integerRegex);
        if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
          const [_type, base, size_] = integerMatch;
          (0, toHex_js_1.numberToHex)(value, {
            signed: base === "int",
            size: parseInt(size_) / 8
          });
        }
        if (type === "address" && typeof value === "string" && !(0, isAddress_js_1.isAddress)(value))
          throw new address_js_1.InvalidAddressError({ address: value });
        const bytesMatch = type.match(regex_js_1.bytesRegex);
        if (bytesMatch) {
          const [_type, size_] = bytesMatch;
          if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))
            throw new abi_js_1.BytesSizeMismatchError({
              expectedSize: parseInt(size_),
              givenSize: (0, size_js_1.size)(value)
            });
        }
        const struct2 = types[type];
        if (struct2)
          validateData(struct2, value);
      }
    };
    if (types.EIP712Domain && domain)
      validateData(types.EIP712Domain, domain);
    if (primaryType !== "EIP712Domain") {
      const type = types[primaryType];
      validateData(type, message);
    }
  }
  function getTypesForEIP712Domain({ domain }) {
    return [
      typeof domain?.name === "string" && { name: "name", type: "string" },
      domain?.version && { name: "version", type: "string" },
      typeof domain?.chainId === "number" && {
        name: "chainId",
        type: "uint256"
      },
      domain?.verifyingContract && {
        name: "verifyingContract",
        type: "address"
      },
      domain?.salt && { name: "salt", type: "bytes32" }
    ].filter(Boolean);
  }
  function domainSeparator({ domain }) {
    return (0, hashTypedData_js_1.hashDomain)({
      domain,
      types: {
        EIP712Domain: getTypesForEIP712Domain({ domain })
      }
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.domainSeparator = exports.getTypesForEIP712Domain = exports.validateTypedData = undefined;
  var abi_js_1 = require_abi();
  var address_js_1 = require_address();
  var isAddress_js_1 = require_isAddress();
  var size_js_1 = require_size();
  var toHex_js_1 = require_toHex();
  var regex_js_1 = require_regex2();
  var hashTypedData_js_1 = require_hashTypedData();
  exports.validateTypedData = validateTypedData;
  exports.getTypesForEIP712Domain = getTypesForEIP712Domain;
  exports.domainSeparator = domainSeparator;
});

// node_modules/viem/_cjs/utils/abi/decodeFunctionData.js
var require_decodeFunctionData = __commonJS((exports) => {
  function decodeFunctionData(parameters) {
    const { abi, data } = parameters;
    const signature = (0, slice_js_1.slice)(data, 0, 4);
    const description = abi.find((x) => x.type === "function" && signature === (0, toFunctionSelector_js_1.toFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!description)
      throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
        docsPath: "/docs/contract/decodeFunctionData"
      });
    return {
      functionName: description.name,
      args: "inputs" in description && description.inputs && description.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4)) : undefined
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeFunctionData = undefined;
  var abi_js_1 = require_abi();
  var slice_js_1 = require_slice();
  var toFunctionSelector_js_1 = require_toFunctionSelector();
  var decodeAbiParameters_js_1 = require_decodeAbiParameters();
  var formatAbiItem_js_1 = require_formatAbiItem2();
  exports.decodeFunctionData = decodeFunctionData;
});

// node_modules/viem/_cjs/utils/abi/encodeDeployData.js
var require_encodeDeployData = __commonJS((exports) => {
  function encodeDeployData(parameters) {
    const { abi, args, bytecode } = parameters;
    if (!args || args.length === 0)
      return bytecode;
    const description = abi.find((x) => ("type" in x) && x.type === "constructor");
    if (!description)
      throw new abi_js_1.AbiConstructorNotFoundError({ docsPath: docsPath5 });
    if (!("inputs" in description))
      throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    if (!description.inputs || description.inputs.length === 0)
      throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
    return (0, concat_js_1.concatHex)([bytecode, data]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeDeployData = undefined;
  var abi_js_1 = require_abi();
  var concat_js_1 = require_concat();
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  var docsPath5 = "/docs/contract/encodeDeployData";
  exports.encodeDeployData = encodeDeployData;
});

// node_modules/viem/_cjs/utils/abi/encodeErrorResult.js
var require_encodeErrorResult = __commonJS((exports) => {
  function encodeErrorResult(parameters) {
    const { abi, errorName, args } = parameters;
    let abiItem = abi[0];
    if (errorName) {
      const item = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: errorName });
      if (!item)
        throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath: docsPath5 });
      abiItem = item;
    }
    if (abiItem.type !== "error")
      throw new abi_js_1.AbiErrorNotFoundError(undefined, { docsPath: docsPath5 });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, toFunctionSelector_js_1.toFunctionSelector)(definition);
    let data = "0x";
    if (args && args.length > 0) {
      if (!abiItem.inputs)
        throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath5 });
      data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
    }
    return (0, concat_js_1.concatHex)([signature, data]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeErrorResult = undefined;
  var abi_js_1 = require_abi();
  var concat_js_1 = require_concat();
  var toFunctionSelector_js_1 = require_toFunctionSelector();
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  var formatAbiItem_js_1 = require_formatAbiItem2();
  var getAbiItem_js_1 = require_getAbiItem();
  var docsPath5 = "/docs/contract/encodeErrorResult";
  exports.encodeErrorResult = encodeErrorResult;
});

// node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js
var require_encodeFunctionResult = __commonJS((exports) => {
  function encodeFunctionResult(parameters) {
    const { abi, functionName, result } = parameters;
    let abiItem = abi[0];
    if (functionName) {
      const item = (0, getAbiItem_js_1.getAbiItem)({ abi, name: functionName });
      if (!item)
        throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath: docsPath5 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new abi_js_1.AbiFunctionNotFoundError(undefined, { docsPath: docsPath5 });
    if (!abiItem.outputs)
      throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath5 });
    let values = Array.isArray(result) ? result : [result];
    if (abiItem.outputs.length === 0 && !values[0])
      values = [];
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeFunctionResult = undefined;
  var abi_js_1 = require_abi();
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  var getAbiItem_js_1 = require_getAbiItem();
  var docsPath5 = "/docs/contract/encodeFunctionResult";
  exports.encodeFunctionResult = encodeFunctionResult;
});

// node_modules/viem/_cjs/utils/abi/encodePacked.js
var require_encodePacked = __commonJS((exports) => {
  function encodePacked(types, values) {
    if (types.length !== values.length)
      throw new abi_js_1.AbiEncodingLengthMismatchError({
        expectedLength: types.length,
        givenLength: values.length
      });
    const data = [];
    for (let i = 0;i < types.length; i++) {
      const type = types[i];
      const value = values[i];
      data.push(encode(type, value));
    }
    return (0, concat_js_1.concatHex)(data);
  }
  function encode(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      if (!(0, isAddress_js_1.isAddress)(address))
        throw new address_js_1.InvalidAddressError({ address });
      return (0, pad_js_1.pad)(address.toLowerCase(), {
        size: isArray ? 32 : null
      });
    }
    if (type === "string")
      return (0, toHex_js_1.stringToHex)(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
    const intMatch = type.match(regex_js_1.integerRegex);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size2 = parseInt(bits) / 8;
      return (0, toHex_js_1.numberToHex)(value, {
        size: isArray ? 32 : size2,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(regex_js_1.bytesRegex);
    if (bytesMatch) {
      const [_type, size2] = bytesMatch;
      if (parseInt(size2) !== (value.length - 2) / 2)
        throw new abi_js_1.BytesSizeMismatchError({
          expectedSize: parseInt(size2),
          givenSize: (value.length - 2) / 2
        });
      return (0, pad_js_1.pad)(value, { dir: "right", size: isArray ? 32 : null });
    }
    const arrayMatch = type.match(regex_js_1.arrayRegex);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i = 0;i < value.length; i++) {
        data.push(encode(childType, value[i], true));
      }
      if (data.length === 0)
        return "0x";
      return (0, concat_js_1.concatHex)(data);
    }
    throw new abi_js_1.UnsupportedPackedAbiType(type);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodePacked = undefined;
  var abi_js_1 = require_abi();
  var address_js_1 = require_address();
  var isAddress_js_1 = require_isAddress();
  var concat_js_1 = require_concat();
  var pad_js_1 = require_pad();
  var toHex_js_1 = require_toHex();
  var regex_js_1 = require_regex2();
  exports.encodePacked = encodePacked;
});

// node_modules/viem/_cjs/utils/data/isBytes.js
var require_isBytes = __commonJS((exports) => {
  function isBytes(value) {
    if (!value)
      return false;
    if (typeof value !== "object")
      return false;
    if (!("BYTES_PER_ELEMENT" in value))
      return false;
    return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBytes = undefined;
  exports.isBytes = isBytes;
});

// node_modules/viem/_cjs/utils/address/getContractAddress.js
var require_getContractAddress = __commonJS((exports) => {
  function getContractAddress2(opts) {
    if (opts.opcode === "CREATE2")
      return getCreate2Address(opts);
    return getCreateAddress(opts);
  }
  function getCreateAddress(opts) {
    const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
    let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
    if (nonce[0] === 0)
      nonce = new Uint8Array([]);
    return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], "bytes")).slice(26)}`);
  }
  function getCreate2Address(opts) {
    const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
    const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
      size: 32
    });
    const bytecodeHash = (() => {
      if ("bytecodeHash" in opts) {
        if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash))
          return opts.bytecodeHash;
        return (0, toBytes_js_1.toBytes)(opts.bytecodeHash);
      }
      return (0, keccak256_js_1.keccak256)(opts.bytecode, "bytes");
    })();
    return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)("0xff"), from, salt, bytecodeHash])), 12));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = undefined;
  var concat_js_1 = require_concat();
  var isBytes_js_1 = require_isBytes();
  var pad_js_1 = require_pad();
  var slice_js_1 = require_slice();
  var toBytes_js_1 = require_toBytes();
  var toRlp_js_1 = require_toRlp();
  var keccak256_js_1 = require_keccak256();
  var getAddress_js_1 = require_getAddress();
  exports.getContractAddress = getContractAddress2;
  exports.getCreateAddress = getCreateAddress;
  exports.getCreate2Address = getCreate2Address;
});

// node_modules/viem/_cjs/utils/encoding/fromRlp.js
var require_fromRlp = __commonJS((exports) => {
  function fromRlp(value, to = "hex") {
    const bytes2 = (() => {
      if (typeof value === "string") {
        if (value.length > 3 && value.length % 2 !== 0)
          throw new encoding_js_1.InvalidHexValueError(value);
        return (0, toBytes_js_1.hexToBytes)(value);
      }
      return value;
    })();
    const cursor = (0, cursor_js_1.createCursor)(bytes2, { recursiveReadLimit: Infinity });
    const result = fromRlpCursor(cursor, to);
    return result;
  }
  function rlpToBytes(bytes2, to = "bytes") {
    return fromRlp(bytes2, to);
  }
  function rlpToHex(hex, to = "hex") {
    return fromRlp(hex, to);
  }
  function fromRlpCursor(cursor, to = "hex") {
    if (cursor.bytes.length === 0)
      return to === "hex" ? (0, toHex_js_1.bytesToHex)(cursor.bytes) : cursor.bytes;
    const prefix = cursor.readByte();
    if (prefix < 128)
      cursor.decrementPosition(1);
    if (prefix < 192) {
      const length2 = readLength(cursor, prefix, 128);
      const bytes2 = cursor.readBytes(length2);
      return to === "hex" ? (0, toHex_js_1.bytesToHex)(bytes2) : bytes2;
    }
    const length = readLength(cursor, prefix, 192);
    return readList(cursor, length, to);
  }
  function readLength(cursor, prefix, offset) {
    if (offset === 128 && prefix < 128)
      return 1;
    if (prefix <= offset + 55)
      return prefix - offset;
    if (prefix === offset + 55 + 1)
      return cursor.readUint8();
    if (prefix === offset + 55 + 2)
      return cursor.readUint16();
    if (prefix === offset + 55 + 3)
      return cursor.readUint24();
    if (prefix === offset + 55 + 4)
      return cursor.readUint32();
    throw new base_js_1.BaseError("Invalid RLP prefix");
  }
  function readList(cursor, length, to) {
    const position = cursor.position;
    const value = [];
    while (cursor.position - position < length)
      value.push(fromRlpCursor(cursor, to));
    return value;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rlpToHex = exports.rlpToBytes = exports.fromRlp = undefined;
  var base_js_1 = require_base();
  var encoding_js_1 = require_encoding();
  var cursor_js_1 = require_cursor2();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.fromRlp = fromRlp;
  exports.rlpToBytes = rlpToBytes;
  exports.rlpToHex = rlpToHex;
});

// node_modules/viem/_cjs/utils/hash/toEventSignature.js
var require_toEventSignature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toEventSignature = undefined;
  var toSignature_js_1 = require_toSignature();
  Object.defineProperty(exports, "toEventSignature", { enumerable: true, get: function() {
    return toSignature_js_1.toSignature;
  } });
});

// node_modules/viem/_cjs/utils/hash/toFunctionSignature.js
var require_toFunctionSignature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toFunctionSignature = undefined;
  var toSignature_js_1 = require_toSignature();
  Object.defineProperty(exports, "toFunctionSignature", { enumerable: true, get: function() {
    return toSignature_js_1.toSignature;
  } });
});

// node_modules/viem/_cjs/utils/hash/toEventHash.js
var require_toEventHash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toEventHash = undefined;
  var toSignatureHash_js_1 = require_toSignatureHash();
  Object.defineProperty(exports, "toEventHash", { enumerable: true, get: function() {
    return toSignatureHash_js_1.toSignatureHash;
  } });
});

// node_modules/viem/_cjs/utils/hash/toFunctionHash.js
var require_toFunctionHash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toFunctionHash = undefined;
  var toSignatureHash_js_1 = require_toSignatureHash();
  Object.defineProperty(exports, "toFunctionHash", { enumerable: true, get: function() {
    return toSignatureHash_js_1.toSignatureHash;
  } });
});

// node_modules/viem/_cjs/utils/hash/isHash.js
var require_isHash = __commonJS((exports) => {
  function isHash(hash2) {
    return (0, isHex_js_1.isHex)(hash2) && (0, size_js_1.size)(hash2) === 32;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isHash = undefined;
  var isHex_js_1 = require_isHex();
  var size_js_1 = require_size();
  exports.isHash = isHash;
});

// node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS((exports) => {
  function f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    else if (group === 1)
      return x & y | ~x & z;
    else if (group === 2)
      return (x | ~y) ^ z;
    else if (group === 3)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ripemd160 = exports.RIPEMD160 = undefined;
  var _sha2_js_1 = require__sha2();
  var utils_js_1 = require_utils2();
  var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
  var Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i = 0;i < 4; i++)
    for (let j of [idxL, idxR])
      j.push(j[i].map((k) => Rho[k]));
  var shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i) => new Uint8Array(i));
  var shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
  var shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
  var Kl = /* @__PURE__ */ new Uint32Array([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]);
  var Kr = /* @__PURE__ */ new Uint32Array([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  var rotl = (word, shift) => word << shift | word >>> 32 - shift;
  var BUF = /* @__PURE__ */ new Uint32Array(16);

  class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        BUF[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0;group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i = 0;i < 16; i++) {
          const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0;i < 16; i++) {
          const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  }
  exports.RIPEMD160 = RIPEMD160;
  exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160);
});

// node_modules/viem/_cjs/utils/hash/ripemd160.js
var require_ripemd1602 = __commonJS((exports) => {
  function ripemd160(value, to_) {
    const to = to_ || "hex";
    const bytes2 = (0, ripemd160_1.ripemd160)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === "bytes")
      return bytes2;
    return (0, toHex_js_1.toHex)(bytes2);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ripemd160 = undefined;
  var ripemd160_1 = require_ripemd160();
  var isHex_js_1 = require_isHex();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.ripemd160 = ripemd160;
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils6 = __commonJS((exports) => {
  function bytesToHex2(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes2.length; i++) {
      hex += hexes2[bytes2[i]];
    }
    return hex;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  function hexToBytes2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber2(bytesToHex2(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber2(bytesToHex2(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function numberToVarBytesBE(n) {
    return hexToBytes2(numberToHexUnpadded(n));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes2(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (u8a2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes2(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad2 = 0;
    arrays.forEach((a) => {
      if (!u8a2(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad2);
      pad2 += a.length;
    });
    return r;
  }
  function equalBytes(b1, b2) {
    if (b1.length !== b2.length)
      return false;
    for (let i = 0;i < b1.length; i++)
      if (b1[i] !== b2[i])
        return false;
    return true;
  }
  function utf8ToBytes2(str2) {
    if (typeof str2 !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
    return new Uint8Array(new TextEncoder().encode(str2));
  }
  function bitLen(n) {
    let len;
    for (len = 0;n > _0n2; n >>= _1n2, len += 1)
      ;
    return len;
  }
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n2;
  }
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n()) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen2 = () => {
      if (i++ >= 1000)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = undefined;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object[fieldName];
      if (isOptional && val === undefined)
        return;
      if (!checkVal(val, object)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n2 = BigInt(2);
  var u8a2 = (a) => a instanceof Uint8Array;
  var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  exports.bytesToHex = bytesToHex2;
  exports.numberToHexUnpadded = numberToHexUnpadded;
  exports.hexToNumber = hexToNumber2;
  exports.hexToBytes = hexToBytes2;
  exports.bytesToNumberBE = bytesToNumberBE;
  exports.bytesToNumberLE = bytesToNumberLE;
  exports.numberToBytesBE = numberToBytesBE;
  exports.numberToBytesLE = numberToBytesLE;
  exports.numberToVarBytesBE = numberToVarBytesBE;
  exports.ensureBytes = ensureBytes;
  exports.concatBytes = concatBytes2;
  exports.equalBytes = equalBytes;
  exports.utf8ToBytes = utf8ToBytes2;
  exports.bitLen = bitLen;
  exports.bitGet = bitGet;
  var bitSet = (n, pos, value) => {
    return n | (value ? _1n2 : _0n2) << BigInt(pos);
  };
  exports.bitSet = bitSet;
  var bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
  exports.bitMask = bitMask;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  exports.createHmacDrbg = createHmacDrbg;
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  exports.validateObject = validateObject;
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS((exports) => {
  function mod(a, b) {
    const result = a % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n2 || power < _0n2)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n2)
      return _0n2;
    let res = _1n2;
    while (power > _0n2) {
      if (power & _1n2)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n2;
    }
    return res;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n2 || modulo <= _0n2) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod(number2, modulo);
    let b = modulo;
    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
    while (a !== _0n2) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    const legendreC = (P - _1n2) / _2n2;
    let Q, S, Z;
    for (Q = P - _1n2, S = 0;Q % _2n2 === _0n2; Q /= _2n2, S++)
      ;
    for (Z = _2n2;Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n2) / _4n;
      return function tonelliFast(Fp, n) {
        const root = Fp.pow(n, p1div4);
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n2) / _2n2;
    return function tonelliSlow(Fp, n) {
      if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
      let x = Fp.pow(n, Q1div2);
      let b = Fp.pow(n, Q);
      while (!Fp.eql(b, Fp.ONE)) {
        if (Fp.eql(b, Fp.ZERO))
          return Fp.ZERO;
        let m = 1;
        for (let t2 = Fp.sqr(b);m < r; m++) {
          if (Fp.eql(t2, Fp.ONE))
            break;
          t2 = Fp.sqr(t2);
        }
        const ge = Fp.pow(g, _1n2 << BigInt(r - m - 1));
        g = Fp.sqr(ge);
        x = Fp.mul(x, ge);
        b = Fp.mul(b, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n) {
      const p1div4 = (P + _1n2) / _4n;
      return function sqrt3mod4(Fp, n) {
        const root = Fp.pow(n, p1div4);
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod8(Fp, n) {
        const n2 = Fp.mul(n, _2n2);
        const v = Fp.pow(n2, c1);
        const nv = Fp.mul(n, v);
        const i = Fp.mul(Fp.mul(nv, _2n2), v);
        const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  }
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
  }
  function FpPow(f, num, power) {
    if (power < _0n2)
      throw new Error("Expected power > 0");
    if (power === _0n2)
      return f.ONE;
    if (power === _1n2)
      return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n2) {
      if (power & _1n2)
        p = f.mul(p, d);
      d = f.sqr(d);
      power >>= _1n2;
    }
    return p;
  }
  function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    const inverted = f.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
  }
  function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n2) / _2n2;
    return (x) => {
      const p = f.pow(x, legendreConst);
      return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
  }
  function nLength(n, nBitLength) {
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen, isLE2 = false, redef = {}) {
    if (ORDER <= _0n2)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: (0, utils_js_1.bitMask)(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n2,
      isOdd: (num) => (num & _1n2) === _1n2,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
      invertBatch: (lst) => FpInvertBatch(f, lst),
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE2 ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? (0, utils_js_1.bytesToNumberLE)(bytes2) : (0, utils_js_1.bytesToNumberBE)(bytes2);
      }
    });
    return Object.freeze(f);
  }
  function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
  }
  function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
  }
  function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {
    hash2 = (0, utils_js_1.ensureBytes)("privateHash", hash2);
    const hashLen = hash2.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
      throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE2 ? (0, utils_js_1.bytesToNumberLE)(hash2) : (0, utils_js_1.bytesToNumberBE)(hash2);
    return mod(num, groupOrder - _1n2) + _1n2;
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE2 ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    const reduced = mod(num, fieldOrder - _1n2) + _1n2;
    return isLE2 ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var utils_js_1 = require_utils6();
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n2 = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  var _5n = BigInt(5);
  var _8n = BigInt(8);
  var _9n = BigInt(9);
  var _16n = BigInt(16);
  exports.mod = mod;
  exports.pow = pow;
  exports.pow2 = pow2;
  exports.invert = invert;
  exports.tonelliShanks = tonelliShanks;
  exports.FpSqrt = FpSqrt;
  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
  exports.isNegativeLE = isNegativeLE;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  exports.validateField = validateField;
  exports.FpPow = FpPow;
  exports.FpInvertBatch = FpInvertBatch;
  exports.FpDiv = FpDiv;
  exports.FpIsSquare = FpIsSquare;
  exports.nLength = nLength;
  exports.Field = Field;
  exports.FpSqrtOdd = FpSqrtOdd;
  exports.FpSqrtEven = FpSqrtEven;
  exports.hashToPrivateScalar = hashToPrivateScalar;
  exports.getFieldBytesLength = getFieldBytesLength;
  exports.getMinHashLength = getMinHashLength;
  exports.mapHashToField = mapHashToField;
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS((exports) => {
  function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d = elm;
        while (n > _0n2) {
          if (n & _1n2)
            p = p.add(d);
          d = d.double();
          n >>= _1n2;
        }
        return p;
      },
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base = p;
        for (let window2 = 0;window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1;i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      },
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0;window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n2;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      },
      wNAFCached(P, precomputesMap, n, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  }
  function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateBasic = exports.wNAF = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var modular_js_1 = require_modular();
  var utils_js_1 = require_utils6();
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  exports.wNAF = wNAF;
  exports.validateBasic = validateBasic;
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS((exports) => {
  function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp, a } = opts;
    if (endo) {
      if (!Fp.eql(a, Fp.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE;
    const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp.sqr(x);
      const x3 = Fp.mul(x2, x);
      return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
    }
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n2 < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (key instanceof Uint8Array)
          key = ut.bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod.mod(num, n);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = new Map;
    function assertPrjPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ProjectivePoint expected");
    }

    class Point {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp.isValid(pz))
          throw new Error("z required");
      }
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp.eql(i, Fp.ZERO);
        if (is0(x) && is0(y))
          return Point.ZERO;
        return new Point(x, y, Fp.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        const toInv = Fp.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      }
      static fromHex(hex) {
        const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp.isOdd)
          return !Fp.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
        const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
        return U1 && U2;
      }
      negate() {
        return new Point(this.px, Fp.neg(this.py), this.pz);
      }
      double() {
        const { a, b } = CURVE;
        const b3 = Fp.mul(b, _3n);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
        let t0 = Fp.mul(X1, X1);
        let t1 = Fp.mul(Y1, Y1);
        let t2 = Fp.mul(Z1, Z1);
        let t3 = Fp.mul(X1, Y1);
        t3 = Fp.add(t3, t3);
        Z3 = Fp.mul(X1, Z1);
        Z3 = Fp.add(Z3, Z3);
        X3 = Fp.mul(a, Z3);
        Y3 = Fp.mul(b3, t2);
        Y3 = Fp.add(X3, Y3);
        X3 = Fp.sub(t1, Y3);
        Y3 = Fp.add(t1, Y3);
        Y3 = Fp.mul(X3, Y3);
        X3 = Fp.mul(t3, X3);
        Z3 = Fp.mul(b3, Z3);
        t2 = Fp.mul(a, t2);
        t3 = Fp.sub(t0, t2);
        t3 = Fp.mul(a, t3);
        t3 = Fp.add(t3, Z3);
        Z3 = Fp.add(t0, t0);
        t0 = Fp.add(Z3, t0);
        t0 = Fp.add(t0, t2);
        t0 = Fp.mul(t0, t3);
        Y3 = Fp.add(Y3, t0);
        t2 = Fp.mul(Y1, Z1);
        t2 = Fp.add(t2, t2);
        t0 = Fp.mul(t2, t3);
        X3 = Fp.sub(X3, t0);
        Z3 = Fp.mul(t2, t1);
        Z3 = Fp.add(Z3, Z3);
        Z3 = Fp.add(Z3, Z3);
        return new Point(X3, Y3, Z3);
      }
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
        const a = CURVE.a;
        const b3 = Fp.mul(CURVE.b, _3n);
        let t0 = Fp.mul(X1, X2);
        let t1 = Fp.mul(Y1, Y2);
        let t2 = Fp.mul(Z1, Z2);
        let t3 = Fp.add(X1, Y1);
        let t4 = Fp.add(X2, Y2);
        t3 = Fp.mul(t3, t4);
        t4 = Fp.add(t0, t1);
        t3 = Fp.sub(t3, t4);
        t4 = Fp.add(X1, Z1);
        let t5 = Fp.add(X2, Z2);
        t4 = Fp.mul(t4, t5);
        t5 = Fp.add(t0, t2);
        t4 = Fp.sub(t4, t5);
        t5 = Fp.add(Y1, Z1);
        X3 = Fp.add(Y2, Z2);
        t5 = Fp.mul(t5, X3);
        X3 = Fp.add(t1, t2);
        t5 = Fp.sub(t5, X3);
        Z3 = Fp.mul(a, t4);
        X3 = Fp.mul(b3, t2);
        Z3 = Fp.add(X3, Z3);
        X3 = Fp.sub(t1, Z3);
        Z3 = Fp.add(t1, Z3);
        Y3 = Fp.mul(X3, Z3);
        t1 = Fp.add(t0, t0);
        t1 = Fp.add(t1, t0);
        t2 = Fp.mul(a, t2);
        t4 = Fp.mul(b3, t4);
        t1 = Fp.add(t1, t2);
        t2 = Fp.sub(t0, t2);
        t2 = Fp.mul(a, t2);
        t4 = Fp.add(t4, t2);
        t0 = Fp.mul(t1, t4);
        Y3 = Fp.add(Y3, t0);
        t0 = Fp.mul(t5, t4);
        X3 = Fp.mul(t3, X3);
        X3 = Fp.sub(X3, t0);
        t0 = Fp.mul(t3, t1);
        Z3 = Fp.mul(t5, Z3);
        Z3 = Fp.add(Z3, t0);
        return new Point(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
          const toInv = Fp.invertBatch(comp.map((p) => p.pz));
          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        });
      }
      multiplyUnsafe(n) {
        const I = Point.ZERO;
        if (n === _0n2)
          return I;
        assertGE(n);
        if (n === _1n2)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n2 || k2 > _0n2) {
          if (k1 & _1n2)
            k1p = k1p.add(d);
          if (k2 & _1n2)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n2;
          k2 >>= _1n2;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      multiply(scalar) {
        assertGE(scalar);
        let n = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(n);
          point = p;
          fake = f;
        }
        return Point.normalizeZ([point, fake])[0];
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point.BASE;
        const mul = (P, a2) => a2 === _0n2 || a2 === _1n2 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? undefined : sum;
      }
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n2)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n2)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes3(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return ut.bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1;
    const uncompressedLen = 2 * Fp.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n2 < num && num < Fp.ORDER;
    }
    function modN(a) {
      return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp.toBytes(a.x);
        const cat = ut.concatBytes;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = ut.bytesToNumberBE(tail);
          if (!isValidFieldElement(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y = Fp.sqrt(y2);
          const isYOdd = (y & _1n2) === _1n2;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
          const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n2;
      return number2 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));

    class Signature {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      static fromDER(hex) {
        const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
        return new Signature(r, s);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s * ir);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return ut.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return exports.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return ut.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const length = mod.getMinHashLength(CURVE.n);
        return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str2 = typeof item === "string";
      const len = (arr || str2) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str2)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = ut.bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n2 <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => (k in opts)))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
      if (prehash)
        msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes(Fp.BYTES) : ent;
        seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
      }
      const seed = ut.concatBytes(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n2)
          return;
        const s = modN(ik * modN(m + r * d));
        if (s === _0n2)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n2);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
      publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = undefined;
      let P;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err))
              throw derError;
            _sig = Signature.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig = new Signature(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P = Point.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s);
      const u1 = modN(h * is);
      const u2 = modN(r * is);
      const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R)
        return false;
      const v = modN(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point,
      Signature,
      utils
    };
  }
  function SWUFpSqrtRatio(Fp, Z) {
    const q = Fp.ORDER;
    let l = _0n2;
    for (let o = q - _1n2;o % _2n2 === _0n2; o /= _2n2)
      l += _1n2;
    const c1 = l;
    const _2n_pow_c1_1 = _2n2 << c1 - _1n2 - _1n2;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n2;
    const c2 = (q - _1n2) / _2n_pow_c1;
    const c3 = (c2 - _1n2) / _2n2;
    const c4 = _2n_pow_c1 - _1n2;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp.pow(Z, c2);
    const c7 = Fp.pow(Z, (c2 + _1n2) / _2n2);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp.pow(v, c4);
      let tv3 = Fp.sqr(tv2);
      tv3 = Fp.mul(tv3, v);
      let tv5 = Fp.mul(u, tv3);
      tv5 = Fp.pow(tv5, c3);
      tv5 = Fp.mul(tv5, tv2);
      tv2 = Fp.mul(tv5, v);
      tv3 = Fp.mul(tv5, u);
      let tv4 = Fp.mul(tv3, tv2);
      tv5 = Fp.pow(tv4, c5);
      let isQR = Fp.eql(tv5, Fp.ONE);
      tv2 = Fp.mul(tv3, c7);
      tv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, isQR);
      tv4 = Fp.cmov(tv5, tv4, isQR);
      for (let i = c1;i > _1n2; i--) {
        let tv52 = i - _2n2;
        tv52 = _2n2 << tv52 - _1n2;
        let tvv5 = Fp.pow(tv4, tv52);
        const e1 = Fp.eql(tvv5, Fp.ONE);
        tv2 = Fp.mul(tv3, tv1);
        tv1 = Fp.mul(tv1, tv1);
        tvv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, e1);
        tv4 = Fp.cmov(tvv5, tv4, e1);
      }
      return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
      const c12 = (Fp.ORDER - _3n) / _4n;
      const c22 = Fp.sqrt(Fp.neg(Z));
      sqrtRatio = (u, v) => {
        let tv1 = Fp.sqr(v);
        const tv2 = Fp.mul(u, v);
        tv1 = Fp.mul(tv1, tv2);
        let y1 = Fp.pow(tv1, c12);
        y1 = Fp.mul(y1, tv2);
        const y2 = Fp.mul(y1, c22);
        const tv3 = Fp.mul(Fp.sqr(y1), v);
        const isQR = Fp.eql(tv3, u);
        let y = Fp.cmov(y2, y1, isQR);
        return { isValid: isQR, value: y };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
      tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, opts.Z);
      tv2 = Fp.sqr(tv1);
      tv2 = Fp.add(tv2, tv1);
      tv3 = Fp.add(tv2, Fp.ONE);
      tv3 = Fp.mul(tv3, opts.B);
      tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
      tv4 = Fp.mul(tv4, opts.A);
      tv2 = Fp.sqr(tv3);
      tv6 = Fp.sqr(tv4);
      tv5 = Fp.mul(tv6, opts.A);
      tv2 = Fp.add(tv2, tv5);
      tv2 = Fp.mul(tv2, tv3);
      tv6 = Fp.mul(tv6, tv4);
      tv5 = Fp.mul(tv6, opts.B);
      tv2 = Fp.add(tv2, tv5);
      x = Fp.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp.mul(tv1, u);
      y = Fp.mul(y, value);
      x = Fp.cmov(x, tv3, isValid);
      y = Fp.cmov(y, value, isValid);
      const e1 = Fp.isOdd(u) === Fp.isOdd(y);
      y = Fp.cmov(Fp.neg(y), y, e1);
      x = Fp.div(x, tv4);
      return { x, y };
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var mod = require_modular();
  var ut = require_utils6();
  var utils_js_1 = require_utils6();
  var curve_js_1 = require_curve();
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
  exports.DER = {
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data) {
      const { Err: E } = exports.DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex) {
      const { Err: E } = exports.DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      if (!(data instanceof Uint8Array))
        throw new Error("ui8a expected");
      let l = data.length;
      if (l < 2 || data[0] != 48)
        throw new E("Invalid signature tag");
      if (data[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
      const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r, s };
    },
    hexFromSig(sig) {
      const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s = slice2(h(sig.s));
      const r = slice2(h(sig.r));
      const shl = s.length / 2;
      const rhl = r.length / 2;
      const sl = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
  };
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n2 = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  exports.weierstrassPoints = weierstrassPoints;
  exports.weierstrass = weierstrass;
  exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
  exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS((exports) => {
  function validateDST(dst) {
    if (dst instanceof Uint8Array)
      return dst;
    if (typeof dst === "string")
      return (0, utils_js_1.utf8ToBytes)(dst);
    throw new Error("DST must be Uint8Array or string");
  }
  function i2osp(value, length) {
    if (value < 0 || value >= 1 << 8 * length) {
      throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1;i >= 0; i--) {
      res[i] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0;i < a.length; i++) {
      arr[i] = a[i] ^ b[i];
    }
    return arr;
  }
  function isBytes(item) {
    if (!(item instanceof Uint8Array))
      throw new Error("Uint8Array expected");
  }
  function isNum(item) {
    if (!Number.isSafeInteger(item))
      throw new Error("number expected");
  }
  function expand_message_xmd(msg, DST, lenInBytes, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    if (DST.length > 255)
      DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
      throw new Error("Invalid xmd length");
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1;i <= ell; i++) {
      const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
      b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  function expand_message_xof(msg, DST, lenInBytes, k, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k / 8);
      DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
      throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  }
  function hash_to_field(msg, count, options2) {
    (0, utils_js_1.validateObject)(options2, {
      DST: "stringOrUint8Array",
      p: "bigint",
      m: "isSafeInteger",
      k: "isSafeInteger",
      hash: "hash"
    });
    const { p, k, m, hash: hash2, expand, DST: _DST } = options2;
    isBytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8);
    const len_in_bytes = count * m * L;
    let prb;
    if (expand === "xmd") {
      prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
    } else if (expand === "xof") {
      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
    } else if (expand === "_internal_pass") {
      prb = msg;
    } else {
      throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0;i < count; i++) {
      const e = new Array(m);
      for (let j = 0;j < m; j++) {
        const elm_offset = L * (j + i * m);
        const tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
      }
      u[i] = e;
    }
    return u;
  }
  function isogenyMap(field, map) {
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
      const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
      x = field.div(xNum, xDen);
      y = field.mul(y, field.div(yNum, yDen));
      return { x, y };
    };
  }
  function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== "function")
      throw new Error("mapToCurve() must be defined");
    return {
      hashToCurve(msg, options2) {
        const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options2 });
        const u0 = Point.fromAffine(mapToCurve(u[0]));
        const u1 = Point.fromAffine(mapToCurve(u[1]));
        const P = u0.add(u1).clearCofactor();
        P.assertValidity();
        return P;
      },
      encodeToCurve(msg, options2) {
        const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options2 });
        const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
        P.assertValidity();
        return P;
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = undefined;
  var modular_js_1 = require_modular();
  var utils_js_1 = require_utils6();
  var os2ip = utils_js_1.bytesToNumberBE;
  exports.expand_message_xmd = expand_message_xmd;
  exports.expand_message_xof = expand_message_xof;
  exports.hash_to_field = hash_to_field;
  exports.isogenyMap = isogenyMap;
  exports.createHasher = createHasher;
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = exports.HMAC = undefined;
  var _assert_js_1 = require__assert();
  var utils_js_1 = require_utils2();

  class HMAC extends utils_js_1.Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_1.hash)(hash2);
      const key = (0, utils_js_1.toBytes)(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad2 = new Uint8Array(blockLen);
      pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0;i < pad2.length; i++)
        pad2[i] ^= 54;
      this.iHash.update(pad2);
      this.oHash = hash2.create();
      for (let i = 0;i < pad2.length; i++)
        pad2[i] ^= 54 ^ 92;
      this.oHash.update(pad2);
      pad2.fill(0);
    }
    update(buf) {
      (0, _assert_js_1.exists)(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.bytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }
  exports.HMAC = HMAC;
  var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
  exports.hmac = hmac;
  exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
});

// node_modules/@noble/curves/_shortw_utils.js
var require__shortw_utils = __commonJS((exports) => {
  function getHash(hash2) {
    return {
      hash: hash2,
      hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash2, key, (0, utils_1.concatBytes)(...msgs)),
      randomBytes: utils_1.randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash2) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash2) });
    return Object.freeze({ ...create(defHash), create });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCurve = exports.getHash = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var hmac_1 = require_hmac();
  var utils_1 = require_utils2();
  var weierstrass_js_1 = require_weierstrass();
  exports.getHash = getHash;
  exports.createCurve = createCurve;
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS((exports) => {
  function sqrtMod(y) {
    const P = secp256k1P;
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
    const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
    const b11 = (0, modular_js_1.pow2)(b9, _2n2, P) * b2 % P;
    const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
    const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, modular_js_1.pow2)(t2, _2n2, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
      const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
  }
  function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
    let p = Point.fromPrivateKey(d_);
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar, bytes: pointToBytes(p) };
  }
  function lift_x(x) {
    if (!fe(x))
      throw new Error("bad x: need 0 < x < p");
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7));
    let y = sqrtMod(c);
    if (y % _2n2 !== _0n2)
      y = modP(-y);
    const p = new Point(x, y, _1n2);
    p.assertValidity();
    return p;
  }
  function challenge(...args) {
    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
    if (k_ === _0n2)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
    const m = (0, utils_js_1.ensureBytes)("message", message);
    const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
    try {
      const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
      const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
      if (!fe(r))
        return false;
      const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
      if (!ge(s))
        return false;
      const e = challenge(numTo32b(r), pointToBytes(P), m);
      const R = GmulAdd(P, s, modN(-e));
      if (!R || !R.hasEvenY() || R.toAffine().x !== r)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var sha256_1 = require_sha256();
  var utils_1 = require_utils2();
  var modular_js_1 = require_modular();
  var weierstrass_js_1 = require_weierstrass();
  var utils_js_1 = require_utils6();
  var hash_to_curve_js_1 = require_hash_to_curve();
  var _shortw_utils_js_1 = require__shortw_utils();
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n2 = BigInt(1);
  var _2n2 = BigInt(2);
  var divNearest = (a, b) => (a + b / _2n2) / b;
  var Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
  exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n2 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
        let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256_1.sha256);
  var _0n2 = BigInt(0);
  var fe = (x) => typeof x === "bigint" && _0n2 < x && x < secp256k1P;
  var ge = (x) => typeof x === "bigint" && _0n2 < x && x < secp256k1N;
  var TAGGED_HASH_PREFIXES = {};
  var pointToBytes = (point) => point.toRawBytes(true).slice(1);
  var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
  var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
  var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
  var Point = exports.secp256k1.ProjectivePoint;
  var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
  exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE: utils_js_1.numberToBytesBE,
      bytesToNumberBE: utils_js_1.bytesToNumberBE,
      taggedHash,
      mod: modular_js_1.mod
    }
  }))();
  var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((i) => i.map((j) => BigInt(j)))))();
  var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fp.create(BigInt("-11"))
  }))();
  var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fp.create(scalars[0]));
    return isoMap(x, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256_1.sha256
  }))();
  exports.hashToCurve = (() => htf.hashToCurve)();
  exports.encodeToCurve = (() => htf.encodeToCurve)();
});

// node_modules/viem/_cjs/utils/signature/recoverPublicKey.js
var require_recoverPublicKey = __commonJS((exports) => {
  async function recoverPublicKey({ hash: hash2, signature }) {
    const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
    const hashHex = (0, isHex_js_1.isHex)(hash2) ? hash2 : (0, toHex_js_1.toHex)(hash2);
    let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
    if (v === 0 || v === 1)
      v += 27;
    const { secp256k1 } = await Promise.resolve().then(() => require_secp256k1());
    const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
    return `0x${publicKey}`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recoverPublicKey = undefined;
  var isHex_js_1 = require_isHex();
  var fromHex_js_1 = require_fromHex();
  var toHex_js_1 = require_toHex();
  exports.recoverPublicKey = recoverPublicKey;
});

// node_modules/viem/_cjs/utils/signature/recoverAddress.js
var require_recoverAddress = __commonJS((exports) => {
  async function recoverAddress({ hash: hash2, signature }) {
    return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash: hash2, signature }));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recoverAddress = undefined;
  var publicKeyToAddress_js_1 = require_publicKeyToAddress();
  var recoverPublicKey_js_1 = require_recoverPublicKey();
  exports.recoverAddress = recoverAddress;
});

// node_modules/viem/_cjs/constants/strings.js
var require_strings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.presignMessagePrefix = undefined;
  exports.presignMessagePrefix = `\x19Ethereum Signed Message:
`;
});

// node_modules/viem/_cjs/utils/signature/hashMessage.js
var require_hashMessage = __commonJS((exports) => {
  function hashMessage(message, to_) {
    const messageBytes = (() => {
      if (typeof message === "string")
        return (0, toBytes_js_1.stringToBytes)(message);
      if (message.raw instanceof Uint8Array)
        return message.raw;
      return (0, toBytes_js_1.toBytes)(message.raw);
    })();
    const prefixBytes = (0, toBytes_js_1.stringToBytes)(`${strings_js_1.presignMessagePrefix}${messageBytes.length}`);
    return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hashMessage = undefined;
  var strings_js_1 = require_strings();
  var concat_js_1 = require_concat();
  var toBytes_js_1 = require_toBytes();
  var keccak256_js_1 = require_keccak256();
  exports.hashMessage = hashMessage;
});

// node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js
var require_recoverMessageAddress = __commonJS((exports) => {
  async function recoverMessageAddress({ message, signature }) {
    return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recoverMessageAddress = undefined;
  var hashMessage_js_1 = require_hashMessage();
  var recoverAddress_js_1 = require_recoverAddress();
  exports.recoverMessageAddress = recoverMessageAddress;
});

// node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js
var require_recoverTypedDataAddress = __commonJS((exports) => {
  async function recoverTypedDataAddress(parameters) {
    const { domain, message, primaryType, signature, types } = parameters;
    return (0, recoverAddress_js_1.recoverAddress)({
      hash: (0, hashTypedData_js_1.hashTypedData)({
        domain,
        message,
        primaryType,
        types
      }),
      signature
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recoverTypedDataAddress = undefined;
  var hashTypedData_js_1 = require_hashTypedData();
  var recoverAddress_js_1 = require_recoverAddress();
  exports.recoverTypedDataAddress = recoverTypedDataAddress;
});

// node_modules/viem/_cjs/utils/signature/verifyMessage.js
var require_verifyMessage = __commonJS((exports) => {
  async function verifyMessage({ address, message, signature }) {
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyMessage = undefined;
  var getAddress_js_1 = require_getAddress();
  var isAddressEqual_js_1 = require_isAddressEqual();
  var recoverMessageAddress_js_1 = require_recoverMessageAddress();
  exports.verifyMessage = verifyMessage;
});

// node_modules/viem/_cjs/utils/signature/verifyTypedData.js
var require_verifyTypedData = __commonJS((exports) => {
  async function verifyTypedData(parameters) {
    const { address, domain, message, primaryType, signature, types } = parameters;
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
      domain,
      message,
      primaryType,
      signature,
      types
    }));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyTypedData = undefined;
  var getAddress_js_1 = require_getAddress();
  var isAddressEqual_js_1 = require_isAddressEqual();
  var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
  exports.verifyTypedData = verifyTypedData;
});

// node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js
var require_getSerializedTransactionType = __commonJS((exports) => {
  function getSerializedTransactionType(serializedTransaction) {
    const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
    if (serializedType === "0x03")
      return "eip4844";
    if (serializedType === "0x02")
      return "eip1559";
    if (serializedType === "0x01")
      return "eip2930";
    if (serializedType !== "0x" && (0, fromHex_js_1.hexToNumber)(serializedType) >= 192)
      return "legacy";
    throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSerializedTransactionType = undefined;
  var transaction_js_1 = require_transaction2();
  var slice_js_1 = require_slice();
  var fromHex_js_1 = require_fromHex();
  exports.getSerializedTransactionType = getSerializedTransactionType;
});

// node_modules/viem/_cjs/utils/transaction/assertTransaction.js
var require_assertTransaction = __commonJS((exports) => {
  function assertTransactionEIP4844(transaction) {
    const { blobVersionedHashes } = transaction;
    if (blobVersionedHashes) {
      if (blobVersionedHashes.length === 0)
        throw new blob_js_1.EmptyBlobError;
      for (const hash2 of blobVersionedHashes) {
        const size_ = (0, size_js_1.size)(hash2);
        const version2 = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(hash2, 0, 1));
        if (size_ !== 32)
          throw new blob_js_1.InvalidVersionedHashSizeError({ hash: hash2, size: size_ });
        if (version2 !== kzg_js_1.versionedHashVersionKzg)
          throw new blob_js_1.InvalidVersionedHashVersionError({
            hash: hash2,
            version: version2
          });
      }
    }
    assertTransactionEIP1559(transaction);
  }
  function assertTransactionEIP1559(transaction) {
    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
      throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  function assertTransactionEIP2930(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
      throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
  }
  function assertTransactionLegacy(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
    if (typeof chainId !== "undefined" && chainId <= 0)
      throw new chain_js_1.InvalidChainIdError({ chainId });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
      throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
    if (accessList)
      throw new base_js_1.BaseError("`accessList` is not a valid Legacy Transaction attribute.");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertTransactionEIP4844 = undefined;
  var kzg_js_1 = require_kzg();
  var address_js_1 = require_address();
  var base_js_1 = require_base();
  var blob_js_1 = require_blob2();
  var chain_js_1 = require_chain();
  var node_js_1 = require_node();
  var isAddress_js_1 = require_isAddress();
  var size_js_1 = require_size();
  var slice_js_1 = require_slice();
  var fromHex_js_1 = require_fromHex();
  exports.assertTransactionEIP4844 = assertTransactionEIP4844;
  exports.assertTransactionEIP1559 = assertTransactionEIP1559;
  exports.assertTransactionEIP2930 = assertTransactionEIP2930;
  exports.assertTransactionLegacy = assertTransactionLegacy;
});

// node_modules/viem/_cjs/utils/transaction/parseTransaction.js
var require_parseTransaction = __commonJS((exports) => {
  function parseTransaction(serializedTransaction) {
    const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
    if (type === "eip1559")
      return parseTransactionEIP1559(serializedTransaction);
    if (type === "eip2930")
      return parseTransactionEIP2930(serializedTransaction);
    if (type === "eip4844")
      return parseTransactionEIP4844(serializedTransaction);
    return parseTransactionLegacy(serializedTransaction);
  }
  function parseTransactionEIP4844(serializedTransaction) {
    const transactionOrWrapperArray = toTransactionArray(serializedTransaction);
    const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
    const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
    const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s] = transactionArray;
    const [blobs, commitments, proofs] = wrapperArray;
    if (!(transactionArray.length === 11 || transactionArray.length === 14))
      throw new transaction_js_1.InvalidSerializedTransactionError({
        attributes: {
          chainId,
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gas,
          to,
          value,
          data,
          accessList,
          ...transactionArray.length > 9 ? {
            v,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "eip4844"
      });
    const transaction = {
      blobVersionedHashes,
      chainId: (0, fromHex_js_1.hexToNumber)(chainId),
      type: "eip4844"
    };
    if ((0, isHex_js_1.isHex)(to) && to !== "0x")
      transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
      transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== "0x")
      transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
      transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== "0x")
      transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(maxFeePerBlobGas) && maxFeePerBlobGas !== "0x")
      transaction.maxFeePerBlobGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerBlobGas);
    if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
      transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
    if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
      transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== "0x")
      transaction.accessList = parseAccessList(accessList);
    if (blobs && commitments && proofs)
      transaction.sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({
        blobs,
        commitments,
        proofs
      });
    (0, assertTransaction_js_1.assertTransactionEIP4844)(transaction);
    const signature = transactionArray.length === 14 ? parseEIP155Signature(transactionArray) : undefined;
    return { ...signature, ...transaction };
  }
  function parseTransactionEIP1559(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 9 || transactionArray.length === 12))
      throw new transaction_js_1.InvalidSerializedTransactionError({
        attributes: {
          chainId,
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gas,
          to,
          value,
          data,
          accessList,
          ...transactionArray.length > 9 ? {
            v,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "eip1559"
      });
    const transaction = {
      chainId: (0, fromHex_js_1.hexToNumber)(chainId),
      type: "eip1559"
    };
    if ((0, isHex_js_1.isHex)(to) && to !== "0x")
      transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
      transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== "0x")
      transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
      transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== "0x")
      transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
      transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
    if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
      transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== "0x")
      transaction.accessList = parseAccessList(accessList);
    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
    const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : undefined;
    return { ...signature, ...transaction };
  }
  function parseTransactionEIP2930(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 8 || transactionArray.length === 11))
      throw new transaction_js_1.InvalidSerializedTransactionError({
        attributes: {
          chainId,
          nonce,
          gasPrice,
          gas,
          to,
          value,
          data,
          accessList,
          ...transactionArray.length > 8 ? {
            v,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "eip2930"
      });
    const transaction = {
      chainId: (0, fromHex_js_1.hexToNumber)(chainId),
      type: "eip2930"
    };
    if ((0, isHex_js_1.isHex)(to) && to !== "0x")
      transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
      transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== "0x")
      transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
      transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== "0x")
      transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
      transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
    if (accessList.length !== 0 && accessList !== "0x")
      transaction.accessList = parseAccessList(accessList);
    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
    const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : undefined;
    return { ...signature, ...transaction };
  }
  function parseTransactionLegacy(serializedTransaction) {
    const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, "hex");
    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
    if (!(transactionArray.length === 6 || transactionArray.length === 9))
      throw new transaction_js_1.InvalidSerializedTransactionError({
        attributes: {
          nonce,
          gasPrice,
          gas,
          to,
          value,
          data,
          ...transactionArray.length > 6 ? {
            v: chainIdOrV_,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "legacy"
      });
    const transaction = {
      type: "legacy"
    };
    if ((0, isHex_js_1.isHex)(to) && to !== "0x")
      transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
      transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== "0x")
      transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
      transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== "0x")
      transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
      transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
    if (transactionArray.length === 6)
      return transaction;
    const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== "0x" ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_) : 0n;
    if (s === "0x" && r === "0x") {
      if (chainIdOrV > 0)
        transaction.chainId = Number(chainIdOrV);
      return transaction;
    }
    const v = chainIdOrV;
    const chainId = Number((v - 35n) / 2n);
    if (chainId > 0)
      transaction.chainId = chainId;
    else if (v !== 27n && v !== 28n)
      throw new transaction_js_1.InvalidLegacyVError({ v });
    delete transaction.yParity;
    transaction.v = v;
    transaction.s = s;
    transaction.r = r;
    return transaction;
  }
  function toTransactionArray(serializedTransaction) {
    return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
  }
  function parseAccessList(accessList_) {
    const accessList = [];
    for (let i = 0;i < accessList_.length; i++) {
      const [address, storageKeys] = accessList_[i];
      if (!(0, isAddress_js_1.isAddress)(address, { strict: false }))
        throw new address_js_1.InvalidAddressError({ address });
      accessList.push({
        address,
        storageKeys: storageKeys.map((key) => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))
      });
    }
    return accessList;
  }
  function parseEIP155Signature(transactionArray) {
    const signature = transactionArray.slice(-3);
    const v = signature[0] === "0x" || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
    return {
      r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
      s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
      v,
      yParity: v === 27n ? 0 : 1
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAccessList = exports.toTransactionArray = exports.parseTransaction = undefined;
  var address_js_1 = require_address();
  var transaction_js_1 = require_transaction2();
  var isAddress_js_1 = require_isAddress();
  var toBlobSidecars_js_1 = require_toBlobSidecars();
  var isHex_js_1 = require_isHex();
  var pad_js_1 = require_pad();
  var trim_js_1 = require_trim();
  var fromHex_js_1 = require_fromHex();
  var fromRlp_js_1 = require_fromRlp();
  var isHash_js_1 = require_isHash();
  var assertTransaction_js_1 = require_assertTransaction();
  var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
  exports.parseTransaction = parseTransaction;
  exports.toTransactionArray = toTransactionArray;
  exports.parseAccessList = parseAccessList;
});

// node_modules/viem/_cjs/utils/transaction/serializeAccessList.js
var require_serializeAccessList = __commonJS((exports) => {
  function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0)
      return [];
    const serializedAccessList = [];
    for (let i = 0;i < accessList.length; i++) {
      const { address, storageKeys } = accessList[i];
      for (let j = 0;j < storageKeys.length; j++) {
        if (storageKeys[j].length - 2 !== 64) {
          throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
        }
      }
      if (!(0, isAddress_js_1.isAddress)(address, { strict: false })) {
        throw new address_js_1.InvalidAddressError({ address });
      }
      serializedAccessList.push([address, storageKeys]);
    }
    return serializedAccessList;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializeAccessList = undefined;
  var address_js_1 = require_address();
  var transaction_js_1 = require_transaction2();
  var isAddress_js_1 = require_isAddress();
  exports.serializeAccessList = serializeAccessList;
});

// node_modules/viem/_cjs/utils/transaction/serializeTransaction.js
var require_serializeTransaction = __commonJS((exports) => {
  function serializeTransaction(transaction, signature) {
    const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
    if (type === "eip1559")
      return serializeTransactionEIP1559(transaction, signature);
    if (type === "eip2930")
      return serializeTransactionEIP2930(transaction, signature);
    if (type === "eip4844")
      return serializeTransactionEIP4844(transaction, signature);
    return serializeTransactionLegacy(transaction, signature);
  }
  function serializeTransactionEIP4844(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP4844)(transaction);
    let blobVersionedHashes = transaction.blobVersionedHashes;
    let sidecars = transaction.sidecars;
    if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
      const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => (0, toHex_js_1.bytesToHex)(x));
      const kzg = transaction.kzg;
      const commitments2 = (0, blobsToCommitments_js_1.blobsToCommitments)({
        blobs: blobs2,
        kzg
      });
      if (typeof blobVersionedHashes === "undefined")
        blobVersionedHashes = (0, commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes)({
          commitments: commitments2
        });
      if (typeof sidecars === "undefined") {
        const proofs2 = (0, blobsToProofs_js_1.blobsToProofs)({ blobs: blobs2, commitments: commitments2, kzg });
        sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
      }
    }
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
      (0, toHex_js_1.toHex)(chainId),
      nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
      maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      maxFeePerBlobGas ? (0, toHex_js_1.toHex)(maxFeePerBlobGas) : "0x",
      blobVersionedHashes ?? [],
      ...toYParitySignatureArray(transaction, signature)
    ];
    const blobs = [];
    const commitments = [];
    const proofs = [];
    if (sidecars)
      for (let i = 0;i < sidecars.length; i++) {
        const { blob, commitment, proof } = sidecars[i];
        blobs.push(blob);
        commitments.push(commitment);
        proofs.push(proof);
      }
    return (0, concat_js_1.concatHex)([
      "0x03",
      sidecars ? (0, toRlp_js_1.toRlp)([serializedTransaction, blobs, commitments, proofs]) : (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function serializeTransactionEIP1559(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
      (0, toHex_js_1.toHex)(chainId),
      nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
      maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      ...toYParitySignatureArray(transaction, signature)
    ];
    return (0, concat_js_1.concatHex)([
      "0x02",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function serializeTransactionEIP2930(transaction, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
      (0, toHex_js_1.toHex)(chainId),
      nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
      gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      ...toYParitySignatureArray(transaction, signature)
    ];
    return (0, concat_js_1.concatHex)([
      "0x01",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function serializeTransactionLegacy(transaction, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
    let serializedTransaction = [
      nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
      gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      data ?? "0x"
    ];
    if (signature) {
      const v = (() => {
        if (signature.v >= 35n) {
          const inferredChainId = (signature.v - 35n) / 2n;
          if (inferredChainId > 0)
            return signature.v;
          return 27n + (signature.v === 35n ? 0n : 1n);
        }
        if (chainId > 0)
          return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
        const v2 = 27n + (signature.v === 27n ? 0n : 1n);
        if (signature.v !== v2)
          throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
        return v2;
      })();
      serializedTransaction = [
        ...serializedTransaction,
        (0, toHex_js_1.toHex)(v),
        signature.r,
        signature.s
      ];
    } else if (chainId > 0) {
      serializedTransaction = [
        ...serializedTransaction,
        (0, toHex_js_1.toHex)(chainId),
        "0x",
        "0x"
      ];
    }
    return (0, toRlp_js_1.toRlp)(serializedTransaction);
  }
  function toYParitySignatureArray(transaction, signature) {
    const { r, s, v, yParity } = signature ?? transaction;
    if (typeof r === "undefined")
      return [];
    if (typeof s === "undefined")
      return [];
    if (typeof v === "undefined" && typeof yParity === "undefined")
      return [];
    const yParity_ = (() => {
      if (typeof yParity === "number")
        return yParity ? (0, toHex_js_1.toHex)(1) : "0x";
      if (v === 0n)
        return "0x";
      if (v === 1n)
        return (0, toHex_js_1.toHex)(1);
      return v === 27n ? "0x" : (0, toHex_js_1.toHex)(1);
    })();
    return [yParity_, (0, trim_js_1.trim)(r), (0, trim_js_1.trim)(s)];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toYParitySignatureArray = exports.serializeTransaction = undefined;
  var transaction_js_1 = require_transaction2();
  var blobsToCommitments_js_1 = require_blobsToCommitments();
  var blobsToProofs_js_1 = require_blobsToProofs();
  var commitmentsToVersionedHashes_js_1 = require_commitmentsToVersionedHashes();
  var toBlobSidecars_js_1 = require_toBlobSidecars();
  var concat_js_1 = require_concat();
  var trim_js_1 = require_trim();
  var toHex_js_1 = require_toHex();
  var toRlp_js_1 = require_toRlp();
  var assertTransaction_js_1 = require_assertTransaction();
  var getTransactionType_js_1 = require_getTransactionType();
  var serializeAccessList_js_1 = require_serializeAccessList();
  exports.serializeTransaction = serializeTransaction;
  exports.toYParitySignatureArray = toYParitySignatureArray;
});

// node_modules/viem/_cjs/utils/unit/parseUnits.js
var require_parseUnits = __commonJS((exports) => {
  function parseUnits(value, decimals) {
    let [integer, fraction = "0"] = value.split(".");
    const negative = integer.startsWith("-");
    if (negative)
      integer = integer.slice(1);
    fraction = fraction.replace(/(0+)$/, "");
    if (decimals === 0) {
      if (Math.round(Number(`.${fraction}`)) === 1)
        integer = `${BigInt(integer) + 1n}`;
      fraction = "";
    } else if (fraction.length > decimals) {
      const [left, unit, right] = [
        fraction.slice(0, decimals - 1),
        fraction.slice(decimals - 1, decimals),
        fraction.slice(decimals)
      ];
      const rounded = Math.round(Number(`${unit}.${right}`));
      if (rounded > 9)
        fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
      else
        fraction = `${left}${rounded}`;
      if (fraction.length > decimals) {
        fraction = fraction.slice(1);
        integer = `${BigInt(integer) + 1n}`;
      }
      fraction = fraction.slice(0, decimals);
    } else {
      fraction = fraction.padEnd(decimals, "0");
    }
    return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseUnits = undefined;
  exports.parseUnits = parseUnits;
});

// node_modules/viem/_cjs/utils/unit/parseEther.js
var require_parseEther = __commonJS((exports) => {
  function parseEther(ether, unit = "wei") {
    return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEther = undefined;
  var unit_js_1 = require_unit();
  var parseUnits_js_1 = require_parseUnits();
  exports.parseEther = parseEther;
});

// node_modules/viem/_cjs/utils/unit/parseGwei.js
var require_parseGwei = __commonJS((exports) => {
  function parseGwei(ether, unit = "wei") {
    return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGwei = undefined;
  var unit_js_1 = require_unit();
  var parseUnits_js_1 = require_parseUnits();
  exports.parseGwei = parseGwei;
});

// node_modules/viem/_cjs/utils/index.js
var require_utils7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAddressEqual = exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.parseEventLogs = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.stringify = exports.getWebSocketRpcClient = exports.socketClientCache = exports.getSocketRpcClient = exports.getHttpRpcClient = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.ccipRequest = exports.buildRequest = undefined;
  exports.getContractError = exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = exports.concatHex = exports.concatBytes = exports.concat = undefined;
  exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHash = exports.toFunctionHash = exports.toEventHash = exports.getFunctionSignature = exports.toFunctionSignature = exports.getEventSignature = exports.toEventSignature = exports.getFunctionSelector = exports.toFunctionSelector = exports.getEventSelector = exports.toEventSelector = exports.defineFormatter = exports.getAction = exports.getTransactionError = exports.getEstimateGasError = undefined;
  var buildRequest_js_1 = require_buildRequest();
  Object.defineProperty(exports, "buildRequest", { enumerable: true, get: function() {
    return buildRequest_js_1.buildRequest;
  } });
  var ccip_js_1 = require_ccip2();
  Object.defineProperty(exports, "ccipRequest", { enumerable: true, get: function() {
    return ccip_js_1.ccipRequest;
  } });
  Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
    return ccip_js_1.ccipRequest;
  } });
  Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
    return ccip_js_1.offchainLookup;
  } });
  Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
    return ccip_js_1.offchainLookupAbiItem;
  } });
  Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
    return ccip_js_1.offchainLookupSignature;
  } });
  var assertCurrentChain_js_1 = require_assertCurrentChain();
  Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
    return assertCurrentChain_js_1.assertCurrentChain;
  } });
  var defineChain_js_1 = require_defineChain();
  Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
    return defineChain_js_1.defineChain;
  } });
  var extractChain_js_1 = require_extractChain();
  Object.defineProperty(exports, "extractChain", { enumerable: true, get: function() {
    return extractChain_js_1.extractChain;
  } });
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
    return getChainContractAddress_js_1.getChainContractAddress;
  } });
  var regex_js_1 = require_regex2();
  Object.defineProperty(exports, "arrayRegex", { enumerable: true, get: function() {
    return regex_js_1.arrayRegex;
  } });
  Object.defineProperty(exports, "bytesRegex", { enumerable: true, get: function() {
    return regex_js_1.bytesRegex;
  } });
  Object.defineProperty(exports, "integerRegex", { enumerable: true, get: function() {
    return regex_js_1.integerRegex;
  } });
  var compat_js_1 = require_compat();
  Object.defineProperty(exports, "getSocket", { enumerable: true, get: function() {
    return compat_js_1.getSocket;
  } });
  Object.defineProperty(exports, "rpc", { enumerable: true, get: function() {
    return compat_js_1.rpc;
  } });
  var http_js_1 = require_http();
  Object.defineProperty(exports, "getHttpRpcClient", { enumerable: true, get: function() {
    return http_js_1.getHttpRpcClient;
  } });
  var socket_js_1 = require_socket();
  Object.defineProperty(exports, "getSocketRpcClient", { enumerable: true, get: function() {
    return socket_js_1.getSocketRpcClient;
  } });
  Object.defineProperty(exports, "socketClientCache", { enumerable: true, get: function() {
    return socket_js_1.socketClientCache;
  } });
  var webSocket_js_1 = require_webSocket();
  Object.defineProperty(exports, "getWebSocketRpcClient", { enumerable: true, get: function() {
    return webSocket_js_1.getWebSocketRpcClient;
  } });
  var stringify_js_1 = require_stringify();
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return stringify_js_1.stringify;
  } });
  var typedData_js_1 = require_typedData();
  Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
    return typedData_js_1.validateTypedData;
  } });
  var decodeAbiParameters_js_1 = require_decodeAbiParameters();
  Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
    return decodeAbiParameters_js_1.decodeAbiParameters;
  } });
  var decodeErrorResult_js_1 = require_decodeErrorResult();
  Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
    return decodeErrorResult_js_1.decodeErrorResult;
  } });
  var decodeEventLog_js_1 = require_decodeEventLog();
  Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
    return decodeEventLog_js_1.decodeEventLog;
  } });
  var decodeFunctionData_js_1 = require_decodeFunctionData();
  Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
    return decodeFunctionData_js_1.decodeFunctionData;
  } });
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
    return decodeFunctionResult_js_1.decodeFunctionResult;
  } });
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
    return encodeAbiParameters_js_1.encodeAbiParameters;
  } });
  var encodeDeployData_js_1 = require_encodeDeployData();
  Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
    return encodeDeployData_js_1.encodeDeployData;
  } });
  var encodeErrorResult_js_1 = require_encodeErrorResult();
  Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
    return encodeErrorResult_js_1.encodeErrorResult;
  } });
  var encodeEventTopics_js_1 = require_encodeEventTopics();
  Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
    return encodeEventTopics_js_1.encodeEventTopics;
  } });
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
    return encodeFunctionData_js_1.encodeFunctionData;
  } });
  var encodeFunctionResult_js_1 = require_encodeFunctionResult();
  Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
    return encodeFunctionResult_js_1.encodeFunctionResult;
  } });
  var parseEventLogs_js_1 = require_parseEventLogs();
  Object.defineProperty(exports, "parseEventLogs", { enumerable: true, get: function() {
    return parseEventLogs_js_1.parseEventLogs;
  } });
  var getAbiItem_js_1 = require_getAbiItem();
  Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
    return getAbiItem_js_1.getAbiItem;
  } });
  var abitype_1 = require_exports();
  Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
    return abitype_1.parseAbi;
  } });
  Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
    return abitype_1.parseAbiItem;
  } });
  Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
    return abitype_1.parseAbiParameter;
  } });
  Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
    return abitype_1.parseAbiParameters;
  } });
  var encodePacked_js_1 = require_encodePacked();
  Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
    return encodePacked_js_1.encodePacked;
  } });
  var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
  Object.defineProperty(exports, "formatAbiItemWithArgs", { enumerable: true, get: function() {
    return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs;
  } });
  var formatAbiItem_js_1 = require_formatAbiItem2();
  Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
    return formatAbiItem_js_1.formatAbiItem;
  } });
  Object.defineProperty(exports, "formatAbiParams", { enumerable: true, get: function() {
    return formatAbiItem_js_1.formatAbiParams;
  } });
  var parseAccount_js_1 = require_parseAccount();
  Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
    return parseAccount_js_1.parseAccount;
  } });
  var publicKeyToAddress_js_1 = require_publicKeyToAddress();
  Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
    return publicKeyToAddress_js_1.publicKeyToAddress;
  } });
  var getContractAddress_js_1 = require_getContractAddress();
  Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
    return getContractAddress_js_1.getContractAddress;
  } });
  Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
    return getContractAddress_js_1.getCreateAddress;
  } });
  Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
    return getContractAddress_js_1.getCreate2Address;
  } });
  var getAddress_js_1 = require_getAddress();
  Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
    return getAddress_js_1.getAddress;
  } });
  var isAddress_js_1 = require_isAddress();
  Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
    return isAddress_js_1.isAddress;
  } });
  var isAddressEqual_js_1 = require_isAddressEqual();
  Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
    return isAddressEqual_js_1.isAddressEqual;
  } });
  var concat_js_1 = require_concat();
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_js_1.concat;
  } });
  Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
    return concat_js_1.concatBytes;
  } });
  Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
    return concat_js_1.concatHex;
  } });
  var isBytes_js_1 = require_isBytes();
  Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
    return isBytes_js_1.isBytes;
  } });
  var isHex_js_1 = require_isHex();
  Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
    return isHex_js_1.isHex;
  } });
  var pad_js_1 = require_pad();
  Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
    return pad_js_1.pad;
  } });
  Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
    return pad_js_1.padBytes;
  } });
  Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
    return pad_js_1.padHex;
  } });
  var size_js_1 = require_size();
  Object.defineProperty(exports, "size", { enumerable: true, get: function() {
    return size_js_1.size;
  } });
  var slice_js_1 = require_slice();
  Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
    return slice_js_1.slice;
  } });
  Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
    return slice_js_1.sliceBytes;
  } });
  Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
    return slice_js_1.sliceHex;
  } });
  var trim_js_1 = require_trim();
  Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
    return trim_js_1.trim;
  } });
  var block_js_1 = require_block();
  Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
    return block_js_1.defineBlock;
  } });
  Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
    return block_js_1.formatBlock;
  } });
  var transaction_js_1 = require_transaction();
  Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
    return transaction_js_1.defineTransaction;
  } });
  Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
    return transaction_js_1.formatTransaction;
  } });
  Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
    return transaction_js_1.transactionType;
  } });
  var log_js_1 = require_log();
  Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
    return log_js_1.formatLog;
  } });
  var transactionReceipt_js_1 = require_transactionReceipt();
  Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
    return transactionReceipt_js_1.defineTransactionReceipt;
  } });
  var transactionRequest_js_1 = require_transactionRequest();
  Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
    return transactionRequest_js_1.defineTransactionRequest;
  } });
  Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
    return transactionRequest_js_1.formatTransactionRequest;
  } });
  var extract_js_1 = require_extract();
  Object.defineProperty(exports, "extract", { enumerable: true, get: function() {
    return extract_js_1.extract;
  } });
  var toRlp_js_1 = require_toRlp();
  Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
    return toRlp_js_1.toRlp;
  } });
  var toBytes_js_1 = require_toBytes();
  Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.boolToBytes;
  } });
  Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
    return toBytes_js_1.toBytes;
  } });
  Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.hexToBytes;
  } });
  Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.numberToBytes;
  } });
  Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.stringToBytes;
  } });
  var toHex_js_1 = require_toHex();
  Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
    return toHex_js_1.boolToHex;
  } });
  Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
    return toHex_js_1.bytesToHex;
  } });
  Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
    return toHex_js_1.toHex;
  } });
  Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
    return toHex_js_1.numberToHex;
  } });
  Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
    return toHex_js_1.stringToHex;
  } });
  var fromBytes_js_1 = require_fromBytes();
  Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToBigInt;
  } });
  Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToBigInt;
  } });
  Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToBool;
  } });
  Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToNumber;
  } });
  Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToString;
  } });
  Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
    return fromBytes_js_1.fromBytes;
  } });
  var fromHex_js_1 = require_fromHex();
  Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
    return fromHex_js_1.fromHex;
  } });
  Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
    return fromHex_js_1.hexToBool;
  } });
  Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
    return fromHex_js_1.hexToBigInt;
  } });
  Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
    return fromHex_js_1.hexToNumber;
  } });
  Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
    return fromHex_js_1.hexToString;
  } });
  var fromRlp_js_1 = require_fromRlp();
  Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
    return fromRlp_js_1.fromRlp;
  } });
  var getNodeError_js_1 = require_getNodeError();
  Object.defineProperty(exports, "containsNodeError", { enumerable: true, get: function() {
    return getNodeError_js_1.containsNodeError;
  } });
  Object.defineProperty(exports, "getNodeError", { enumerable: true, get: function() {
    return getNodeError_js_1.getNodeError;
  } });
  var getCallError_js_1 = require_getCallError();
  Object.defineProperty(exports, "getCallError", { enumerable: true, get: function() {
    return getCallError_js_1.getCallError;
  } });
  var getContractError_js_1 = require_getContractError();
  Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
    return getContractError_js_1.getContractError;
  } });
  var getEstimateGasError_js_1 = require_getEstimateGasError();
  Object.defineProperty(exports, "getEstimateGasError", { enumerable: true, get: function() {
    return getEstimateGasError_js_1.getEstimateGasError;
  } });
  var getTransactionError_js_1 = require_getTransactionError();
  Object.defineProperty(exports, "getTransactionError", { enumerable: true, get: function() {
    return getTransactionError_js_1.getTransactionError;
  } });
  var getAction_js_1 = require_getAction();
  Object.defineProperty(exports, "getAction", { enumerable: true, get: function() {
    return getAction_js_1.getAction;
  } });
  var formatter_js_1 = require_formatter();
  Object.defineProperty(exports, "defineFormatter", { enumerable: true, get: function() {
    return formatter_js_1.defineFormatter;
  } });
  var toEventSelector_js_1 = require_toEventSelector();
  Object.defineProperty(exports, "toEventSelector", { enumerable: true, get: function() {
    return toEventSelector_js_1.toEventSelector;
  } });
  Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
    return toEventSelector_js_1.toEventSelector;
  } });
  var toFunctionSelector_js_1 = require_toFunctionSelector();
  Object.defineProperty(exports, "toFunctionSelector", { enumerable: true, get: function() {
    return toFunctionSelector_js_1.toFunctionSelector;
  } });
  Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
    return toFunctionSelector_js_1.toFunctionSelector;
  } });
  var toEventSignature_js_1 = require_toEventSignature();
  Object.defineProperty(exports, "toEventSignature", { enumerable: true, get: function() {
    return toEventSignature_js_1.toEventSignature;
  } });
  Object.defineProperty(exports, "getEventSignature", { enumerable: true, get: function() {
    return toEventSignature_js_1.toEventSignature;
  } });
  var toFunctionSignature_js_1 = require_toFunctionSignature();
  Object.defineProperty(exports, "toFunctionSignature", { enumerable: true, get: function() {
    return toFunctionSignature_js_1.toFunctionSignature;
  } });
  Object.defineProperty(exports, "getFunctionSignature", { enumerable: true, get: function() {
    return toFunctionSignature_js_1.toFunctionSignature;
  } });
  var toEventHash_js_1 = require_toEventHash();
  Object.defineProperty(exports, "toEventHash", { enumerable: true, get: function() {
    return toEventHash_js_1.toEventHash;
  } });
  var toFunctionHash_js_1 = require_toFunctionHash();
  Object.defineProperty(exports, "toFunctionHash", { enumerable: true, get: function() {
    return toFunctionHash_js_1.toFunctionHash;
  } });
  var isHash_js_1 = require_isHash();
  Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
    return isHash_js_1.isHash;
  } });
  var keccak256_js_1 = require_keccak256();
  Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
    return keccak256_js_1.keccak256;
  } });
  var sha256_js_1 = require_sha2562();
  Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
    return sha256_js_1.sha256;
  } });
  var ripemd160_js_1 = require_ripemd1602();
  Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
    return ripemd160_js_1.ripemd160;
  } });
  var hashTypedData_js_1 = require_hashTypedData();
  Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
    return hashTypedData_js_1.hashTypedData;
  } });
  var recoverAddress_js_1 = require_recoverAddress();
  Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
    return recoverAddress_js_1.recoverAddress;
  } });
  var recoverMessageAddress_js_1 = require_recoverMessageAddress();
  Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
    return recoverMessageAddress_js_1.recoverMessageAddress;
  } });
  var recoverPublicKey_js_1 = require_recoverPublicKey();
  Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
    return recoverPublicKey_js_1.recoverPublicKey;
  } });
  var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
  Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
    return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
  } });
  var verifyMessage_js_1 = require_verifyMessage();
  Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
    return verifyMessage_js_1.verifyMessage;
  } });
  var verifyTypedData_js_1 = require_verifyTypedData();
  Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
    return verifyTypedData_js_1.verifyTypedData;
  } });
  var hashMessage_js_1 = require_hashMessage();
  Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
    return hashMessage_js_1.hashMessage;
  } });
  var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
  Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
    return getSerializedTransactionType_js_1.getSerializedTransactionType;
  } });
  var getTransactionType_js_1 = require_getTransactionType();
  Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
    return getTransactionType_js_1.getTransactionType;
  } });
  var assertRequest_js_1 = require_assertRequest();
  Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
    return assertRequest_js_1.assertRequest;
  } });
  var assertTransaction_js_1 = require_assertTransaction();
  Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
    return assertTransaction_js_1.assertTransactionEIP1559;
  } });
  Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
    return assertTransaction_js_1.assertTransactionEIP2930;
  } });
  Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
    return assertTransaction_js_1.assertTransactionLegacy;
  } });
  var parseTransaction_js_1 = require_parseTransaction();
  Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
    return parseTransaction_js_1.parseTransaction;
  } });
  var serializeTransaction_js_1 = require_serializeTransaction();
  Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
    return serializeTransaction_js_1.serializeTransaction;
  } });
  var serializeAccessList_js_1 = require_serializeAccessList();
  Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
    return serializeAccessList_js_1.serializeAccessList;
  } });
  var formatEther_js_1 = require_formatEther();
  Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
    return formatEther_js_1.formatEther;
  } });
  var formatGwei_js_1 = require_formatGwei();
  Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
    return formatGwei_js_1.formatGwei;
  } });
  var formatUnits_js_1 = require_formatUnits();
  Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
    return formatUnits_js_1.formatUnits;
  } });
  var parseUnits_js_1 = require_parseUnits();
  Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
    return parseUnits_js_1.parseUnits;
  } });
  var parseEther_js_1 = require_parseEther();
  Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
    return parseEther_js_1.parseEther;
  } });
  var parseGwei_js_1 = require_parseGwei();
  Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
    return parseGwei_js_1.parseGwei;
  } });
});

// node_modules/viem/_cjs/utils/formatters/proof.js
var require_proof = __commonJS((exports) => {
  function formatStorageProof(storageProof) {
    return storageProof.map((proof) => ({
      ...proof,
      value: BigInt(proof.value)
    }));
  }
  function formatProof(proof) {
    return {
      ...proof,
      balance: proof.balance ? BigInt(proof.balance) : undefined,
      nonce: proof.nonce ? (0, index_js_1.hexToNumber)(proof.nonce) : undefined,
      storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : undefined
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatProof = undefined;
  var index_js_1 = require_utils7();
  exports.formatProof = formatProof;
});

// node_modules/viem/_cjs/actions/public/getProof.js
var require_getProof = __commonJS((exports) => {
  async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
    const blockTag = blockTag_ ?? "latest";
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const proof = await client.request({
      method: "eth_getProof",
      params: [address, storageKeys, blockNumberHex || blockTag]
    });
    return (0, proof_js_1.formatProof)(proof);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getProof = undefined;
  var toHex_js_1 = require_toHex();
  var proof_js_1 = require_proof();
  exports.getProof = getProof;
});

// node_modules/viem/_cjs/actions/public/getStorageAt.js
var require_getStorageAt = __commonJS((exports) => {
  async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const data = await client.request({
      method: "eth_getStorageAt",
      params: [address, slot, blockNumberHex || blockTag]
    });
    return data;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStorageAt = undefined;
  var toHex_js_1 = require_toHex();
  exports.getStorageAt = getStorageAt;
});

// node_modules/viem/_cjs/actions/public/getTransaction.js
var require_getTransaction = __commonJS((exports) => {
  async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index }) {
    const blockTag = blockTag_ || "latest";
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let transaction = null;
    if (hash2) {
      transaction = await client.request({
        method: "eth_getTransactionByHash",
        params: [hash2]
      });
    } else if (blockHash) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [blockHash, (0, toHex_js_1.numberToHex)(index)]
      });
    } else if (blockNumberHex || blockTag) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index)]
      });
    }
    if (!transaction)
      throw new transaction_js_1.TransactionNotFoundError({
        blockHash,
        blockNumber,
        blockTag,
        hash: hash2,
        index
      });
    const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
    return format(transaction);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTransaction = undefined;
  var transaction_js_1 = require_transaction2();
  var toHex_js_1 = require_toHex();
  var transaction_js_2 = require_transaction();
  exports.getTransaction = getTransaction;
});

// node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js
var require_getTransactionConfirmations = __commonJS((exports) => {
  async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
      (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({}),
      hash2 ? (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, "getBlockNumber")({ hash: hash2 }) : undefined
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber)
      return 0n;
    return blockNumber - transactionBlockNumber + 1n;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTransactionConfirmations = undefined;
  var getAction_js_1 = require_getAction();
  var getBlockNumber_js_1 = require_getBlockNumber();
  var getTransaction_js_1 = require_getTransaction();
  exports.getTransactionConfirmations = getTransactionConfirmations;
});

// node_modules/viem/_cjs/actions/public/getTransactionReceipt.js
var require_getTransactionReceipt = __commonJS((exports) => {
  async function getTransactionReceipt(client, { hash: hash2 }) {
    const receipt = await client.request({
      method: "eth_getTransactionReceipt",
      params: [hash2]
    });
    if (!receipt)
      throw new transaction_js_1.TransactionReceiptNotFoundError({ hash: hash2 });
    const format = client.chain?.formatters?.transactionReceipt?.format || transactionReceipt_js_1.formatTransactionReceipt;
    return format(receipt);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTransactionReceipt = undefined;
  var transaction_js_1 = require_transaction2();
  var transactionReceipt_js_1 = require_transactionReceipt();
  exports.getTransactionReceipt = getTransactionReceipt;
});

// node_modules/viem/_cjs/actions/public/multicall.js
var require_multicall = __commonJS((exports) => {
  async function multicall(client, parameters) {
    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
    const contracts = parameters.contracts;
    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. multicallAddress is required.");
      multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i = 0;i < contracts.length; i++) {
      const { abi, address, args, functionName } = contracts[i];
      try {
        const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({ abi, args, functionName });
        currentChunkSize += (callData.length - 2) / 2;
        if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
          currentChunk++;
          currentChunkSize = (callData.length - 2) / 2;
          chunkedCalls[currentChunk] = [];
        }
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData,
            target: address
          }
        ];
      } catch (err) {
        const error = (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData: "0x",
            target: address
          }
        ];
      }
    }
    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
      abi: abis_js_1.multicall3Abi,
      address: multicallAddress,
      args: [calls],
      blockNumber,
      blockTag,
      functionName: "aggregate3",
      stateOverride
    })));
    const results = [];
    for (let i = 0;i < aggregate3Results.length; i++) {
      const result = aggregate3Results[i];
      if (result.status === "rejected") {
        if (!allowFailure)
          throw result.reason;
        for (let j = 0;j < chunkedCalls[i].length; j++) {
          results.push({
            status: "failure",
            error: result.reason,
            result: undefined
          });
        }
        continue;
      }
      const aggregate3Result = result.value;
      for (let j = 0;j < aggregate3Result.length; j++) {
        const { returnData, success } = aggregate3Result[j];
        const { callData } = chunkedCalls[i][j];
        const { abi, address, functionName, args } = contracts[results.length];
        try {
          if (callData === "0x")
            throw new abi_js_1.AbiDecodingZeroDataError;
          if (!success)
            throw new contract_js_1.RawContractError({ data: returnData });
          const result2 = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi,
            args,
            data: returnData,
            functionName
          });
          results.push(allowFailure ? { result: result2, status: "success" } : result2);
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          results.push({ error, result: undefined, status: "failure" });
        }
      }
    }
    if (results.length !== contracts.length)
      throw new base_js_1.BaseError("multicall results mismatch");
    return results;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multicall = undefined;
  var abis_js_1 = require_abis();
  var abi_js_1 = require_abi();
  var base_js_1 = require_base();
  var contract_js_1 = require_contract();
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  var getContractError_js_1 = require_getContractError();
  var getAction_js_1 = require_getAction();
  var readContract_js_1 = require_readContract();
  exports.multicall = multicall;
});

// node_modules/viem/_cjs/constants/contracts.js
var require_contracts2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.universalSignatureValidatorByteCode = undefined;
  exports.universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
});

// node_modules/viem/_cjs/utils/data/isBytesEqual.js
var require_isBytesEqual = __commonJS((exports) => {
  function isBytesEqual(a_, b_) {
    const a = (0, isHex_js_1.isHex)(a_) ? (0, toBytes_js_1.toBytes)(a_) : a_;
    const b = (0, isHex_js_1.isHex)(b_) ? (0, toBytes_js_1.toBytes)(b_) : b_;
    return (0, utils_1.equalBytes)(a, b);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBytesEqual = undefined;
  var utils_1 = require_utils6();
  var toBytes_js_1 = require_toBytes();
  var isHex_js_1 = require_isHex();
  exports.isBytesEqual = isBytesEqual;
});

// node_modules/viem/_cjs/actions/public/verifyHash.js
var require_verifyHash = __commonJS((exports) => {
  async function verifyHash(client, { address, hash: hash2, signature, ...callRequest }) {
    const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);
    try {
      const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
        data: (0, index_js_1.encodeDeployData)({
          abi: abis_js_1.universalSignatureValidatorAbi,
          args: [address, hash2, signatureHex],
          bytecode: contracts_js_1.universalSignatureValidatorByteCode
        }),
        ...callRequest
      });
      return (0, isBytesEqual_js_1.isBytesEqual)(data ?? "0x0", "0x1");
    } catch (error) {
      if (error instanceof contract_js_1.CallExecutionError) {
        return false;
      }
      throw error;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyHash = undefined;
  var abis_js_1 = require_abis();
  var contracts_js_1 = require_contracts2();
  var contract_js_1 = require_contract();
  var isBytesEqual_js_1 = require_isBytesEqual();
  var getAction_js_1 = require_getAction();
  var index_js_1 = require_utils7();
  var call_js_1 = require_call();
  exports.verifyHash = verifyHash;
});

// node_modules/viem/_cjs/actions/public/verifyMessage.js
var require_verifyMessage2 = __commonJS((exports) => {
  async function verifyMessage(client, { address, message, signature, ...callRequest }) {
    const hash2 = (0, index_js_1.hashMessage)(message);
    return (0, verifyHash_js_1.verifyHash)(client, {
      address,
      hash: hash2,
      signature,
      ...callRequest
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyMessage = undefined;
  var index_js_1 = require_utils7();
  var verifyHash_js_1 = require_verifyHash();
  exports.verifyMessage = verifyMessage;
});

// node_modules/viem/_cjs/actions/public/verifyTypedData.js
var require_verifyTypedData2 = __commonJS((exports) => {
  async function verifyTypedData(client, parameters) {
    const { address, signature, message, primaryType, types, domain, ...callRequest } = parameters;
    const hash2 = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
    return (0, verifyHash_js_1.verifyHash)(client, {
      address,
      hash: hash2,
      signature,
      ...callRequest
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyTypedData = undefined;
  var hashTypedData_js_1 = require_hashTypedData();
  var verifyHash_js_1 = require_verifyHash();
  exports.verifyTypedData = verifyTypedData;
});

// node_modules/viem/_cjs/actions/public/watchBlockNumber.js
var require_watchBlockNumber = __commonJS((exports) => {
  function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    let prevBlockNumber;
    const pollBlockNumber = () => {
      const observerId = (0, stringify_js_1.stringify)([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed,
        pollingInterval
      ]);
      return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
        try {
          const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
          if (prevBlockNumber) {
            if (blockNumber === prevBlockNumber)
              return;
            if (blockNumber - prevBlockNumber > 1 && emitMissed) {
              for (let i = prevBlockNumber + 1n;i < blockNumber; i++) {
                emit.onBlockNumber(i, prevBlockNumber);
                prevBlockNumber = i;
              }
            }
          }
          if (!prevBlockNumber || blockNumber > prevBlockNumber) {
            emit.onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlockNumber = () => {
      const observerId = (0, stringify_js_1.stringify)([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed
      ]);
      return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                emit.onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                emit.onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return () => unsubscribe();
      });
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.watchBlockNumber = undefined;
  var fromHex_js_1 = require_fromHex();
  var getAction_js_1 = require_getAction();
  var observe_js_1 = require_observe();
  var poll_js_1 = require_poll();
  var stringify_js_1 = require_stringify();
  var getBlockNumber_js_1 = require_getBlockNumber();
  exports.watchBlockNumber = watchBlockNumber;
});

// node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js
var require_waitForTransactionReceipt = __commonJS((exports) => {
  async function waitForTransactionReceipt(client, { confirmations = 1, hash: hash2, onReplaced, pollingInterval = client.pollingInterval, retryCount = 6, retryDelay = ({ count }) => ~~(1 << count) * 200, timeout }) {
    const observerId = (0, stringify_js_1.stringify)(["waitForTransactionReceipt", client.uid, hash2]);
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    return new Promise((resolve, reject) => {
      if (timeout)
        setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout);
      const _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
        const _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, "watchBlockNumber")({
          emitMissed: true,
          emitOnBegin: true,
          poll: true,
          pollingInterval,
          async onBlockNumber(blockNumber_) {
            if (retrying)
              return;
            let blockNumber = blockNumber_;
            const done = (fn) => {
              _unwatch();
              fn();
              _unobserve();
            };
            try {
              if (receipt) {
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                done(() => emit.resolve(receipt));
                return;
              }
              if (!transaction) {
                retrying = true;
                await (0, withRetry_js_1.withRetry)(async () => {
                  transaction = await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, "getTransaction")({ hash: hash2 });
                  if (transaction.blockNumber)
                    blockNumber = transaction.blockNumber;
                }, {
                  delay: retryDelay,
                  retryCount
                });
                retrying = false;
              }
              receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit.resolve(receipt));
            } catch (err) {
              if (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError) {
                if (!transaction) {
                  retrying = false;
                  return;
                }
                try {
                  replacedTransaction = transaction;
                  retrying = true;
                  const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
                    blockNumber,
                    includeTransactions: true
                  }), {
                    delay: retryDelay,
                    retryCount,
                    shouldRetry: ({ error }) => error instanceof block_js_1.BlockNotFoundError
                  });
                  retrying = false;
                  const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                  if (!replacementTransaction)
                    return;
                  receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({
                    hash: replacementTransaction.hash
                  });
                  if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                    return;
                  let reason = "replaced";
                  if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                    reason = "repriced";
                  } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                    reason = "cancelled";
                  }
                  done(() => {
                    emit.onReplaced?.({
                      reason,
                      replacedTransaction,
                      transaction: replacementTransaction,
                      transactionReceipt: receipt
                    });
                    emit.resolve(receipt);
                  });
                } catch (err_) {
                  done(() => emit.reject(err_));
                }
              } else {
                done(() => emit.reject(err));
              }
            }
          }
        });
      });
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.waitForTransactionReceipt = undefined;
  var block_js_1 = require_block2();
  var transaction_js_1 = require_transaction2();
  var getAction_js_1 = require_getAction();
  var observe_js_1 = require_observe();
  var withRetry_js_1 = require_withRetry();
  var stringify_js_1 = require_stringify();
  var getBlock_js_1 = require_getBlock();
  var getTransaction_js_1 = require_getTransaction();
  var getTransactionReceipt_js_1 = require_getTransactionReceipt();
  var watchBlockNumber_js_1 = require_watchBlockNumber();
  exports.waitForTransactionReceipt = waitForTransactionReceipt;
});

// node_modules/viem/_cjs/actions/public/watchBlocks.js
var require_watchBlocks = __commonJS((exports) => {
  function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    const includeTransactions = includeTransactions_ ?? false;
    let prevBlock;
    const pollBlocks = () => {
      const observerId = (0, stringify_js_1.stringify)([
        "watchBlocks",
        client.uid,
        blockTag,
        emitMissed,
        emitOnBegin,
        includeTransactions,
        pollingInterval
      ]);
      return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
        try {
          const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
            blockTag,
            includeTransactions
          });
          if (block.number && prevBlock?.number) {
            if (block.number === prevBlock.number)
              return;
            if (block.number - prevBlock.number > 1 && emitMissed) {
              for (let i = prevBlock?.number + 1n;i < block.number; i++) {
                const block2 = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
                  blockNumber: i,
                  includeTransactions
                });
                emit.onBlock(block2, prevBlock);
                prevBlock = block2;
              }
            }
          }
          if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
            emit.onBlock(block, prevBlock);
            prevBlock = block;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlocks = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              if (!active)
                return;
              const format = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
              const block = format(data.result);
              onBlock(block, prevBlock);
              prevBlock = block;
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.watchBlocks = undefined;
  var block_js_1 = require_block();
  var getAction_js_1 = require_getAction();
  var observe_js_1 = require_observe();
  var poll_js_1 = require_poll();
  var stringify_js_1 = require_stringify();
  var getBlock_js_1 = require_getBlock();
  exports.watchBlocks = watchBlocks;
});

// node_modules/viem/_cjs/actions/public/watchEvent.js
var require_watchEvent = __commonJS((exports) => {
  function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket" || typeof fromBlock === "bigint";
    const strict = strict_ ?? false;
    const pollEvent = () => {
      const observerId = (0, stringify_js_1.stringify)([
        "watchEvent",
        address,
        args,
        batch,
        client.uid,
        event,
        pollingInterval,
        fromBlock
      ]);
      return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
        let previousBlockNumber;
        if (fromBlock !== undefined)
          previousBlockNumber = fromBlock - 1n;
        let filter;
        let initialized = false;
        const unwatch = (0, poll_js_1.poll)(async () => {
          if (!initialized) {
            try {
              filter = await (0, getAction_js_1.getAction)(client, createEventFilter_js_1.createEventFilter, "createEventFilter")({
                address,
                args,
                event,
                events,
                strict,
                fromBlock
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
            } else {
              const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({});
              if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                logs = await (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, "getLogs")({
                  address,
                  args,
                  event,
                  events,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit.onLogs(logs);
            else
              for (const log of logs)
                emit.onLogs([log]);
          } catch (err) {
            if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
              initialized = false;
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribeEvent = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const events_ = events ?? (event ? [event] : undefined);
          let topics = [];
          if (events_) {
            topics = [
              events_.flatMap((event2) => (0, index_js_1.encodeEventTopics)({
                abi: [event2],
                eventName: event2.name,
                args
              }))
            ];
            if (event)
              topics = topics[0];
          }
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName, args: args2 } = (0, index_js_1.decodeEventLog)({
                  abi: events_ ?? [],
                  data: log.data,
                  topics: log.topics,
                  strict
                });
                const formatted = (0, index_js_1.formatLog)(log, { args: args2, eventName });
                onLogs([formatted]);
              } catch (err) {
                let eventName;
                let isUnnamed;
                if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
                }
                const formatted = (0, index_js_1.formatLog)(log, {
                  args: isUnnamed ? [] : {},
                  eventName
                });
                onLogs([formatted]);
              }
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollEvent() : subscribeEvent();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.watchEvent = undefined;
  var observe_js_1 = require_observe();
  var poll_js_1 = require_poll();
  var stringify_js_1 = require_stringify();
  var abi_js_1 = require_abi();
  var rpc_js_1 = require_rpc();
  var getAction_js_1 = require_getAction();
  var index_js_1 = require_utils7();
  var createEventFilter_js_1 = require_createEventFilter();
  var getBlockNumber_js_1 = require_getBlockNumber();
  var getFilterChanges_js_1 = require_getFilterChanges();
  var getLogs_js_1 = require_getLogs();
  var uninstallFilter_js_1 = require_uninstallFilter();
  exports.watchEvent = watchEvent;
});

// node_modules/viem/_cjs/actions/public/watchPendingTransactions.js
var require_watchPendingTransactions = __commonJS((exports) => {
  function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    const pollPendingTransactions = () => {
      const observerId = (0, stringify_js_1.stringify)([
        "watchPendingTransactions",
        client.uid,
        batch,
        pollingInterval
      ]);
      return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
        let filter;
        const unwatch = (0, poll_js_1.poll)(async () => {
          try {
            if (!filter) {
              try {
                filter = await (0, getAction_js_1.getAction)(client, createPendingTransactionFilter_js_1.createPendingTransactionFilter, "createPendingTransactionFilter")({});
                return;
              } catch (err) {
                unwatch();
                throw err;
              }
            }
            const hashes = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
            if (hashes.length === 0)
              return;
            if (batch)
              emit.onTransactions(hashes);
            else
              for (const hash2 of hashes)
                emit.onTransactions([hash2]);
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribePendingTransactions = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newPendingTransactions"],
            onData(data) {
              if (!active)
                return;
              const transaction = data.result;
              onTransactions([transaction]);
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.watchPendingTransactions = undefined;
  var getAction_js_1 = require_getAction();
  var observe_js_1 = require_observe();
  var poll_js_1 = require_poll();
  var stringify_js_1 = require_stringify();
  var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
  var getFilterChanges_js_1 = require_getFilterChanges();
  var uninstallFilter_js_1 = require_uninstallFilter();
  exports.watchPendingTransactions = watchPendingTransactions;
});

// node_modules/viem/_cjs/clients/decorators/public.js
var require_public = __commonJS((exports) => {
  function publicActions(client) {
    return {
      call: (args) => (0, call_js_1.call)(client, args),
      createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
      createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
      createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
      createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
      estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
      estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
      getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
      getBlobBaseFee: () => (0, getBlobBaseFee_js_1.getBlobBaseFee)(client),
      getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
      getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
      getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
      getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client, args),
      getChainId: () => (0, getChainId_js_1.getChainId)(client),
      getContractEvents: (args) => (0, getContractEvents_js_1.getContractEvents)(client, args),
      getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
      getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
      getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
      getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
      getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
      getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
      estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client, args),
      getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
      getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
      getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
      getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
      getProof: (args) => (0, getProof_js_1.getProof)(client, args),
      estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas)(client, args),
      getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
      getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
      getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
      getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
      getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
      multicall: (args) => (0, multicall_js_1.multicall)(client, args),
      prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
      readContract: (args) => (0, readContract_js_1.readContract)(client, args),
      sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
      simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
      verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
      verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
      uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
      waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
      watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
      watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
      watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
      watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
      watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args)
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publicActions = undefined;
  var getEnsAddress_js_1 = require_getEnsAddress();
  var getEnsAvatar_js_1 = require_getEnsAvatar();
  var getEnsName_js_1 = require_getEnsName();
  var getEnsResolver_js_1 = require_getEnsResolver();
  var getEnsText_js_1 = require_getEnsText();
  var call_js_1 = require_call();
  var createBlockFilter_js_1 = require_createBlockFilter();
  var createContractEventFilter_js_1 = require_createContractEventFilter();
  var createEventFilter_js_1 = require_createEventFilter();
  var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
  var estimateContractGas_js_1 = require_estimateContractGas();
  var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
  var estimateGas_js_1 = require_estimateGas2();
  var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
  var getBalance_js_1 = require_getBalance();
  var getBlobBaseFee_js_1 = require_getBlobBaseFee();
  var getBlock_js_1 = require_getBlock();
  var getBlockNumber_js_1 = require_getBlockNumber();
  var getBlockTransactionCount_js_1 = require_getBlockTransactionCount();
  var getBytecode_js_1 = require_getBytecode();
  var getChainId_js_1 = require_getChainId();
  var getContractEvents_js_1 = require_getContractEvents();
  var getFeeHistory_js_1 = require_getFeeHistory();
  var getFilterChanges_js_1 = require_getFilterChanges();
  var getFilterLogs_js_1 = require_getFilterLogs();
  var getGasPrice_js_1 = require_getGasPrice();
  var getLogs_js_1 = require_getLogs();
  var getProof_js_1 = require_getProof();
  var getStorageAt_js_1 = require_getStorageAt();
  var getTransaction_js_1 = require_getTransaction();
  var getTransactionConfirmations_js_1 = require_getTransactionConfirmations();
  var getTransactionCount_js_1 = require_getTransactionCount();
  var getTransactionReceipt_js_1 = require_getTransactionReceipt();
  var multicall_js_1 = require_multicall();
  var readContract_js_1 = require_readContract();
  var simulateContract_js_1 = require_simulateContract();
  var uninstallFilter_js_1 = require_uninstallFilter();
  var verifyMessage_js_1 = require_verifyMessage2();
  var verifyTypedData_js_1 = require_verifyTypedData2();
  var waitForTransactionReceipt_js_1 = require_waitForTransactionReceipt();
  var watchBlockNumber_js_1 = require_watchBlockNumber();
  var watchBlocks_js_1 = require_watchBlocks();
  var watchContractEvent_js_1 = require_watchContractEvent();
  var watchEvent_js_1 = require_watchEvent();
  var watchPendingTransactions_js_1 = require_watchPendingTransactions();
  var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
  var sendRawTransaction_js_1 = require_sendRawTransaction();
  exports.publicActions = publicActions;
});

// node_modules/viem/_cjs/clients/createPublicClient.js
var require_createPublicClient = __commonJS((exports) => {
  function createPublicClient(parameters) {
    const { key = "public", name = "Public Client" } = parameters;
    const client = (0, createClient_js_1.createClient)({
      ...parameters,
      key,
      name,
      type: "publicClient"
    });
    return client.extend(public_js_1.publicActions);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPublicClient = undefined;
  var createClient_js_1 = require_createClient();
  var public_js_1 = require_public();
  exports.createPublicClient = createPublicClient;
});

// node_modules/viem/_cjs/actions/test/dropTransaction.js
var require_dropTransaction = __commonJS((exports) => {
  async function dropTransaction(client, { hash: hash2 }) {
    await client.request({
      method: `${client.mode}_dropTransaction`,
      params: [hash2]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dropTransaction = undefined;
  exports.dropTransaction = dropTransaction;
});

// node_modules/viem/_cjs/actions/test/dumpState.js
var require_dumpState = __commonJS((exports) => {
  async function dumpState(client) {
    return client.request({
      method: `${client.mode}_dumpState`
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dumpState = undefined;
  exports.dumpState = dumpState;
});

// node_modules/viem/_cjs/actions/test/getAutomine.js
var require_getAutomine = __commonJS((exports) => {
  async function getAutomine(client) {
    if (client.mode === "ganache")
      return await client.request({
        method: "eth_mining"
      });
    return await client.request({
      method: `${client.mode}_getAutomine`
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAutomine = undefined;
  exports.getAutomine = getAutomine;
});

// node_modules/viem/_cjs/actions/test/getTxpoolContent.js
var require_getTxpoolContent = __commonJS((exports) => {
  async function getTxpoolContent(client) {
    return await client.request({
      method: "txpool_content"
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTxpoolContent = undefined;
  exports.getTxpoolContent = getTxpoolContent;
});

// node_modules/viem/_cjs/actions/test/getTxpoolStatus.js
var require_getTxpoolStatus = __commonJS((exports) => {
  async function getTxpoolStatus(client) {
    const { pending, queued } = await client.request({
      method: "txpool_status"
    });
    return {
      pending: (0, fromHex_js_1.hexToNumber)(pending),
      queued: (0, fromHex_js_1.hexToNumber)(queued)
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTxpoolStatus = undefined;
  var fromHex_js_1 = require_fromHex();
  exports.getTxpoolStatus = getTxpoolStatus;
});

// node_modules/viem/_cjs/actions/test/impersonateAccount.js
var require_impersonateAccount = __commonJS((exports) => {
  async function impersonateAccount(client, { address }) {
    await client.request({
      method: `${client.mode}_impersonateAccount`,
      params: [address]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.impersonateAccount = undefined;
  exports.impersonateAccount = impersonateAccount;
});

// node_modules/viem/_cjs/actions/test/increaseTime.js
var require_increaseTime = __commonJS((exports) => {
  async function increaseTime(client, { seconds }) {
    return await client.request({
      method: "evm_increaseTime",
      params: [(0, toHex_js_1.numberToHex)(seconds)]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.increaseTime = undefined;
  var toHex_js_1 = require_toHex();
  exports.increaseTime = increaseTime;
});

// node_modules/viem/_cjs/actions/test/inspectTxpool.js
var require_inspectTxpool = __commonJS((exports) => {
  async function inspectTxpool(client) {
    return await client.request({
      method: "txpool_inspect"
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.inspectTxpool = undefined;
  exports.inspectTxpool = inspectTxpool;
});

// node_modules/viem/_cjs/actions/test/loadState.js
var require_loadState = __commonJS((exports) => {
  async function loadState(client, { state }) {
    await client.request({
      method: `${client.mode}_loadState`,
      params: [state]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadState = undefined;
  exports.loadState = loadState;
});

// node_modules/viem/_cjs/actions/test/mine.js
var require_mine = __commonJS((exports) => {
  async function mine(client, { blocks, interval }) {
    if (client.mode === "ganache")
      await client.request({
        method: "evm_mine",
        params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }]
      });
    else
      await client.request({
        method: `${client.mode}_mine`,
        params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)]
      });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mine = undefined;
  var toHex_js_1 = require_toHex();
  exports.mine = mine;
});

// node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js
var require_removeBlockTimestampInterval = __commonJS((exports) => {
  async function removeBlockTimestampInterval(client) {
    await client.request({
      method: `${client.mode}_removeBlockTimestampInterval`
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.removeBlockTimestampInterval = undefined;
  exports.removeBlockTimestampInterval = removeBlockTimestampInterval;
});

// node_modules/viem/_cjs/actions/test/reset.js
var require_reset = __commonJS((exports) => {
  async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
    await client.request({
      method: `${client.mode}_reset`,
      params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reset = undefined;
  exports.reset = reset;
});

// node_modules/viem/_cjs/actions/test/revert.js
var require_revert = __commonJS((exports) => {
  async function revert(client, { id }) {
    await client.request({
      method: "evm_revert",
      params: [id]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.revert = undefined;
  exports.revert = revert;
});

// node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js
var require_sendUnsignedTransaction = __commonJS((exports) => {
  async function sendUnsignedTransaction(client, args) {
    const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
    const request = format({
      ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
      accessList,
      data,
      from,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const hash2 = await client.request({
      method: "eth_sendUnsignedTransaction",
      params: [request]
    });
    return hash2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sendUnsignedTransaction = undefined;
  var extract_js_1 = require_extract();
  var transactionRequest_js_1 = require_transactionRequest();
  exports.sendUnsignedTransaction = sendUnsignedTransaction;
});

// node_modules/viem/_cjs/actions/test/setAutomine.js
var require_setAutomine = __commonJS((exports) => {
  async function setAutomine(client, enabled) {
    if (client.mode === "ganache") {
      if (enabled)
        await client.request({ method: "miner_start" });
      else
        await client.request({ method: "miner_stop" });
    } else
      await client.request({
        method: "evm_setAutomine",
        params: [enabled]
      });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setAutomine = undefined;
  exports.setAutomine = setAutomine;
});

// node_modules/viem/_cjs/actions/test/setBalance.js
var require_setBalance = __commonJS((exports) => {
  async function setBalance(client, { address, value }) {
    if (client.mode === "ganache")
      await client.request({
        method: "evm_setAccountBalance",
        params: [address, (0, toHex_js_1.numberToHex)(value)]
      });
    else
      await client.request({
        method: `${client.mode}_setBalance`,
        params: [address, (0, toHex_js_1.numberToHex)(value)]
      });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setBalance = undefined;
  var toHex_js_1 = require_toHex();
  exports.setBalance = setBalance;
});

// node_modules/viem/_cjs/actions/test/setBlockGasLimit.js
var require_setBlockGasLimit = __commonJS((exports) => {
  async function setBlockGasLimit(client, { gasLimit }) {
    await client.request({
      method: "evm_setBlockGasLimit",
      params: [(0, toHex_js_1.numberToHex)(gasLimit)]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setBlockGasLimit = undefined;
  var toHex_js_1 = require_toHex();
  exports.setBlockGasLimit = setBlockGasLimit;
});

// node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js
var require_setBlockTimestampInterval = __commonJS((exports) => {
  async function setBlockTimestampInterval(client, { interval }) {
    const interval_ = (() => {
      if (client.mode === "hardhat")
        return interval * 1000;
      return interval;
    })();
    await client.request({
      method: `${client.mode}_setBlockTimestampInterval`,
      params: [interval_]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setBlockTimestampInterval = undefined;
  exports.setBlockTimestampInterval = setBlockTimestampInterval;
});

// node_modules/viem/_cjs/actions/test/setCode.js
var require_setCode = __commonJS((exports) => {
  async function setCode(client, { address, bytecode }) {
    await client.request({
      method: `${client.mode}_setCode`,
      params: [address, bytecode]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setCode = undefined;
  exports.setCode = setCode;
});

// node_modules/viem/_cjs/actions/test/setCoinbase.js
var require_setCoinbase = __commonJS((exports) => {
  async function setCoinbase(client, { address }) {
    await client.request({
      method: `${client.mode}_setCoinbase`,
      params: [address]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setCoinbase = undefined;
  exports.setCoinbase = setCoinbase;
});

// node_modules/viem/_cjs/actions/test/setIntervalMining.js
var require_setIntervalMining = __commonJS((exports) => {
  async function setIntervalMining(client, { interval }) {
    const interval_ = (() => {
      if (client.mode === "hardhat")
        return interval * 1000;
      return interval;
    })();
    await client.request({
      method: "evm_setIntervalMining",
      params: [interval_]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setIntervalMining = undefined;
  exports.setIntervalMining = setIntervalMining;
});

// node_modules/viem/_cjs/actions/test/setLoggingEnabled.js
var require_setLoggingEnabled = __commonJS((exports) => {
  async function setLoggingEnabled(client, enabled) {
    await client.request({
      method: `${client.mode}_setLoggingEnabled`,
      params: [enabled]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setLoggingEnabled = undefined;
  exports.setLoggingEnabled = setLoggingEnabled;
});

// node_modules/viem/_cjs/actions/test/setMinGasPrice.js
var require_setMinGasPrice = __commonJS((exports) => {
  async function setMinGasPrice(client, { gasPrice }) {
    await client.request({
      method: `${client.mode}_setMinGasPrice`,
      params: [(0, toHex_js_1.numberToHex)(gasPrice)]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setMinGasPrice = undefined;
  var toHex_js_1 = require_toHex();
  exports.setMinGasPrice = setMinGasPrice;
});

// node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js
var require_setNextBlockBaseFeePerGas = __commonJS((exports) => {
  async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
    await client.request({
      method: `${client.mode}_setNextBlockBaseFeePerGas`,
      params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setNextBlockBaseFeePerGas = undefined;
  var toHex_js_1 = require_toHex();
  exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
});

// node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js
var require_setNextBlockTimestamp = __commonJS((exports) => {
  async function setNextBlockTimestamp(client, { timestamp }) {
    await client.request({
      method: "evm_setNextBlockTimestamp",
      params: [(0, toHex_js_1.numberToHex)(timestamp)]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setNextBlockTimestamp = undefined;
  var toHex_js_1 = require_toHex();
  exports.setNextBlockTimestamp = setNextBlockTimestamp;
});

// node_modules/viem/_cjs/actions/test/setNonce.js
var require_setNonce = __commonJS((exports) => {
  async function setNonce(client, { address, nonce }) {
    await client.request({
      method: `${client.mode}_setNonce`,
      params: [address, (0, toHex_js_1.numberToHex)(nonce)]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setNonce = undefined;
  var toHex_js_1 = require_toHex();
  exports.setNonce = setNonce;
});

// node_modules/viem/_cjs/actions/test/setRpcUrl.js
var require_setRpcUrl = __commonJS((exports) => {
  async function setRpcUrl(client, jsonRpcUrl) {
    await client.request({
      method: `${client.mode}_setRpcUrl`,
      params: [jsonRpcUrl]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setRpcUrl = undefined;
  exports.setRpcUrl = setRpcUrl;
});

// node_modules/viem/_cjs/actions/test/setStorageAt.js
var require_setStorageAt = __commonJS((exports) => {
  async function setStorageAt(client, { address, index, value }) {
    await client.request({
      method: `${client.mode}_setStorageAt`,
      params: [
        address,
        typeof index === "number" ? (0, toHex_js_1.numberToHex)(index) : index,
        value
      ]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setStorageAt = undefined;
  var toHex_js_1 = require_toHex();
  exports.setStorageAt = setStorageAt;
});

// node_modules/viem/_cjs/actions/test/snapshot.js
var require_snapshot = __commonJS((exports) => {
  async function snapshot(client) {
    return await client.request({
      method: "evm_snapshot"
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.snapshot = undefined;
  exports.snapshot = snapshot;
});

// node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js
var require_stopImpersonatingAccount = __commonJS((exports) => {
  async function stopImpersonatingAccount(client, { address }) {
    await client.request({
      method: `${client.mode}_stopImpersonatingAccount`,
      params: [address]
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stopImpersonatingAccount = undefined;
  exports.stopImpersonatingAccount = stopImpersonatingAccount;
});

// node_modules/viem/_cjs/clients/decorators/test.js
var require_test = __commonJS((exports) => {
  function testActions({ mode }) {
    return (client_) => {
      const client = client_.extend(() => ({
        mode
      }));
      return {
        dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
        dumpState: () => (0, dumpState_js_1.dumpState)(client),
        getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
        getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
        getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
        impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
        increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
        inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
        loadState: (args) => (0, loadState_js_1.loadState)(client, args),
        mine: (args) => (0, mine_js_1.mine)(client, args),
        removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
        reset: (args) => (0, reset_js_1.reset)(client, args),
        revert: (args) => (0, revert_js_1.revert)(client, args),
        sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
        setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
        setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
        setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
        setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
        setCode: (args) => (0, setCode_js_1.setCode)(client, args),
        setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
        setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
        setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
        setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
        setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
        setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
        setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
        setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
        setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
        snapshot: () => (0, snapshot_js_1.snapshot)(client),
        stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args)
      };
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.testActions = undefined;
  var dropTransaction_js_1 = require_dropTransaction();
  var dumpState_js_1 = require_dumpState();
  var getAutomine_js_1 = require_getAutomine();
  var getTxpoolContent_js_1 = require_getTxpoolContent();
  var getTxpoolStatus_js_1 = require_getTxpoolStatus();
  var impersonateAccount_js_1 = require_impersonateAccount();
  var increaseTime_js_1 = require_increaseTime();
  var inspectTxpool_js_1 = require_inspectTxpool();
  var loadState_js_1 = require_loadState();
  var mine_js_1 = require_mine();
  var removeBlockTimestampInterval_js_1 = require_removeBlockTimestampInterval();
  var reset_js_1 = require_reset();
  var revert_js_1 = require_revert();
  var sendUnsignedTransaction_js_1 = require_sendUnsignedTransaction();
  var setAutomine_js_1 = require_setAutomine();
  var setBalance_js_1 = require_setBalance();
  var setBlockGasLimit_js_1 = require_setBlockGasLimit();
  var setBlockTimestampInterval_js_1 = require_setBlockTimestampInterval();
  var setCode_js_1 = require_setCode();
  var setCoinbase_js_1 = require_setCoinbase();
  var setIntervalMining_js_1 = require_setIntervalMining();
  var setLoggingEnabled_js_1 = require_setLoggingEnabled();
  var setMinGasPrice_js_1 = require_setMinGasPrice();
  var setNextBlockBaseFeePerGas_js_1 = require_setNextBlockBaseFeePerGas();
  var setNextBlockTimestamp_js_1 = require_setNextBlockTimestamp();
  var setNonce_js_1 = require_setNonce();
  var setRpcUrl_js_1 = require_setRpcUrl();
  var setStorageAt_js_1 = require_setStorageAt();
  var snapshot_js_1 = require_snapshot();
  var stopImpersonatingAccount_js_1 = require_stopImpersonatingAccount();
  exports.testActions = testActions;
});

// node_modules/viem/_cjs/clients/createTestClient.js
var require_createTestClient = __commonJS((exports) => {
  function createTestClient(parameters) {
    const { key = "test", name = "Test Client", mode } = parameters;
    const client = (0, createClient_js_1.createClient)({
      ...parameters,
      key,
      name,
      type: "testClient"
    });
    return client.extend((config) => ({
      mode,
      ...(0, test_js_1.testActions)({ mode })(config)
    }));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTestClient = undefined;
  var createClient_js_1 = require_createClient();
  var test_js_1 = require_test();
  exports.createTestClient = createTestClient;
});

// node_modules/viem/_cjs/actions/wallet/addChain.js
var require_addChain = __commonJS((exports) => {
  async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: (0, toHex_js_1.numberToHex)(id),
          chainName: name,
          nativeCurrency,
          rpcUrls: rpcUrls.default.http,
          blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : undefined
        }
      ]
    }, { retryCount: 0 });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addChain = undefined;
  var toHex_js_1 = require_toHex();
  exports.addChain = addChain;
});

// node_modules/viem/_cjs/actions/wallet/deployContract.js
var require_deployContract = __commonJS((exports) => {
  function deployContract(walletClient, parameters) {
    const { abi, args, bytecode, ...request } = parameters;
    const calldata = (0, encodeDeployData_js_1.encodeDeployData)({ abi, args, bytecode });
    return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
      ...request,
      data: calldata
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deployContract = undefined;
  var encodeDeployData_js_1 = require_encodeDeployData();
  var sendTransaction_js_1 = require_sendTransaction();
  exports.deployContract = deployContract;
});

// node_modules/viem/_cjs/actions/wallet/getAddresses.js
var require_getAddresses = __commonJS((exports) => {
  async function getAddresses(client) {
    if (client.account?.type === "local")
      return [client.account.address];
    const addresses = await client.request({ method: "eth_accounts" });
    return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAddresses = undefined;
  var getAddress_js_1 = require_getAddress();
  exports.getAddresses = getAddresses;
});

// node_modules/viem/_cjs/actions/wallet/getPermissions.js
var require_getPermissions = __commonJS((exports) => {
  async function getPermissions(client) {
    const permissions = await client.request({ method: "wallet_getPermissions" });
    return permissions;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPermissions = undefined;
  exports.getPermissions = getPermissions;
});

// node_modules/viem/_cjs/actions/wallet/requestAddresses.js
var require_requestAddresses = __commonJS((exports) => {
  async function requestAddresses(client) {
    const addresses = await client.request({ method: "eth_requestAccounts" }, { retryCount: 0 });
    return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestAddresses = undefined;
  var getAddress_js_1 = require_getAddress();
  exports.requestAddresses = requestAddresses;
});

// node_modules/viem/_cjs/actions/wallet/requestPermissions.js
var require_requestPermissions = __commonJS((exports) => {
  async function requestPermissions(client, permissions) {
    return client.request({
      method: "wallet_requestPermissions",
      params: [permissions]
    }, { retryCount: 0 });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestPermissions = undefined;
  exports.requestPermissions = requestPermissions;
});

// node_modules/viem/_cjs/actions/wallet/signMessage.js
var require_signMessage = __commonJS((exports) => {
  async function signMessage(client, { account: account_ = client.account, message }) {
    if (!account_)
      throw new account_js_1.AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signMessage"
      });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    if (account.type === "local")
      return account.signMessage({ message });
    const message_ = (() => {
      if (typeof message === "string")
        return (0, toHex_js_1.stringToHex)(message);
      if (message.raw instanceof Uint8Array)
        return (0, toHex_js_1.toHex)(message.raw);
      return message.raw;
    })();
    return client.request({
      method: "personal_sign",
      params: [message_, account.address]
    }, { retryCount: 0 });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signMessage = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var account_js_1 = require_account();
  var toHex_js_1 = require_toHex();
  exports.signMessage = signMessage;
});

// node_modules/viem/_cjs/actions/wallet/signTransaction.js
var require_signTransaction = __commonJS((exports) => {
  async function signTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
    if (!account_)
      throw new account_js_1.AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTransaction"
      });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    (0, assertRequest_js_1.assertRequest)({
      account,
      ...parameters
    });
    const chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
    if (chain !== null)
      (0, assertCurrentChain_js_1.assertCurrentChain)({
        currentChainId: chainId,
        chain
      });
    const formatters = chain?.formatters || client.chain?.formatters;
    const format = formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
    if (account.type === "local") {
      return account.signTransaction({
        ...transaction,
        chainId
      }, { serializer: client.chain?.serializers?.transaction });
    }
    return await client.request({
      method: "eth_signTransaction",
      params: [
        {
          ...format(transaction),
          chainId: (0, toHex_js_1.numberToHex)(chainId),
          from: account.address
        }
      ]
    }, { retryCount: 0 });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signTransaction = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var account_js_1 = require_account();
  var assertCurrentChain_js_1 = require_assertCurrentChain();
  var toHex_js_1 = require_toHex();
  var transactionRequest_js_1 = require_transactionRequest();
  var getAction_js_1 = require_getAction();
  var assertRequest_js_1 = require_assertRequest();
  var getChainId_js_1 = require_getChainId();
  exports.signTransaction = signTransaction;
});

// node_modules/viem/_cjs/actions/wallet/signTypedData.js
var require_signTypedData = __commonJS((exports) => {
  async function signTypedData(client, parameters) {
    const { account: account_ = client.account, domain, message, primaryType } = parameters;
    if (!account_)
      throw new account_js_1.AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTypedData"
      });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    const types = {
      EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
      ...parameters.types
    };
    (0, typedData_js_1.validateTypedData)({ domain, message, primaryType, types });
    if (account.type === "local")
      return account.signTypedData({ domain, message, primaryType, types });
    const typedData = (0, stringify_js_1.stringify)({ domain: domain ?? {}, message, primaryType, types }, (_, value) => (0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value);
    return client.request({
      method: "eth_signTypedData_v4",
      params: [account.address, typedData]
    }, { retryCount: 0 });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signTypedData = undefined;
  var parseAccount_js_1 = require_parseAccount();
  var account_js_1 = require_account();
  var isHex_js_1 = require_isHex();
  var stringify_js_1 = require_stringify();
  var typedData_js_1 = require_typedData();
  exports.signTypedData = signTypedData;
});

// node_modules/viem/_cjs/actions/wallet/switchChain.js
var require_switchChain = __commonJS((exports) => {
  async function switchChain(client, { id }) {
    await client.request({
      method: "wallet_switchEthereumChain",
      params: [
        {
          chainId: (0, toHex_js_1.numberToHex)(id)
        }
      ]
    }, { retryCount: 0 });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchChain = undefined;
  var toHex_js_1 = require_toHex();
  exports.switchChain = switchChain;
});

// node_modules/viem/_cjs/actions/wallet/watchAsset.js
var require_watchAsset = __commonJS((exports) => {
  async function watchAsset(client, params) {
    const added = await client.request({
      method: "wallet_watchAsset",
      params
    }, { retryCount: 0 });
    return added;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.watchAsset = undefined;
  exports.watchAsset = watchAsset;
});

// node_modules/viem/_cjs/clients/decorators/wallet.js
var require_wallet = __commonJS((exports) => {
  function walletActions(client) {
    return {
      addChain: (args) => (0, addChain_js_1.addChain)(client, args),
      deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
      getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
      getChainId: () => (0, getChainId_js_1.getChainId)(client),
      getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
      prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
      requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
      requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
      sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
      sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
      signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
      signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client, args),
      signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
      switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
      watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
      writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args)
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.walletActions = undefined;
  var getChainId_js_1 = require_getChainId();
  var addChain_js_1 = require_addChain();
  var deployContract_js_1 = require_deployContract();
  var getAddresses_js_1 = require_getAddresses();
  var getPermissions_js_1 = require_getPermissions();
  var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
  var requestAddresses_js_1 = require_requestAddresses();
  var requestPermissions_js_1 = require_requestPermissions();
  var sendRawTransaction_js_1 = require_sendRawTransaction();
  var sendTransaction_js_1 = require_sendTransaction();
  var signMessage_js_1 = require_signMessage();
  var signTransaction_js_1 = require_signTransaction();
  var signTypedData_js_1 = require_signTypedData();
  var switchChain_js_1 = require_switchChain();
  var watchAsset_js_1 = require_watchAsset();
  var writeContract_js_1 = require_writeContract();
  exports.walletActions = walletActions;
});

// node_modules/viem/_cjs/clients/createWalletClient.js
var require_createWalletClient = __commonJS((exports) => {
  function createWalletClient(parameters) {
    const { key = "wallet", name = "Wallet Client", transport } = parameters;
    const client = (0, createClient_js_1.createClient)({
      ...parameters,
      key,
      name,
      transport,
      type: "walletClient"
    });
    return client.extend(wallet_js_1.walletActions);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createWalletClient = undefined;
  var createClient_js_1 = require_createClient();
  var wallet_js_1 = require_wallet();
  exports.createWalletClient = createWalletClient;
});

// node_modules/viem/_cjs/clients/transports/webSocket.js
var require_webSocket2 = __commonJS((exports) => {
  function webSocket(url, config = {}) {
    const { key = "webSocket", name = "WebSocket JSON-RPC", reconnect, retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const retryCount = config.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
      if (!url_)
        throw new transport_js_1.UrlRequiredError;
      return (0, createTransport_js_1.createTransport)({
        key,
        name,
        async request({ method, params }) {
          const body = { method, params };
          const rpcClient = await (0, webSocket_js_1.getWebSocketRpcClient)(url_, { reconnect });
          const { error, result } = await rpcClient.requestAsync({
            body,
            timeout
          });
          if (error)
            throw new request_js_1.RpcRequestError({
              body,
              error,
              url: url_
            });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "webSocket"
      }, {
        getSocket() {
          return (0, compat_js_1.getSocket)(url_);
        },
        getRpcClient() {
          return (0, webSocket_js_1.getWebSocketRpcClient)(url_);
        },
        async subscribe({ params, onData, onError }) {
          const rpcClient = await (0, webSocket_js_1.getWebSocketRpcClient)(url_);
          const { result: subscriptionId } = await new Promise((resolve, reject) => rpcClient.request({
            body: {
              method: "eth_subscribe",
              params
            },
            onResponse(response) {
              if (response.error) {
                reject(response.error);
                onError?.(response.error);
                return;
              }
              if (typeof response.id === "number") {
                resolve(response);
                return;
              }
              if (response.method !== "eth_subscription")
                return;
              onData(response.params);
            }
          }));
          return {
            subscriptionId,
            async unsubscribe() {
              return new Promise((resolve) => rpcClient.request({
                body: {
                  method: "eth_unsubscribe",
                  params: [subscriptionId]
                },
                onResponse: resolve
              }));
            }
          };
        }
      });
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.webSocket = undefined;
  var request_js_1 = require_request();
  var transport_js_1 = require_transport();
  var compat_js_1 = require_compat();
  var webSocket_js_1 = require_webSocket();
  var createTransport_js_1 = require_createTransport();
  exports.webSocket = webSocket;
});

// node_modules/viem/_cjs/constants/address.js
var require_address2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zeroAddress = undefined;
  exports.zeroAddress = "0x0000000000000000000000000000000000000000";
});

// node_modules/viem/_cjs/constants/number.js
var require_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = undefined;
  exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = undefined;
  exports.maxInt8 = 2n ** (8n - 1n) - 1n;
  exports.maxInt16 = 2n ** (16n - 1n) - 1n;
  exports.maxInt24 = 2n ** (24n - 1n) - 1n;
  exports.maxInt32 = 2n ** (32n - 1n) - 1n;
  exports.maxInt40 = 2n ** (40n - 1n) - 1n;
  exports.maxInt48 = 2n ** (48n - 1n) - 1n;
  exports.maxInt56 = 2n ** (56n - 1n) - 1n;
  exports.maxInt64 = 2n ** (64n - 1n) - 1n;
  exports.maxInt72 = 2n ** (72n - 1n) - 1n;
  exports.maxInt80 = 2n ** (80n - 1n) - 1n;
  exports.maxInt88 = 2n ** (88n - 1n) - 1n;
  exports.maxInt96 = 2n ** (96n - 1n) - 1n;
  exports.maxInt104 = 2n ** (104n - 1n) - 1n;
  exports.maxInt112 = 2n ** (112n - 1n) - 1n;
  exports.maxInt120 = 2n ** (120n - 1n) - 1n;
  exports.maxInt128 = 2n ** (128n - 1n) - 1n;
  exports.maxInt136 = 2n ** (136n - 1n) - 1n;
  exports.maxInt144 = 2n ** (144n - 1n) - 1n;
  exports.maxInt152 = 2n ** (152n - 1n) - 1n;
  exports.maxInt160 = 2n ** (160n - 1n) - 1n;
  exports.maxInt168 = 2n ** (168n - 1n) - 1n;
  exports.maxInt176 = 2n ** (176n - 1n) - 1n;
  exports.maxInt184 = 2n ** (184n - 1n) - 1n;
  exports.maxInt192 = 2n ** (192n - 1n) - 1n;
  exports.maxInt200 = 2n ** (200n - 1n) - 1n;
  exports.maxInt208 = 2n ** (208n - 1n) - 1n;
  exports.maxInt216 = 2n ** (216n - 1n) - 1n;
  exports.maxInt224 = 2n ** (224n - 1n) - 1n;
  exports.maxInt232 = 2n ** (232n - 1n) - 1n;
  exports.maxInt240 = 2n ** (240n - 1n) - 1n;
  exports.maxInt248 = 2n ** (248n - 1n) - 1n;
  exports.maxInt256 = 2n ** (256n - 1n) - 1n;
  exports.minInt8 = -(2n ** (8n - 1n));
  exports.minInt16 = -(2n ** (16n - 1n));
  exports.minInt24 = -(2n ** (24n - 1n));
  exports.minInt32 = -(2n ** (32n - 1n));
  exports.minInt40 = -(2n ** (40n - 1n));
  exports.minInt48 = -(2n ** (48n - 1n));
  exports.minInt56 = -(2n ** (56n - 1n));
  exports.minInt64 = -(2n ** (64n - 1n));
  exports.minInt72 = -(2n ** (72n - 1n));
  exports.minInt80 = -(2n ** (80n - 1n));
  exports.minInt88 = -(2n ** (88n - 1n));
  exports.minInt96 = -(2n ** (96n - 1n));
  exports.minInt104 = -(2n ** (104n - 1n));
  exports.minInt112 = -(2n ** (112n - 1n));
  exports.minInt120 = -(2n ** (120n - 1n));
  exports.minInt128 = -(2n ** (128n - 1n));
  exports.minInt136 = -(2n ** (136n - 1n));
  exports.minInt144 = -(2n ** (144n - 1n));
  exports.minInt152 = -(2n ** (152n - 1n));
  exports.minInt160 = -(2n ** (160n - 1n));
  exports.minInt168 = -(2n ** (168n - 1n));
  exports.minInt176 = -(2n ** (176n - 1n));
  exports.minInt184 = -(2n ** (184n - 1n));
  exports.minInt192 = -(2n ** (192n - 1n));
  exports.minInt200 = -(2n ** (200n - 1n));
  exports.minInt208 = -(2n ** (208n - 1n));
  exports.minInt216 = -(2n ** (216n - 1n));
  exports.minInt224 = -(2n ** (224n - 1n));
  exports.minInt232 = -(2n ** (232n - 1n));
  exports.minInt240 = -(2n ** (240n - 1n));
  exports.minInt248 = -(2n ** (248n - 1n));
  exports.minInt256 = -(2n ** (256n - 1n));
  exports.maxUint8 = 2n ** 8n - 1n;
  exports.maxUint16 = 2n ** 16n - 1n;
  exports.maxUint24 = 2n ** 24n - 1n;
  exports.maxUint32 = 2n ** 32n - 1n;
  exports.maxUint40 = 2n ** 40n - 1n;
  exports.maxUint48 = 2n ** 48n - 1n;
  exports.maxUint56 = 2n ** 56n - 1n;
  exports.maxUint64 = 2n ** 64n - 1n;
  exports.maxUint72 = 2n ** 72n - 1n;
  exports.maxUint80 = 2n ** 80n - 1n;
  exports.maxUint88 = 2n ** 88n - 1n;
  exports.maxUint96 = 2n ** 96n - 1n;
  exports.maxUint104 = 2n ** 104n - 1n;
  exports.maxUint112 = 2n ** 112n - 1n;
  exports.maxUint120 = 2n ** 120n - 1n;
  exports.maxUint128 = 2n ** 128n - 1n;
  exports.maxUint136 = 2n ** 136n - 1n;
  exports.maxUint144 = 2n ** 144n - 1n;
  exports.maxUint152 = 2n ** 152n - 1n;
  exports.maxUint160 = 2n ** 160n - 1n;
  exports.maxUint168 = 2n ** 168n - 1n;
  exports.maxUint176 = 2n ** 176n - 1n;
  exports.maxUint184 = 2n ** 184n - 1n;
  exports.maxUint192 = 2n ** 192n - 1n;
  exports.maxUint200 = 2n ** 200n - 1n;
  exports.maxUint208 = 2n ** 208n - 1n;
  exports.maxUint216 = 2n ** 216n - 1n;
  exports.maxUint224 = 2n ** 224n - 1n;
  exports.maxUint232 = 2n ** 232n - 1n;
  exports.maxUint240 = 2n ** 240n - 1n;
  exports.maxUint248 = 2n ** 248n - 1n;
  exports.maxUint256 = 2n ** 256n - 1n;
});

// node_modules/viem/_cjs/constants/bytes.js
var require_bytes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zeroHash = undefined;
  exports.zeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
});

// node_modules/viem/_cjs/utils/abi/decodeDeployData.js
var require_decodeDeployData = __commonJS((exports) => {
  function decodeDeployData(parameters) {
    const { abi, bytecode, data } = parameters;
    if (data === bytecode)
      return { bytecode };
    const description = abi.find((x) => ("type" in x) && x.type === "constructor");
    if (!description)
      throw new abi_js_1.AbiConstructorNotFoundError({ docsPath: docsPath5 });
    if (!("inputs" in description))
      throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    if (!description.inputs || description.inputs.length === 0)
      throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, "")}`);
    return { args, bytecode };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeDeployData = undefined;
  var abi_js_1 = require_abi();
  var decodeAbiParameters_js_1 = require_decodeAbiParameters();
  var docsPath5 = "/docs/contract/decodeDeployData";
  exports.decodeDeployData = decodeDeployData;
});

// node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js
var require_compactSignatureToSignature = __commonJS((exports) => {
  function compactSignatureToSignature({ r, yParityAndS }) {
    const yParityAndS_bytes = (0, toBytes_js_1.hexToBytes)(yParityAndS);
    const yParity = yParityAndS_bytes[0] & 128 ? 1 : 0;
    const s = yParityAndS_bytes;
    if (yParity === 1)
      s[0] &= 127;
    return { r, s: (0, toHex_js_1.bytesToHex)(s), yParity };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compactSignatureToSignature = undefined;
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.compactSignatureToSignature = compactSignatureToSignature;
});

// node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js
var require_hexToCompactSignature = __commonJS((exports) => {
  function hexToCompactSignature(signatureHex) {
    const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    return {
      r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
      yParityAndS: (0, toHex_js_1.numberToHex)(s, { size: 32 })
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToCompactSignature = undefined;
  var secp256k1_1 = require_secp256k1();
  var toHex_js_1 = require_toHex();
  exports.hexToCompactSignature = hexToCompactSignature;
});

// node_modules/viem/_cjs/utils/signature/hexToSignature.js
var require_hexToSignature = __commonJS((exports) => {
  function hexToSignature(signatureHex) {
    const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    const v = BigInt(`0x${signatureHex.slice(130)}`);
    return {
      r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
      s: (0, toHex_js_1.numberToHex)(s, { size: 32 }),
      v,
      yParity: v === 28n ? 1 : 0
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToSignature = undefined;
  var secp256k1_1 = require_secp256k1();
  var toHex_js_1 = require_toHex();
  exports.hexToSignature = hexToSignature;
});

// node_modules/viem/_cjs/utils/signature/signatureToHex.js
var require_signatureToHex = __commonJS((exports) => {
  function signatureToHex({ r, s, v, yParity }) {
    const vHex = (() => {
      if (v === 27n || yParity === 0)
        return "1b";
      if (v === 28n || yParity === 1)
        return "1c";
      throw new Error("Invalid v value");
    })();
    return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s)).toCompactHex()}${vHex}`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signatureToHex = undefined;
  var secp256k1_1 = require_secp256k1();
  var fromHex_js_1 = require_fromHex();
  exports.signatureToHex = signatureToHex;
});

// node_modules/viem/_cjs/utils/signature/recoverTransactionAddress.js
var require_recoverTransactionAddress = __commonJS((exports) => {
  async function recoverTransactionAddress(parameters) {
    const { serializedTransaction, signature: signature_ } = parameters;
    const transaction = (0, parseTransaction_js_1.parseTransaction)(serializedTransaction);
    const signature = signature_ ?? (0, signatureToHex_js_1.signatureToHex)({
      r: transaction.r,
      s: transaction.s,
      v: transaction.v,
      yParity: transaction.yParity
    });
    const serialized = (0, serializeTransaction_js_1.serializeTransaction)({
      ...transaction,
      r: undefined,
      s: undefined,
      v: undefined,
      yParity: undefined
    });
    return await (0, recoverAddress_js_1.recoverAddress)({
      hash: (0, keccak256_js_1.keccak256)(serialized),
      signature
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recoverTransactionAddress = undefined;
  var keccak256_js_1 = require_keccak256();
  var parseTransaction_js_1 = require_parseTransaction();
  var serializeTransaction_js_1 = require_serializeTransaction();
  var recoverAddress_js_1 = require_recoverAddress();
  var signatureToHex_js_1 = require_signatureToHex();
  exports.recoverTransactionAddress = recoverTransactionAddress;
});

// node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js
var require_signatureToCompactSignature = __commonJS((exports) => {
  function signatureToCompactSignature(signature) {
    const { r, s, v, yParity } = signature;
    const yParity_ = Number(yParity ?? v - 27n);
    let yParityAndS = s;
    if (yParity_ === 1) {
      const bytes2 = (0, index_js_1.hexToBytes)(s);
      bytes2[0] |= 128;
      yParityAndS = (0, index_js_1.bytesToHex)(bytes2);
    }
    return { r, yParityAndS };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signatureToCompactSignature = undefined;
  var index_js_1 = require_utils7();
  exports.signatureToCompactSignature = signatureToCompactSignature;
});

// node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js
var require_compactSignatureToHex = __commonJS((exports) => {
  function compactSignatureToHex({ r, yParityAndS }) {
    return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(yParityAndS)).toCompactHex()}`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compactSignatureToHex = undefined;
  var secp256k1_1 = require_secp256k1();
  var fromHex_js_1 = require_fromHex();
  exports.compactSignatureToHex = compactSignatureToHex;
});

// node_modules/viem/_cjs/utils/blob/sidecarsToVersionedHashes.js
var require_sidecarsToVersionedHashes = __commonJS((exports) => {
  function sidecarsToVersionedHashes(parameters) {
    const { sidecars, version: version2 } = parameters;
    const to = parameters.to ?? (typeof sidecars[0].blob === "string" ? "hex" : "bytes");
    const hashes = [];
    for (const { commitment } of sidecars) {
      hashes.push((0, commitmentToVersionedHash_js_1.commitmentToVersionedHash)({
        commitment,
        to,
        version: version2
      }));
    }
    return hashes;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sidecarsToVersionedHashes = undefined;
  var commitmentToVersionedHash_js_1 = require_commitmentToVersionedHash();
  exports.sidecarsToVersionedHashes = sidecarsToVersionedHashes;
});

// node_modules/viem/_cjs/utils/blob/fromBlobs.js
var require_fromBlobs = __commonJS((exports) => {
  function fromBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => (0, toBytes_js_1.hexToBytes)(x)) : parameters.blobs;
    const length = blobs.reduce((length2, blob) => length2 + blob.length, 0);
    const data = (0, cursor_js_1.createCursor)(new Uint8Array(length));
    let active = true;
    for (const blob of blobs) {
      const cursor = (0, cursor_js_1.createCursor)(blob);
      while (active && cursor.position < blob.length) {
        cursor.incrementPosition(1);
        let consume = 31;
        if (blob.length - cursor.position < 31)
          consume = blob.length - cursor.position;
        for (const _ in Array.from({ length: consume })) {
          const byte = cursor.readByte();
          const isTerminator = byte === 128 && !cursor.inspectBytes(cursor.remaining).includes(128);
          if (isTerminator) {
            active = false;
            break;
          }
          data.pushByte(byte);
        }
      }
    }
    const trimmedData = data.bytes.slice(0, data.position);
    return to === "hex" ? (0, toHex_js_1.bytesToHex)(trimmedData) : trimmedData;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBlobs = undefined;
  var cursor_js_1 = require_cursor2();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.fromBlobs = fromBlobs;
});

// node_modules/viem/_cjs/utils/kzg/defineKzg.js
var require_defineKzg = __commonJS((exports) => {
  function defineKzg({ blobToKzgCommitment, computeBlobKzgProof }) {
    return {
      blobToKzgCommitment,
      computeBlobKzgProof
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineKzg = undefined;
  exports.defineKzg = defineKzg;
});

// node_modules/viem/_cjs/utils/kzg/setupKzg.js
var require_setupKzg = __commonJS((exports) => {
  function setupKzg(parameters, path) {
    try {
      parameters.loadTrustedSetup(path);
    } catch (e) {
      const error = e;
      if (!error.message.includes("trusted setup is already loaded"))
        throw error;
    }
    return (0, defineKzg_js_1.defineKzg)(parameters);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setupKzg = undefined;
  var defineKzg_js_1 = require_defineKzg();
  exports.setupKzg = setupKzg;
});

// node_modules/viem/_cjs/index.js
var require__cjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.zeroAddress = exports.erc4626Abi = exports.erc721Abi = exports.erc20Abi_bytes32 = exports.erc20Abi = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.rpcSchema = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = undefined;
  exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = undefined;
  exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.presignMessagePrefix = exports.zeroHash = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = undefined;
  exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.TransactionRejectedRpcError = exports.SwitchChainError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.BaseError = exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = undefined;
  exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = exports.StateAssignmentConflictError = exports.AccountStateConflictError = exports.UrlRequiredError = exports.SliceOffsetOutOfBoundsError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarUriResolutionError = exports.SizeOverflowError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = exports.InvalidBytesBooleanError = undefined;
  exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.verifyTypedData = exports.verifyMessage = exports.toRlp = exports.hexToRlp = exports.bytesToRlp = exports.signatureToHex = exports.compactSignatureToHex = exports.signatureToCompactSignature = exports.recoverTypedDataAddress = exports.recoverTransactionAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hexToSignature = exports.hexToCompactSignature = exports.compactSignatureToSignature = exports.hashTypedData = exports.hashDomain = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.rpcTransactionType = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.formatTransactionReceipt = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.parseEventLogs = exports.encodeFunctionResult = exports.prepareEncodeFunctionData = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = undefined;
  exports.toEventSelector = exports.getContractError = exports.getAddress = exports.checksumAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.withTimeout = exports.withRetry = exports.encodePacked = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.setupKzg = exports.defineKzg = exports.toBlobs = exports.toBlobSidecars = exports.fromBlobs = exports.blobsToProofs = exports.sidecarsToVersionedHashes = exports.commitmentsToVersionedHashes = exports.commitmentToVersionedHash = exports.blobsToCommitments = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.ccipRequest = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigInt = exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = undefined;
  exports.getTypesForEIP712Domain = exports.domainSeparator = exports.validateTypedData = exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = exports.isAddressEqual = exports.isAddress = exports.hashMessage = exports.toFunctionHash = exports.toEventHash = exports.getFunctionSignature = exports.toFunctionSignature = exports.getEventSignature = exports.toEventSignature = exports.getFunctionSelector = exports.toFunctionSelector = exports.getEventSelector = undefined;
  var abitype_1 = require_exports();
  Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
    return abitype_1.CircularReferenceError;
  } });
  Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
    return abitype_1.InvalidAbiParameterError;
  } });
  Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
    return abitype_1.InvalidAbiParametersError;
  } });
  Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
    return abitype_1.InvalidAbiItemError;
  } });
  Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
    return abitype_1.InvalidAbiTypeParameterError;
  } });
  Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
    return abitype_1.InvalidFunctionModifierError;
  } });
  Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
    return abitype_1.InvalidModifierError;
  } });
  Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
    return abitype_1.InvalidParameterError;
  } });
  Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
    return abitype_1.InvalidParenthesisError;
  } });
  Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
    return abitype_1.InvalidSignatureError;
  } });
  Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
    return abitype_1.InvalidStructSignatureError;
  } });
  Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
    return abitype_1.SolidityProtectedKeywordError;
  } });
  Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
    return abitype_1.UnknownTypeError;
  } });
  Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
    return abitype_1.UnknownSignatureError;
  } });
  Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
    return abitype_1.parseAbi;
  } });
  Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
    return abitype_1.parseAbiItem;
  } });
  Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
    return abitype_1.parseAbiParameter;
  } });
  Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
    return abitype_1.parseAbiParameters;
  } });
  var getContract_js_1 = require_getContract();
  Object.defineProperty(exports, "getContract", { enumerable: true, get: function() {
    return getContract_js_1.getContract;
  } });
  var createClient_js_1 = require_createClient();
  Object.defineProperty(exports, "createClient", { enumerable: true, get: function() {
    return createClient_js_1.createClient;
  } });
  Object.defineProperty(exports, "rpcSchema", { enumerable: true, get: function() {
    return createClient_js_1.rpcSchema;
  } });
  var custom_js_1 = require_custom();
  Object.defineProperty(exports, "custom", { enumerable: true, get: function() {
    return custom_js_1.custom;
  } });
  var fallback_js_1 = require_fallback();
  Object.defineProperty(exports, "fallback", { enumerable: true, get: function() {
    return fallback_js_1.fallback;
  } });
  var http_js_1 = require_http2();
  Object.defineProperty(exports, "http", { enumerable: true, get: function() {
    return http_js_1.http;
  } });
  var createPublicClient_js_1 = require_createPublicClient();
  Object.defineProperty(exports, "createPublicClient", { enumerable: true, get: function() {
    return createPublicClient_js_1.createPublicClient;
  } });
  var createTestClient_js_1 = require_createTestClient();
  Object.defineProperty(exports, "createTestClient", { enumerable: true, get: function() {
    return createTestClient_js_1.createTestClient;
  } });
  var public_js_1 = require_public();
  Object.defineProperty(exports, "publicActions", { enumerable: true, get: function() {
    return public_js_1.publicActions;
  } });
  var test_js_1 = require_test();
  Object.defineProperty(exports, "testActions", { enumerable: true, get: function() {
    return test_js_1.testActions;
  } });
  var wallet_js_1 = require_wallet();
  Object.defineProperty(exports, "walletActions", { enumerable: true, get: function() {
    return wallet_js_1.walletActions;
  } });
  var createTransport_js_1 = require_createTransport();
  Object.defineProperty(exports, "createTransport", { enumerable: true, get: function() {
    return createTransport_js_1.createTransport;
  } });
  var createWalletClient_js_1 = require_createWalletClient();
  Object.defineProperty(exports, "createWalletClient", { enumerable: true, get: function() {
    return createWalletClient_js_1.createWalletClient;
  } });
  var webSocket_js_1 = require_webSocket2();
  Object.defineProperty(exports, "webSocket", { enumerable: true, get: function() {
    return webSocket_js_1.webSocket;
  } });
  var abis_js_1 = require_abis();
  Object.defineProperty(exports, "multicall3Abi", { enumerable: true, get: function() {
    return abis_js_1.multicall3Abi;
  } });
  Object.defineProperty(exports, "erc20Abi", { enumerable: true, get: function() {
    return abis_js_1.erc20Abi;
  } });
  Object.defineProperty(exports, "erc20Abi_bytes32", { enumerable: true, get: function() {
    return abis_js_1.erc20Abi_bytes32;
  } });
  Object.defineProperty(exports, "erc721Abi", { enumerable: true, get: function() {
    return abis_js_1.erc721Abi;
  } });
  Object.defineProperty(exports, "erc4626Abi", { enumerable: true, get: function() {
    return abis_js_1.erc4626Abi;
  } });
  var address_js_1 = require_address2();
  Object.defineProperty(exports, "zeroAddress", { enumerable: true, get: function() {
    return address_js_1.zeroAddress;
  } });
  var unit_js_1 = require_unit();
  Object.defineProperty(exports, "etherUnits", { enumerable: true, get: function() {
    return unit_js_1.etherUnits;
  } });
  Object.defineProperty(exports, "gweiUnits", { enumerable: true, get: function() {
    return unit_js_1.gweiUnits;
  } });
  Object.defineProperty(exports, "weiUnits", { enumerable: true, get: function() {
    return unit_js_1.weiUnits;
  } });
  var number_js_1 = require_number();
  Object.defineProperty(exports, "maxInt8", { enumerable: true, get: function() {
    return number_js_1.maxInt8;
  } });
  Object.defineProperty(exports, "maxInt16", { enumerable: true, get: function() {
    return number_js_1.maxInt16;
  } });
  Object.defineProperty(exports, "maxInt24", { enumerable: true, get: function() {
    return number_js_1.maxInt24;
  } });
  Object.defineProperty(exports, "maxInt32", { enumerable: true, get: function() {
    return number_js_1.maxInt32;
  } });
  Object.defineProperty(exports, "maxInt40", { enumerable: true, get: function() {
    return number_js_1.maxInt40;
  } });
  Object.defineProperty(exports, "maxInt48", { enumerable: true, get: function() {
    return number_js_1.maxInt48;
  } });
  Object.defineProperty(exports, "maxInt56", { enumerable: true, get: function() {
    return number_js_1.maxInt56;
  } });
  Object.defineProperty(exports, "maxInt64", { enumerable: true, get: function() {
    return number_js_1.maxInt64;
  } });
  Object.defineProperty(exports, "maxInt72", { enumerable: true, get: function() {
    return number_js_1.maxInt72;
  } });
  Object.defineProperty(exports, "maxInt80", { enumerable: true, get: function() {
    return number_js_1.maxInt80;
  } });
  Object.defineProperty(exports, "maxInt88", { enumerable: true, get: function() {
    return number_js_1.maxInt88;
  } });
  Object.defineProperty(exports, "maxInt96", { enumerable: true, get: function() {
    return number_js_1.maxInt96;
  } });
  Object.defineProperty(exports, "maxInt104", { enumerable: true, get: function() {
    return number_js_1.maxInt104;
  } });
  Object.defineProperty(exports, "maxInt112", { enumerable: true, get: function() {
    return number_js_1.maxInt112;
  } });
  Object.defineProperty(exports, "maxInt120", { enumerable: true, get: function() {
    return number_js_1.maxInt120;
  } });
  Object.defineProperty(exports, "maxInt128", { enumerable: true, get: function() {
    return number_js_1.maxInt128;
  } });
  Object.defineProperty(exports, "maxInt136", { enumerable: true, get: function() {
    return number_js_1.maxInt136;
  } });
  Object.defineProperty(exports, "maxInt144", { enumerable: true, get: function() {
    return number_js_1.maxInt144;
  } });
  Object.defineProperty(exports, "maxInt152", { enumerable: true, get: function() {
    return number_js_1.maxInt152;
  } });
  Object.defineProperty(exports, "maxInt160", { enumerable: true, get: function() {
    return number_js_1.maxInt160;
  } });
  Object.defineProperty(exports, "maxInt168", { enumerable: true, get: function() {
    return number_js_1.maxInt168;
  } });
  Object.defineProperty(exports, "maxInt176", { enumerable: true, get: function() {
    return number_js_1.maxInt176;
  } });
  Object.defineProperty(exports, "maxInt184", { enumerable: true, get: function() {
    return number_js_1.maxInt184;
  } });
  Object.defineProperty(exports, "maxInt192", { enumerable: true, get: function() {
    return number_js_1.maxInt192;
  } });
  Object.defineProperty(exports, "maxInt200", { enumerable: true, get: function() {
    return number_js_1.maxInt200;
  } });
  Object.defineProperty(exports, "maxInt208", { enumerable: true, get: function() {
    return number_js_1.maxInt208;
  } });
  Object.defineProperty(exports, "maxInt216", { enumerable: true, get: function() {
    return number_js_1.maxInt216;
  } });
  Object.defineProperty(exports, "maxInt224", { enumerable: true, get: function() {
    return number_js_1.maxInt224;
  } });
  Object.defineProperty(exports, "maxInt232", { enumerable: true, get: function() {
    return number_js_1.maxInt232;
  } });
  Object.defineProperty(exports, "maxInt240", { enumerable: true, get: function() {
    return number_js_1.maxInt240;
  } });
  Object.defineProperty(exports, "maxInt248", { enumerable: true, get: function() {
    return number_js_1.maxInt248;
  } });
  Object.defineProperty(exports, "maxInt256", { enumerable: true, get: function() {
    return number_js_1.maxInt256;
  } });
  Object.defineProperty(exports, "maxUint8", { enumerable: true, get: function() {
    return number_js_1.maxUint8;
  } });
  Object.defineProperty(exports, "maxUint16", { enumerable: true, get: function() {
    return number_js_1.maxUint16;
  } });
  Object.defineProperty(exports, "maxUint24", { enumerable: true, get: function() {
    return number_js_1.maxUint24;
  } });
  Object.defineProperty(exports, "maxUint32", { enumerable: true, get: function() {
    return number_js_1.maxUint32;
  } });
  Object.defineProperty(exports, "maxUint40", { enumerable: true, get: function() {
    return number_js_1.maxUint40;
  } });
  Object.defineProperty(exports, "maxUint48", { enumerable: true, get: function() {
    return number_js_1.maxUint48;
  } });
  Object.defineProperty(exports, "maxUint56", { enumerable: true, get: function() {
    return number_js_1.maxUint56;
  } });
  Object.defineProperty(exports, "maxUint64", { enumerable: true, get: function() {
    return number_js_1.maxUint64;
  } });
  Object.defineProperty(exports, "maxUint72", { enumerable: true, get: function() {
    return number_js_1.maxUint72;
  } });
  Object.defineProperty(exports, "maxUint80", { enumerable: true, get: function() {
    return number_js_1.maxUint80;
  } });
  Object.defineProperty(exports, "maxUint88", { enumerable: true, get: function() {
    return number_js_1.maxUint88;
  } });
  Object.defineProperty(exports, "maxUint96", { enumerable: true, get: function() {
    return number_js_1.maxUint96;
  } });
  Object.defineProperty(exports, "maxUint104", { enumerable: true, get: function() {
    return number_js_1.maxUint104;
  } });
  Object.defineProperty(exports, "maxUint112", { enumerable: true, get: function() {
    return number_js_1.maxUint112;
  } });
  Object.defineProperty(exports, "maxUint120", { enumerable: true, get: function() {
    return number_js_1.maxUint120;
  } });
  Object.defineProperty(exports, "maxUint128", { enumerable: true, get: function() {
    return number_js_1.maxUint128;
  } });
  Object.defineProperty(exports, "maxUint136", { enumerable: true, get: function() {
    return number_js_1.maxUint136;
  } });
  Object.defineProperty(exports, "maxUint144", { enumerable: true, get: function() {
    return number_js_1.maxUint144;
  } });
  Object.defineProperty(exports, "maxUint152", { enumerable: true, get: function() {
    return number_js_1.maxUint152;
  } });
  Object.defineProperty(exports, "maxUint160", { enumerable: true, get: function() {
    return number_js_1.maxUint160;
  } });
  Object.defineProperty(exports, "maxUint168", { enumerable: true, get: function() {
    return number_js_1.maxUint168;
  } });
  Object.defineProperty(exports, "maxUint176", { enumerable: true, get: function() {
    return number_js_1.maxUint176;
  } });
  Object.defineProperty(exports, "maxUint184", { enumerable: true, get: function() {
    return number_js_1.maxUint184;
  } });
  Object.defineProperty(exports, "maxUint192", { enumerable: true, get: function() {
    return number_js_1.maxUint192;
  } });
  Object.defineProperty(exports, "maxUint200", { enumerable: true, get: function() {
    return number_js_1.maxUint200;
  } });
  Object.defineProperty(exports, "maxUint208", { enumerable: true, get: function() {
    return number_js_1.maxUint208;
  } });
  Object.defineProperty(exports, "maxUint216", { enumerable: true, get: function() {
    return number_js_1.maxUint216;
  } });
  Object.defineProperty(exports, "maxUint224", { enumerable: true, get: function() {
    return number_js_1.maxUint224;
  } });
  Object.defineProperty(exports, "maxUint232", { enumerable: true, get: function() {
    return number_js_1.maxUint232;
  } });
  Object.defineProperty(exports, "maxUint240", { enumerable: true, get: function() {
    return number_js_1.maxUint240;
  } });
  Object.defineProperty(exports, "maxUint248", { enumerable: true, get: function() {
    return number_js_1.maxUint248;
  } });
  Object.defineProperty(exports, "maxUint256", { enumerable: true, get: function() {
    return number_js_1.maxUint256;
  } });
  Object.defineProperty(exports, "minInt8", { enumerable: true, get: function() {
    return number_js_1.minInt8;
  } });
  Object.defineProperty(exports, "minInt16", { enumerable: true, get: function() {
    return number_js_1.minInt16;
  } });
  Object.defineProperty(exports, "minInt24", { enumerable: true, get: function() {
    return number_js_1.minInt24;
  } });
  Object.defineProperty(exports, "minInt32", { enumerable: true, get: function() {
    return number_js_1.minInt32;
  } });
  Object.defineProperty(exports, "minInt40", { enumerable: true, get: function() {
    return number_js_1.minInt40;
  } });
  Object.defineProperty(exports, "minInt48", { enumerable: true, get: function() {
    return number_js_1.minInt48;
  } });
  Object.defineProperty(exports, "minInt56", { enumerable: true, get: function() {
    return number_js_1.minInt56;
  } });
  Object.defineProperty(exports, "minInt64", { enumerable: true, get: function() {
    return number_js_1.minInt64;
  } });
  Object.defineProperty(exports, "minInt72", { enumerable: true, get: function() {
    return number_js_1.minInt72;
  } });
  Object.defineProperty(exports, "minInt80", { enumerable: true, get: function() {
    return number_js_1.minInt80;
  } });
  Object.defineProperty(exports, "minInt88", { enumerable: true, get: function() {
    return number_js_1.minInt88;
  } });
  Object.defineProperty(exports, "minInt96", { enumerable: true, get: function() {
    return number_js_1.minInt96;
  } });
  Object.defineProperty(exports, "minInt104", { enumerable: true, get: function() {
    return number_js_1.minInt104;
  } });
  Object.defineProperty(exports, "minInt112", { enumerable: true, get: function() {
    return number_js_1.minInt112;
  } });
  Object.defineProperty(exports, "minInt120", { enumerable: true, get: function() {
    return number_js_1.minInt120;
  } });
  Object.defineProperty(exports, "minInt128", { enumerable: true, get: function() {
    return number_js_1.minInt128;
  } });
  Object.defineProperty(exports, "minInt136", { enumerable: true, get: function() {
    return number_js_1.minInt136;
  } });
  Object.defineProperty(exports, "minInt144", { enumerable: true, get: function() {
    return number_js_1.minInt144;
  } });
  Object.defineProperty(exports, "minInt152", { enumerable: true, get: function() {
    return number_js_1.minInt152;
  } });
  Object.defineProperty(exports, "minInt160", { enumerable: true, get: function() {
    return number_js_1.minInt160;
  } });
  Object.defineProperty(exports, "minInt168", { enumerable: true, get: function() {
    return number_js_1.minInt168;
  } });
  Object.defineProperty(exports, "minInt176", { enumerable: true, get: function() {
    return number_js_1.minInt176;
  } });
  Object.defineProperty(exports, "minInt184", { enumerable: true, get: function() {
    return number_js_1.minInt184;
  } });
  Object.defineProperty(exports, "minInt192", { enumerable: true, get: function() {
    return number_js_1.minInt192;
  } });
  Object.defineProperty(exports, "minInt200", { enumerable: true, get: function() {
    return number_js_1.minInt200;
  } });
  Object.defineProperty(exports, "minInt208", { enumerable: true, get: function() {
    return number_js_1.minInt208;
  } });
  Object.defineProperty(exports, "minInt216", { enumerable: true, get: function() {
    return number_js_1.minInt216;
  } });
  Object.defineProperty(exports, "minInt224", { enumerable: true, get: function() {
    return number_js_1.minInt224;
  } });
  Object.defineProperty(exports, "minInt232", { enumerable: true, get: function() {
    return number_js_1.minInt232;
  } });
  Object.defineProperty(exports, "minInt240", { enumerable: true, get: function() {
    return number_js_1.minInt240;
  } });
  Object.defineProperty(exports, "minInt248", { enumerable: true, get: function() {
    return number_js_1.minInt248;
  } });
  Object.defineProperty(exports, "minInt256", { enumerable: true, get: function() {
    return number_js_1.minInt256;
  } });
  var bytes_js_1 = require_bytes();
  Object.defineProperty(exports, "zeroHash", { enumerable: true, get: function() {
    return bytes_js_1.zeroHash;
  } });
  var strings_js_1 = require_strings();
  Object.defineProperty(exports, "presignMessagePrefix", { enumerable: true, get: function() {
    return strings_js_1.presignMessagePrefix;
  } });
  var abi_js_1 = require_abi();
  Object.defineProperty(exports, "AbiConstructorNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiConstructorNotFoundError;
  } });
  Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiConstructorParamsNotFoundError;
  } });
  Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function() {
    return abi_js_1.AbiDecodingDataSizeInvalidError;
  } });
  Object.defineProperty(exports, "AbiDecodingDataSizeTooSmallError", { enumerable: true, get: function() {
    return abi_js_1.AbiDecodingDataSizeTooSmallError;
  } });
  Object.defineProperty(exports, "AbiDecodingZeroDataError", { enumerable: true, get: function() {
    return abi_js_1.AbiDecodingZeroDataError;
  } });
  Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function() {
    return abi_js_1.AbiEncodingArrayLengthMismatchError;
  } });
  Object.defineProperty(exports, "AbiEncodingLengthMismatchError", { enumerable: true, get: function() {
    return abi_js_1.AbiEncodingLengthMismatchError;
  } });
  Object.defineProperty(exports, "AbiEncodingBytesSizeMismatchError", { enumerable: true, get: function() {
    return abi_js_1.AbiEncodingBytesSizeMismatchError;
  } });
  Object.defineProperty(exports, "AbiErrorInputsNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiErrorInputsNotFoundError;
  } });
  Object.defineProperty(exports, "AbiErrorNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiErrorNotFoundError;
  } });
  Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiErrorSignatureNotFoundError;
  } });
  Object.defineProperty(exports, "AbiEventNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiEventNotFoundError;
  } });
  Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function() {
    return abi_js_1.AbiEventSignatureEmptyTopicsError;
  } });
  Object.defineProperty(exports, "AbiEventSignatureNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiEventSignatureNotFoundError;
  } });
  Object.defineProperty(exports, "AbiFunctionNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiFunctionNotFoundError;
  } });
  Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiFunctionOutputsNotFoundError;
  } });
  Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function() {
    return abi_js_1.AbiFunctionSignatureNotFoundError;
  } });
  Object.defineProperty(exports, "BytesSizeMismatchError", { enumerable: true, get: function() {
    return abi_js_1.BytesSizeMismatchError;
  } });
  Object.defineProperty(exports, "DecodeLogDataMismatch", { enumerable: true, get: function() {
    return abi_js_1.DecodeLogDataMismatch;
  } });
  Object.defineProperty(exports, "DecodeLogTopicsMismatch", { enumerable: true, get: function() {
    return abi_js_1.DecodeLogTopicsMismatch;
  } });
  Object.defineProperty(exports, "InvalidAbiDecodingTypeError", { enumerable: true, get: function() {
    return abi_js_1.InvalidAbiDecodingTypeError;
  } });
  Object.defineProperty(exports, "InvalidAbiEncodingTypeError", { enumerable: true, get: function() {
    return abi_js_1.InvalidAbiEncodingTypeError;
  } });
  Object.defineProperty(exports, "InvalidArrayError", { enumerable: true, get: function() {
    return abi_js_1.InvalidArrayError;
  } });
  Object.defineProperty(exports, "InvalidDefinitionTypeError", { enumerable: true, get: function() {
    return abi_js_1.InvalidDefinitionTypeError;
  } });
  Object.defineProperty(exports, "UnsupportedPackedAbiType", { enumerable: true, get: function() {
    return abi_js_1.UnsupportedPackedAbiType;
  } });
  var base_js_1 = require_base();
  Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
    return base_js_1.BaseError;
  } });
  var block_js_1 = require_block2();
  Object.defineProperty(exports, "BlockNotFoundError", { enumerable: true, get: function() {
    return block_js_1.BlockNotFoundError;
  } });
  var contract_js_1 = require_contract();
  Object.defineProperty(exports, "CallExecutionError", { enumerable: true, get: function() {
    return contract_js_1.CallExecutionError;
  } });
  Object.defineProperty(exports, "ContractFunctionExecutionError", { enumerable: true, get: function() {
    return contract_js_1.ContractFunctionExecutionError;
  } });
  Object.defineProperty(exports, "ContractFunctionRevertedError", { enumerable: true, get: function() {
    return contract_js_1.ContractFunctionRevertedError;
  } });
  Object.defineProperty(exports, "ContractFunctionZeroDataError", { enumerable: true, get: function() {
    return contract_js_1.ContractFunctionZeroDataError;
  } });
  Object.defineProperty(exports, "RawContractError", { enumerable: true, get: function() {
    return contract_js_1.RawContractError;
  } });
  var fee_js_1 = require_fee();
  Object.defineProperty(exports, "BaseFeeScalarError", { enumerable: true, get: function() {
    return fee_js_1.BaseFeeScalarError;
  } });
  Object.defineProperty(exports, "Eip1559FeesNotSupportedError", { enumerable: true, get: function() {
    return fee_js_1.Eip1559FeesNotSupportedError;
  } });
  Object.defineProperty(exports, "MaxFeePerGasTooLowError", { enumerable: true, get: function() {
    return fee_js_1.MaxFeePerGasTooLowError;
  } });
  var rpc_js_1 = require_rpc();
  Object.defineProperty(exports, "ChainDisconnectedError", { enumerable: true, get: function() {
    return rpc_js_1.ChainDisconnectedError;
  } });
  Object.defineProperty(exports, "InternalRpcError", { enumerable: true, get: function() {
    return rpc_js_1.InternalRpcError;
  } });
  Object.defineProperty(exports, "InvalidInputRpcError", { enumerable: true, get: function() {
    return rpc_js_1.InvalidInputRpcError;
  } });
  Object.defineProperty(exports, "InvalidParamsRpcError", { enumerable: true, get: function() {
    return rpc_js_1.InvalidParamsRpcError;
  } });
  Object.defineProperty(exports, "InvalidRequestRpcError", { enumerable: true, get: function() {
    return rpc_js_1.InvalidRequestRpcError;
  } });
  Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function() {
    return rpc_js_1.JsonRpcVersionUnsupportedError;
  } });
  Object.defineProperty(exports, "LimitExceededRpcError", { enumerable: true, get: function() {
    return rpc_js_1.LimitExceededRpcError;
  } });
  Object.defineProperty(exports, "MethodNotFoundRpcError", { enumerable: true, get: function() {
    return rpc_js_1.MethodNotFoundRpcError;
  } });
  Object.defineProperty(exports, "MethodNotSupportedRpcError", { enumerable: true, get: function() {
    return rpc_js_1.MethodNotSupportedRpcError;
  } });
  Object.defineProperty(exports, "ParseRpcError", { enumerable: true, get: function() {
    return rpc_js_1.ParseRpcError;
  } });
  Object.defineProperty(exports, "ProviderDisconnectedError", { enumerable: true, get: function() {
    return rpc_js_1.ProviderDisconnectedError;
  } });
  Object.defineProperty(exports, "ProviderRpcError", { enumerable: true, get: function() {
    return rpc_js_1.ProviderRpcError;
  } });
  Object.defineProperty(exports, "ResourceNotFoundRpcError", { enumerable: true, get: function() {
    return rpc_js_1.ResourceNotFoundRpcError;
  } });
  Object.defineProperty(exports, "ResourceUnavailableRpcError", { enumerable: true, get: function() {
    return rpc_js_1.ResourceUnavailableRpcError;
  } });
  Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
    return rpc_js_1.RpcError;
  } });
  Object.defineProperty(exports, "SwitchChainError", { enumerable: true, get: function() {
    return rpc_js_1.SwitchChainError;
  } });
  Object.defineProperty(exports, "TransactionRejectedRpcError", { enumerable: true, get: function() {
    return rpc_js_1.TransactionRejectedRpcError;
  } });
  Object.defineProperty(exports, "UnauthorizedProviderError", { enumerable: true, get: function() {
    return rpc_js_1.UnauthorizedProviderError;
  } });
  Object.defineProperty(exports, "UnknownRpcError", { enumerable: true, get: function() {
    return rpc_js_1.UnknownRpcError;
  } });
  Object.defineProperty(exports, "UnsupportedProviderMethodError", { enumerable: true, get: function() {
    return rpc_js_1.UnsupportedProviderMethodError;
  } });
  Object.defineProperty(exports, "UserRejectedRequestError", { enumerable: true, get: function() {
    return rpc_js_1.UserRejectedRequestError;
  } });
  var chain_js_1 = require_chain();
  Object.defineProperty(exports, "ChainDoesNotSupportContract", { enumerable: true, get: function() {
    return chain_js_1.ChainDoesNotSupportContract;
  } });
  Object.defineProperty(exports, "ChainMismatchError", { enumerable: true, get: function() {
    return chain_js_1.ChainMismatchError;
  } });
  Object.defineProperty(exports, "ChainNotFoundError", { enumerable: true, get: function() {
    return chain_js_1.ChainNotFoundError;
  } });
  Object.defineProperty(exports, "ClientChainNotConfiguredError", { enumerable: true, get: function() {
    return chain_js_1.ClientChainNotConfiguredError;
  } });
  Object.defineProperty(exports, "InvalidChainIdError", { enumerable: true, get: function() {
    return chain_js_1.InvalidChainIdError;
  } });
  var encoding_js_1 = require_encoding();
  Object.defineProperty(exports, "InvalidBytesBooleanError", { enumerable: true, get: function() {
    return encoding_js_1.InvalidBytesBooleanError;
  } });
  Object.defineProperty(exports, "IntegerOutOfRangeError", { enumerable: true, get: function() {
    return encoding_js_1.IntegerOutOfRangeError;
  } });
  Object.defineProperty(exports, "InvalidHexBooleanError", { enumerable: true, get: function() {
    return encoding_js_1.InvalidHexBooleanError;
  } });
  Object.defineProperty(exports, "InvalidHexValueError", { enumerable: true, get: function() {
    return encoding_js_1.InvalidHexValueError;
  } });
  Object.defineProperty(exports, "SizeOverflowError", { enumerable: true, get: function() {
    return encoding_js_1.SizeOverflowError;
  } });
  var ens_js_1 = require_ens();
  Object.defineProperty(exports, "EnsAvatarUriResolutionError", { enumerable: true, get: function() {
    return ens_js_1.EnsAvatarUriResolutionError;
  } });
  Object.defineProperty(exports, "EnsAvatarInvalidNftUriError", { enumerable: true, get: function() {
    return ens_js_1.EnsAvatarInvalidNftUriError;
  } });
  Object.defineProperty(exports, "EnsAvatarUnsupportedNamespaceError", { enumerable: true, get: function() {
    return ens_js_1.EnsAvatarUnsupportedNamespaceError;
  } });
  var estimateGas_js_1 = require_estimateGas();
  Object.defineProperty(exports, "EstimateGasExecutionError", { enumerable: true, get: function() {
    return estimateGas_js_1.EstimateGasExecutionError;
  } });
  var node_js_1 = require_node();
  Object.defineProperty(exports, "ExecutionRevertedError", { enumerable: true, get: function() {
    return node_js_1.ExecutionRevertedError;
  } });
  Object.defineProperty(exports, "FeeCapTooHighError", { enumerable: true, get: function() {
    return node_js_1.FeeCapTooHighError;
  } });
  Object.defineProperty(exports, "FeeCapTooLowError", { enumerable: true, get: function() {
    return node_js_1.FeeCapTooLowError;
  } });
  Object.defineProperty(exports, "InsufficientFundsError", { enumerable: true, get: function() {
    return node_js_1.InsufficientFundsError;
  } });
  Object.defineProperty(exports, "IntrinsicGasTooHighError", { enumerable: true, get: function() {
    return node_js_1.IntrinsicGasTooHighError;
  } });
  Object.defineProperty(exports, "IntrinsicGasTooLowError", { enumerable: true, get: function() {
    return node_js_1.IntrinsicGasTooLowError;
  } });
  Object.defineProperty(exports, "NonceMaxValueError", { enumerable: true, get: function() {
    return node_js_1.NonceMaxValueError;
  } });
  Object.defineProperty(exports, "NonceTooHighError", { enumerable: true, get: function() {
    return node_js_1.NonceTooHighError;
  } });
  Object.defineProperty(exports, "NonceTooLowError", { enumerable: true, get: function() {
    return node_js_1.NonceTooLowError;
  } });
  Object.defineProperty(exports, "TipAboveFeeCapError", { enumerable: true, get: function() {
    return node_js_1.TipAboveFeeCapError;
  } });
  Object.defineProperty(exports, "TransactionTypeNotSupportedError", { enumerable: true, get: function() {
    return node_js_1.TransactionTypeNotSupportedError;
  } });
  Object.defineProperty(exports, "UnknownNodeError", { enumerable: true, get: function() {
    return node_js_1.UnknownNodeError;
  } });
  var log_js_1 = require_log2();
  Object.defineProperty(exports, "FilterTypeNotSupportedError", { enumerable: true, get: function() {
    return log_js_1.FilterTypeNotSupportedError;
  } });
  var request_js_1 = require_request();
  Object.defineProperty(exports, "HttpRequestError", { enumerable: true, get: function() {
    return request_js_1.HttpRequestError;
  } });
  Object.defineProperty(exports, "RpcRequestError", { enumerable: true, get: function() {
    return request_js_1.RpcRequestError;
  } });
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return request_js_1.TimeoutError;
  } });
  Object.defineProperty(exports, "WebSocketRequestError", { enumerable: true, get: function() {
    return request_js_1.WebSocketRequestError;
  } });
  var address_js_2 = require_address();
  Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function() {
    return address_js_2.InvalidAddressError;
  } });
  var transaction_js_1 = require_transaction2();
  Object.defineProperty(exports, "FeeConflictError", { enumerable: true, get: function() {
    return transaction_js_1.FeeConflictError;
  } });
  Object.defineProperty(exports, "InvalidLegacyVError", { enumerable: true, get: function() {
    return transaction_js_1.InvalidLegacyVError;
  } });
  Object.defineProperty(exports, "InvalidSerializableTransactionError", { enumerable: true, get: function() {
    return transaction_js_1.InvalidSerializableTransactionError;
  } });
  Object.defineProperty(exports, "InvalidSerializedTransactionError", { enumerable: true, get: function() {
    return transaction_js_1.InvalidSerializedTransactionError;
  } });
  Object.defineProperty(exports, "InvalidSerializedTransactionTypeError", { enumerable: true, get: function() {
    return transaction_js_1.InvalidSerializedTransactionTypeError;
  } });
  Object.defineProperty(exports, "InvalidStorageKeySizeError", { enumerable: true, get: function() {
    return transaction_js_1.InvalidStorageKeySizeError;
  } });
  Object.defineProperty(exports, "TransactionExecutionError", { enumerable: true, get: function() {
    return transaction_js_1.TransactionExecutionError;
  } });
  Object.defineProperty(exports, "TransactionNotFoundError", { enumerable: true, get: function() {
    return transaction_js_1.TransactionNotFoundError;
  } });
  Object.defineProperty(exports, "TransactionReceiptNotFoundError", { enumerable: true, get: function() {
    return transaction_js_1.TransactionReceiptNotFoundError;
  } });
  Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function() {
    return transaction_js_1.WaitForTransactionReceiptTimeoutError;
  } });
  var data_js_1 = require_data();
  Object.defineProperty(exports, "SizeExceedsPaddingSizeError", { enumerable: true, get: function() {
    return data_js_1.SizeExceedsPaddingSizeError;
  } });
  Object.defineProperty(exports, "SliceOffsetOutOfBoundsError", { enumerable: true, get: function() {
    return data_js_1.SliceOffsetOutOfBoundsError;
  } });
  var transport_js_1 = require_transport();
  Object.defineProperty(exports, "UrlRequiredError", { enumerable: true, get: function() {
    return transport_js_1.UrlRequiredError;
  } });
  var stateOverride_js_1 = require_stateOverride();
  Object.defineProperty(exports, "AccountStateConflictError", { enumerable: true, get: function() {
    return stateOverride_js_1.AccountStateConflictError;
  } });
  Object.defineProperty(exports, "StateAssignmentConflictError", { enumerable: true, get: function() {
    return stateOverride_js_1.StateAssignmentConflictError;
  } });
  var labelhash_js_1 = require_labelhash();
  Object.defineProperty(exports, "labelhash", { enumerable: true, get: function() {
    return labelhash_js_1.labelhash;
  } });
  var namehash_js_1 = require_namehash();
  Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
    return namehash_js_1.namehash;
  } });
  var block_js_2 = require_block();
  Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
    return block_js_2.defineBlock;
  } });
  Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
    return block_js_2.formatBlock;
  } });
  var log_js_2 = require_log();
  Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
    return log_js_2.formatLog;
  } });
  var decodeAbiParameters_js_1 = require_decodeAbiParameters();
  Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
    return decodeAbiParameters_js_1.decodeAbiParameters;
  } });
  var decodeDeployData_js_1 = require_decodeDeployData();
  Object.defineProperty(exports, "decodeDeployData", { enumerable: true, get: function() {
    return decodeDeployData_js_1.decodeDeployData;
  } });
  var decodeErrorResult_js_1 = require_decodeErrorResult();
  Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
    return decodeErrorResult_js_1.decodeErrorResult;
  } });
  var decodeEventLog_js_1 = require_decodeEventLog();
  Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
    return decodeEventLog_js_1.decodeEventLog;
  } });
  var decodeFunctionData_js_1 = require_decodeFunctionData();
  Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
    return decodeFunctionData_js_1.decodeFunctionData;
  } });
  var decodeFunctionResult_js_1 = require_decodeFunctionResult();
  Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
    return decodeFunctionResult_js_1.decodeFunctionResult;
  } });
  var encodeAbiParameters_js_1 = require_encodeAbiParameters();
  Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
    return encodeAbiParameters_js_1.encodeAbiParameters;
  } });
  var encodeDeployData_js_1 = require_encodeDeployData();
  Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
    return encodeDeployData_js_1.encodeDeployData;
  } });
  var encodeErrorResult_js_1 = require_encodeErrorResult();
  Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
    return encodeErrorResult_js_1.encodeErrorResult;
  } });
  var encodeEventTopics_js_1 = require_encodeEventTopics();
  Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
    return encodeEventTopics_js_1.encodeEventTopics;
  } });
  var encodeFunctionData_js_1 = require_encodeFunctionData();
  Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
    return encodeFunctionData_js_1.encodeFunctionData;
  } });
  var prepareEncodeFunctionData_js_1 = require_prepareEncodeFunctionData();
  Object.defineProperty(exports, "prepareEncodeFunctionData", { enumerable: true, get: function() {
    return prepareEncodeFunctionData_js_1.prepareEncodeFunctionData;
  } });
  var encodeFunctionResult_js_1 = require_encodeFunctionResult();
  Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
    return encodeFunctionResult_js_1.encodeFunctionResult;
  } });
  var parseEventLogs_js_1 = require_parseEventLogs();
  Object.defineProperty(exports, "parseEventLogs", { enumerable: true, get: function() {
    return parseEventLogs_js_1.parseEventLogs;
  } });
  var transaction_js_2 = require_transaction();
  Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
    return transaction_js_2.defineTransaction;
  } });
  Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
    return transaction_js_2.formatTransaction;
  } });
  Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
    return transaction_js_2.transactionType;
  } });
  var transactionReceipt_js_1 = require_transactionReceipt();
  Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
    return transactionReceipt_js_1.defineTransactionReceipt;
  } });
  Object.defineProperty(exports, "formatTransactionReceipt", { enumerable: true, get: function() {
    return transactionReceipt_js_1.formatTransactionReceipt;
  } });
  var transactionRequest_js_1 = require_transactionRequest();
  Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
    return transactionRequest_js_1.defineTransactionRequest;
  } });
  Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
    return transactionRequest_js_1.formatTransactionRequest;
  } });
  Object.defineProperty(exports, "rpcTransactionType", { enumerable: true, get: function() {
    return transactionRequest_js_1.rpcTransactionType;
  } });
  var getAbiItem_js_1 = require_getAbiItem();
  Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
    return getAbiItem_js_1.getAbiItem;
  } });
  var getContractAddress_js_1 = require_getContractAddress();
  Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
    return getContractAddress_js_1.getContractAddress;
  } });
  Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
    return getContractAddress_js_1.getCreate2Address;
  } });
  Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
    return getContractAddress_js_1.getCreateAddress;
  } });
  var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
  Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
    return getSerializedTransactionType_js_1.getSerializedTransactionType;
  } });
  var getTransactionType_js_1 = require_getTransactionType();
  Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
    return getTransactionType_js_1.getTransactionType;
  } });
  var hashTypedData_js_1 = require_hashTypedData();
  Object.defineProperty(exports, "hashDomain", { enumerable: true, get: function() {
    return hashTypedData_js_1.hashDomain;
  } });
  Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
    return hashTypedData_js_1.hashTypedData;
  } });
  var compactSignatureToSignature_js_1 = require_compactSignatureToSignature();
  Object.defineProperty(exports, "compactSignatureToSignature", { enumerable: true, get: function() {
    return compactSignatureToSignature_js_1.compactSignatureToSignature;
  } });
  var hexToCompactSignature_js_1 = require_hexToCompactSignature();
  Object.defineProperty(exports, "hexToCompactSignature", { enumerable: true, get: function() {
    return hexToCompactSignature_js_1.hexToCompactSignature;
  } });
  var hexToSignature_js_1 = require_hexToSignature();
  Object.defineProperty(exports, "hexToSignature", { enumerable: true, get: function() {
    return hexToSignature_js_1.hexToSignature;
  } });
  var recoverAddress_js_1 = require_recoverAddress();
  Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
    return recoverAddress_js_1.recoverAddress;
  } });
  var recoverMessageAddress_js_1 = require_recoverMessageAddress();
  Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
    return recoverMessageAddress_js_1.recoverMessageAddress;
  } });
  var recoverPublicKey_js_1 = require_recoverPublicKey();
  Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
    return recoverPublicKey_js_1.recoverPublicKey;
  } });
  var recoverTransactionAddress_js_1 = require_recoverTransactionAddress();
  Object.defineProperty(exports, "recoverTransactionAddress", { enumerable: true, get: function() {
    return recoverTransactionAddress_js_1.recoverTransactionAddress;
  } });
  var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
  Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
    return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
  } });
  var signatureToCompactSignature_js_1 = require_signatureToCompactSignature();
  Object.defineProperty(exports, "signatureToCompactSignature", { enumerable: true, get: function() {
    return signatureToCompactSignature_js_1.signatureToCompactSignature;
  } });
  var compactSignatureToHex_js_1 = require_compactSignatureToHex();
  Object.defineProperty(exports, "compactSignatureToHex", { enumerable: true, get: function() {
    return compactSignatureToHex_js_1.compactSignatureToHex;
  } });
  var signatureToHex_js_1 = require_signatureToHex();
  Object.defineProperty(exports, "signatureToHex", { enumerable: true, get: function() {
    return signatureToHex_js_1.signatureToHex;
  } });
  var toRlp_js_1 = require_toRlp();
  Object.defineProperty(exports, "bytesToRlp", { enumerable: true, get: function() {
    return toRlp_js_1.bytesToRlp;
  } });
  Object.defineProperty(exports, "hexToRlp", { enumerable: true, get: function() {
    return toRlp_js_1.hexToRlp;
  } });
  Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
    return toRlp_js_1.toRlp;
  } });
  var verifyMessage_js_1 = require_verifyMessage();
  Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
    return verifyMessage_js_1.verifyMessage;
  } });
  var verifyTypedData_js_1 = require_verifyTypedData();
  Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
    return verifyTypedData_js_1.verifyTypedData;
  } });
  var assertRequest_js_1 = require_assertRequest();
  Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
    return assertRequest_js_1.assertRequest;
  } });
  var assertTransaction_js_1 = require_assertTransaction();
  Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
    return assertTransaction_js_1.assertTransactionEIP1559;
  } });
  Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
    return assertTransaction_js_1.assertTransactionEIP2930;
  } });
  Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
    return assertTransaction_js_1.assertTransactionLegacy;
  } });
  var toBytes_js_1 = require_toBytes();
  Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.boolToBytes;
  } });
  Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.hexToBytes;
  } });
  Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.numberToBytes;
  } });
  Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
    return toBytes_js_1.stringToBytes;
  } });
  Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
    return toBytes_js_1.toBytes;
  } });
  var toHex_js_1 = require_toHex();
  Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
    return toHex_js_1.boolToHex;
  } });
  Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
    return toHex_js_1.bytesToHex;
  } });
  Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
    return toHex_js_1.numberToHex;
  } });
  Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
    return toHex_js_1.stringToHex;
  } });
  Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
    return toHex_js_1.toHex;
  } });
  var fromBytes_js_1 = require_fromBytes();
  Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToBigInt;
  } });
  Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToBool;
  } });
  Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToNumber;
  } });
  Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
    return fromBytes_js_1.bytesToString;
  } });
  Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
    return fromBytes_js_1.fromBytes;
  } });
  var ccip_js_1 = require_ccip2();
  Object.defineProperty(exports, "ccipRequest", { enumerable: true, get: function() {
    return ccip_js_1.ccipRequest;
  } });
  Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
    return ccip_js_1.ccipRequest;
  } });
  Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
    return ccip_js_1.offchainLookup;
  } });
  Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
    return ccip_js_1.offchainLookupAbiItem;
  } });
  Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
    return ccip_js_1.offchainLookupSignature;
  } });
  var blobsToCommitments_js_1 = require_blobsToCommitments();
  Object.defineProperty(exports, "blobsToCommitments", { enumerable: true, get: function() {
    return blobsToCommitments_js_1.blobsToCommitments;
  } });
  var commitmentToVersionedHash_js_1 = require_commitmentToVersionedHash();
  Object.defineProperty(exports, "commitmentToVersionedHash", { enumerable: true, get: function() {
    return commitmentToVersionedHash_js_1.commitmentToVersionedHash;
  } });
  var commitmentsToVersionedHashes_js_1 = require_commitmentsToVersionedHashes();
  Object.defineProperty(exports, "commitmentsToVersionedHashes", { enumerable: true, get: function() {
    return commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes;
  } });
  var sidecarsToVersionedHashes_js_1 = require_sidecarsToVersionedHashes();
  Object.defineProperty(exports, "sidecarsToVersionedHashes", { enumerable: true, get: function() {
    return sidecarsToVersionedHashes_js_1.sidecarsToVersionedHashes;
  } });
  var blobsToProofs_js_1 = require_blobsToProofs();
  Object.defineProperty(exports, "blobsToProofs", { enumerable: true, get: function() {
    return blobsToProofs_js_1.blobsToProofs;
  } });
  var fromBlobs_js_1 = require_fromBlobs();
  Object.defineProperty(exports, "fromBlobs", { enumerable: true, get: function() {
    return fromBlobs_js_1.fromBlobs;
  } });
  var toBlobSidecars_js_1 = require_toBlobSidecars();
  Object.defineProperty(exports, "toBlobSidecars", { enumerable: true, get: function() {
    return toBlobSidecars_js_1.toBlobSidecars;
  } });
  var toBlobs_js_1 = require_toBlobs();
  Object.defineProperty(exports, "toBlobs", { enumerable: true, get: function() {
    return toBlobs_js_1.toBlobs;
  } });
  var defineKzg_js_1 = require_defineKzg();
  Object.defineProperty(exports, "defineKzg", { enumerable: true, get: function() {
    return defineKzg_js_1.defineKzg;
  } });
  var setupKzg_js_1 = require_setupKzg();
  Object.defineProperty(exports, "setupKzg", { enumerable: true, get: function() {
    return setupKzg_js_1.setupKzg;
  } });
  var concat_js_1 = require_concat();
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_js_1.concat;
  } });
  Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
    return concat_js_1.concatBytes;
  } });
  Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
    return concat_js_1.concatHex;
  } });
  var assertCurrentChain_js_1 = require_assertCurrentChain();
  Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
    return assertCurrentChain_js_1.assertCurrentChain;
  } });
  var defineChain_js_1 = require_defineChain();
  Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
    return defineChain_js_1.defineChain;
  } });
  var extractChain_js_1 = require_extractChain();
  Object.defineProperty(exports, "extractChain", { enumerable: true, get: function() {
    return extractChain_js_1.extractChain;
  } });
  var getChainContractAddress_js_1 = require_getChainContractAddress();
  Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
    return getChainContractAddress_js_1.getChainContractAddress;
  } });
  var encodePacked_js_1 = require_encodePacked();
  Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
    return encodePacked_js_1.encodePacked;
  } });
  var withRetry_js_1 = require_withRetry();
  Object.defineProperty(exports, "withRetry", { enumerable: true, get: function() {
    return withRetry_js_1.withRetry;
  } });
  var withTimeout_js_1 = require_withTimeout();
  Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function() {
    return withTimeout_js_1.withTimeout;
  } });
  var formatEther_js_1 = require_formatEther();
  Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
    return formatEther_js_1.formatEther;
  } });
  var formatGwei_js_1 = require_formatGwei();
  Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
    return formatGwei_js_1.formatGwei;
  } });
  var formatUnits_js_1 = require_formatUnits();
  Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
    return formatUnits_js_1.formatUnits;
  } });
  var fromHex_js_1 = require_fromHex();
  Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
    return fromHex_js_1.fromHex;
  } });
  Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
    return fromHex_js_1.hexToBigInt;
  } });
  Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
    return fromHex_js_1.hexToBool;
  } });
  Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
    return fromHex_js_1.hexToNumber;
  } });
  Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
    return fromHex_js_1.hexToString;
  } });
  var fromRlp_js_1 = require_fromRlp();
  Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
    return fromRlp_js_1.fromRlp;
  } });
  var getAddress_js_1 = require_getAddress();
  Object.defineProperty(exports, "checksumAddress", { enumerable: true, get: function() {
    return getAddress_js_1.checksumAddress;
  } });
  Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
    return getAddress_js_1.getAddress;
  } });
  var getContractError_js_1 = require_getContractError();
  Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
    return getContractError_js_1.getContractError;
  } });
  var toEventSelector_js_1 = require_toEventSelector();
  Object.defineProperty(exports, "toEventSelector", { enumerable: true, get: function() {
    return toEventSelector_js_1.toEventSelector;
  } });
  Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
    return toEventSelector_js_1.toEventSelector;
  } });
  var toFunctionSelector_js_1 = require_toFunctionSelector();
  Object.defineProperty(exports, "toFunctionSelector", { enumerable: true, get: function() {
    return toFunctionSelector_js_1.toFunctionSelector;
  } });
  Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
    return toFunctionSelector_js_1.toFunctionSelector;
  } });
  var toEventSignature_js_1 = require_toEventSignature();
  Object.defineProperty(exports, "toEventSignature", { enumerable: true, get: function() {
    return toEventSignature_js_1.toEventSignature;
  } });
  Object.defineProperty(exports, "getEventSignature", { enumerable: true, get: function() {
    return toEventSignature_js_1.toEventSignature;
  } });
  var toFunctionSignature_js_1 = require_toFunctionSignature();
  Object.defineProperty(exports, "toFunctionSignature", { enumerable: true, get: function() {
    return toFunctionSignature_js_1.toFunctionSignature;
  } });
  Object.defineProperty(exports, "getFunctionSignature", { enumerable: true, get: function() {
    return toFunctionSignature_js_1.toFunctionSignature;
  } });
  var toEventHash_js_1 = require_toEventHash();
  Object.defineProperty(exports, "toEventHash", { enumerable: true, get: function() {
    return toEventHash_js_1.toEventHash;
  } });
  var toFunctionHash_js_1 = require_toFunctionHash();
  Object.defineProperty(exports, "toFunctionHash", { enumerable: true, get: function() {
    return toFunctionHash_js_1.toFunctionHash;
  } });
  var hashMessage_js_1 = require_hashMessage();
  Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
    return hashMessage_js_1.hashMessage;
  } });
  var isAddress_js_1 = require_isAddress();
  Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
    return isAddress_js_1.isAddress;
  } });
  var isAddressEqual_js_1 = require_isAddressEqual();
  Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
    return isAddressEqual_js_1.isAddressEqual;
  } });
  var isBytes_js_1 = require_isBytes();
  Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
    return isBytes_js_1.isBytes;
  } });
  var isHash_js_1 = require_isHash();
  Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
    return isHash_js_1.isHash;
  } });
  var isHex_js_1 = require_isHex();
  Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
    return isHex_js_1.isHex;
  } });
  var keccak256_js_1 = require_keccak256();
  Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
    return keccak256_js_1.keccak256;
  } });
  var sha256_js_1 = require_sha2562();
  Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
    return sha256_js_1.sha256;
  } });
  var ripemd160_js_1 = require_ripemd1602();
  Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
    return ripemd160_js_1.ripemd160;
  } });
  var pad_js_1 = require_pad();
  Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
    return pad_js_1.pad;
  } });
  Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
    return pad_js_1.padBytes;
  } });
  Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
    return pad_js_1.padHex;
  } });
  var parseEther_js_1 = require_parseEther();
  Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
    return parseEther_js_1.parseEther;
  } });
  var parseGwei_js_1 = require_parseGwei();
  Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
    return parseGwei_js_1.parseGwei;
  } });
  var parseTransaction_js_1 = require_parseTransaction();
  Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
    return parseTransaction_js_1.parseTransaction;
  } });
  var parseUnits_js_1 = require_parseUnits();
  Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
    return parseUnits_js_1.parseUnits;
  } });
  var serializeAccessList_js_1 = require_serializeAccessList();
  Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
    return serializeAccessList_js_1.serializeAccessList;
  } });
  var serializeTransaction_js_1 = require_serializeTransaction();
  Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
    return serializeTransaction_js_1.serializeTransaction;
  } });
  var size_js_1 = require_size();
  Object.defineProperty(exports, "size", { enumerable: true, get: function() {
    return size_js_1.size;
  } });
  var slice_js_1 = require_slice();
  Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
    return slice_js_1.slice;
  } });
  Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
    return slice_js_1.sliceBytes;
  } });
  Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
    return slice_js_1.sliceHex;
  } });
  var stringify_js_1 = require_stringify();
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return stringify_js_1.stringify;
  } });
  var trim_js_1 = require_trim();
  Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
    return trim_js_1.trim;
  } });
  var typedData_js_1 = require_typedData();
  Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
    return typedData_js_1.validateTypedData;
  } });
  Object.defineProperty(exports, "domainSeparator", { enumerable: true, get: function() {
    return typedData_js_1.domainSeparator;
  } });
  Object.defineProperty(exports, "getTypesForEIP712Domain", { enumerable: true, get: function() {
    return typedData_js_1.getTypesForEIP712Domain;
  } });
});

// node_modules/viem/_cjs/utils/encoding/toRlp.js
var require_toRlp = __commonJS((exports) => {
  function toRlp(bytes2, to = "hex") {
    const encodable = getEncodable(bytes2);
    const cursor = (0, cursor_js_1.createCursor)(new Uint8Array(encodable.length));
    encodable.encode(cursor);
    if (to === "hex")
      return (0, toHex_js_1.bytesToHex)(cursor.bytes);
    return cursor.bytes;
  }
  function bytesToRlp(bytes2, to = "bytes") {
    return toRlp(bytes2, to);
  }
  function hexToRlp(hex, to = "hex") {
    return toRlp(hex, to);
  }
  function getEncodable(bytes2) {
    if (Array.isArray(bytes2))
      return getEncodableList(bytes2.map((x) => getEncodable(x)));
    return getEncodableBytes(bytes2);
  }
  function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length = (() => {
      if (bodyLength <= 55)
        return 1 + bodyLength;
      return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
      length,
      encode(cursor) {
        if (bodyLength <= 55) {
          cursor.pushByte(192 + bodyLength);
        } else {
          cursor.pushByte(192 + 55 + sizeOfBodyLength);
          if (sizeOfBodyLength === 1)
            cursor.pushUint8(bodyLength);
          else if (sizeOfBodyLength === 2)
            cursor.pushUint16(bodyLength);
          else if (sizeOfBodyLength === 3)
            cursor.pushUint24(bodyLength);
          else
            cursor.pushUint32(bodyLength);
        }
        for (const { encode } of list) {
          encode(cursor);
        }
      }
    };
  }
  function getEncodableBytes(bytesOrHex) {
    const bytes2 = typeof bytesOrHex === "string" ? (0, toBytes_js_1.hexToBytes)(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes2.length);
    const length = (() => {
      if (bytes2.length === 1 && bytes2[0] < 128)
        return 1;
      if (bytes2.length <= 55)
        return 1 + bytes2.length;
      return 1 + sizeOfBytesLength + bytes2.length;
    })();
    return {
      length,
      encode(cursor) {
        if (bytes2.length === 1 && bytes2[0] < 128) {
          cursor.pushBytes(bytes2);
        } else if (bytes2.length <= 55) {
          cursor.pushByte(128 + bytes2.length);
          cursor.pushBytes(bytes2);
        } else {
          cursor.pushByte(128 + 55 + sizeOfBytesLength);
          if (sizeOfBytesLength === 1)
            cursor.pushUint8(bytes2.length);
          else if (sizeOfBytesLength === 2)
            cursor.pushUint16(bytes2.length);
          else if (sizeOfBytesLength === 3)
            cursor.pushUint24(bytes2.length);
          else
            cursor.pushUint32(bytes2.length);
          cursor.pushBytes(bytes2);
        }
      }
    };
  }
  function getSizeOfLength(length) {
    if (length < 2 ** 8)
      return 1;
    if (length < 2 ** 16)
      return 2;
    if (length < 2 ** 24)
      return 3;
    if (length < 2 ** 32)
      return 4;
    throw new index_js_1.BaseError("Length is too large.");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToRlp = exports.bytesToRlp = exports.toRlp = undefined;
  var index_js_1 = require__cjs2();
  var cursor_js_1 = require_cursor2();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  exports.toRlp = toRlp;
  exports.bytesToRlp = bytesToRlp;
  exports.hexToRlp = hexToRlp;
});

// node_modules/viem/_cjs/op-stack/serializers.js
var require_serializers = __commonJS((exports) => {
  function serializeTransaction(transaction, signature) {
    if (isDeposit(transaction))
      return serializeTransactionDeposit(transaction);
    return (0, serializeTransaction_js_1.serializeTransaction)(transaction, signature);
  }
  function serializeTransactionDeposit(transaction) {
    assertTransactionDeposit(transaction);
    const { sourceHash, data, from, gas, isSystemTx, mint, to, value } = transaction;
    const serializedTransaction = [
      sourceHash,
      from,
      to ?? "0x",
      mint ? (0, toHex_js_1.toHex)(mint) : "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      isSystemTx ? "0x1" : "0x",
      data ?? "0x"
    ];
    return (0, concat_js_1.concatHex)([
      "0x7e",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function isDeposit(transaction) {
    if (transaction.type === "deposit")
      return true;
    if (typeof transaction.sourceHash !== "undefined")
      return true;
    return false;
  }
  function assertTransactionDeposit(transaction) {
    const { from, to } = transaction;
    if (from && !(0, isAddress_js_1.isAddress)(from))
      throw new address_js_1.InvalidAddressError({ address: from });
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertTransactionDeposit = exports.serializers = exports.serializeTransaction = undefined;
  var address_js_1 = require_address();
  var isAddress_js_1 = require_isAddress();
  var concat_js_1 = require_concat();
  var toHex_js_1 = require_toHex();
  var toRlp_js_1 = require_toRlp();
  var serializeTransaction_js_1 = require_serializeTransaction();
  exports.serializeTransaction = serializeTransaction;
  exports.serializers = {
    transaction: serializeTransaction
  };
  exports.assertTransactionDeposit = assertTransactionDeposit;
});

// node_modules/viem/_cjs/op-stack/chainConfig.js
var require_chainConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chainConfig = undefined;
  var contracts_js_1 = require_contracts();
  var formatters_js_1 = require_formatters();
  var serializers_js_1 = require_serializers();
  exports.chainConfig = {
    contracts: contracts_js_1.contracts,
    formatters: formatters_js_1.formatters,
    serializers: serializers_js_1.serializers
  };
});

// node_modules/viem/_cjs/chains/definitions/ancient8.js
var require_ancient8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ancient8 = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.ancient8 = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 888888888,
    name: "Ancient8",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.ancient8.gg"]
      }
    },
    blockExplorers: {
      default: {
        name: "Ancient8 explorer",
        url: "https://scan.ancient8.gg",
        apiUrl: "https://scan.ancient8.gg/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
        }
      },
      portal: {
        [sourceId]: {
          address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
          blockCreated: 19070571
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
          blockCreated: 19070571
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/ancient8Sepolia.js
var require_ancient8Sepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ancient8Sepolia = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.ancient8Sepolia = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 28122024,
    name: "Ancient8 Testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpcv2-testnet.ancient8.gg"]
      }
    },
    blockExplorers: {
      default: {
        name: "Ancient8 Celestia Testnet explorer",
        url: "https://scanv2-testnet.ancient8.gg",
        apiUrl: "https://scanv2-testnet.ancient8.gg/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
        }
      },
      portal: {
        [sourceId]: {
          address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
          blockCreated: 4972908
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
          blockCreated: 4972908
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/anvil.js
var require_anvil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.anvil = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.anvil = (0, defineChain_js_1.defineChain)({
    id: 31337,
    name: "Anvil",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["http://127.0.0.1:8545"],
        webSocket: ["ws://127.0.0.1:8545"]
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/apexTestnet.js
var require_apexTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.apexTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.apexTestnet = (0, defineChain_js_1.defineChain)({
    id: 3993,
    name: "APEX Testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc-testnet.apexlayer.xyz"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://exp-testnet.apexlayer.xyz",
        apiUrl: "https://exp-testnet.apexlayer.xyz/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
        blockCreated: 283775
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/arbitrum.js
var require_arbitrum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arbitrum = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.arbitrum = (0, defineChain_js_1.defineChain)({
    id: 42161,
    name: "Arbitrum One",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://arb1.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Arbiscan",
        url: "https://arbiscan.io",
        apiUrl: "https://api.arbiscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7654707
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js
var require_arbitrumGoerli = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arbitrumGoerli = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.arbitrumGoerli = (0, defineChain_js_1.defineChain)({
    id: 421613,
    name: "Arbitrum Goerli",
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Arbiscan",
        url: "https://goerli.arbiscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 88114
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/arbitrumNova.js
var require_arbitrumNova = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arbitrumNova = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.arbitrumNova = (0, defineChain_js_1.defineChain)({
    id: 42170,
    name: "Arbitrum Nova",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://nova.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Arbiscan",
        url: "https://nova.arbiscan.io",
        apiUrl: "https://api-nova.arbiscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1746963
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/astar.js
var require_astar = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.astar = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.astar = (0, defineChain_js_1.defineChain)({
    id: 592,
    name: "Astar",
    network: "astar-mainnet",
    nativeCurrency: {
      name: "Astar",
      symbol: "ASTR",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://astar.api.onfinality.io/public"] }
    },
    blockExplorers: {
      default: {
        name: "Astar Subscan",
        url: "https://astar.subscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 761794
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/astarZkEVM.js
var require_astarZkEVM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.astarZkEVM = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.astarZkEVM = (0, defineChain_js_1.defineChain)({
    id: 3776,
    name: "Astar zkEVM",
    network: "AstarZkEVM",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.startale.com/astar-zkevm"]
      }
    },
    blockExplorers: {
      default: {
        name: "Astar zkEVM Explorer",
        url: "https://astar-zkevm.explorer.startale.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 93528
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/astarZkyoto.js
var require_astarZkyoto = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.astarZkyoto = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.astarZkyoto = (0, defineChain_js_1.defineChain)({
    id: 6038361,
    name: "Astar zkEVM Testnet zKyoto",
    network: "zKyoto",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.startale.com/zkyoto"]
      }
    },
    blockExplorers: {
      default: {
        name: "zKyoto Explorer",
        url: "https://zkyoto.explorer.startale.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 196153
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/arbitrumSepolia.js
var require_arbitrumSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arbitrumSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.arbitrumSepolia = (0, defineChain_js_1.defineChain)({
    id: 421614,
    name: "Arbitrum Sepolia",
    nativeCurrency: {
      name: "Arbitrum Sepolia Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://sepolia-rollup.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Arbiscan",
        url: "https://sepolia.arbiscan.io",
        apiUrl: "https://api-sepolia.arbiscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 81930
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/areonNetwork.js
var require_areonNetwork = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.areonNetwork = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.areonNetwork = (0, defineChain_js_1.defineChain)({
    id: 463,
    name: "Areon Network",
    nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
    rpcUrls: {
      default: {
        http: ["https://mainnet-rpc.areon.network"],
        webSocket: ["wss://mainnet-ws.areon.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Areonscan",
        url: "https://areonscan.com"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/areonNetworkTestnet.js
var require_areonNetworkTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.areonNetworkTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.areonNetworkTestnet = (0, defineChain_js_1.defineChain)({
    id: 462,
    name: "Areon Network Testnet",
    nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
    rpcUrls: {
      default: {
        http: ["https://testnet-rpc.areon.network"],
        webSocket: ["wss://testnet-ws.areon.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Areonscan",
        url: "https://areonscan.com"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/aurora.js
var require_aurora = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aurora = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.aurora = (0, defineChain_js_1.defineChain)({
    id: 1313161554,
    name: "Aurora",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["https://mainnet.aurora.dev"] }
    },
    blockExplorers: {
      default: {
        name: "Aurorascan",
        url: "https://aurorascan.dev",
        apiUrl: "https://aurorascan.dev/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 62907816
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/auroraTestnet.js
var require_auroraTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auroraTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.auroraTestnet = (0, defineChain_js_1.defineChain)({
    id: 1313161555,
    name: "Aurora Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["https://testnet.aurora.dev"] }
    },
    blockExplorers: {
      default: {
        name: "Aurorascan",
        url: "https://testnet.aurorascan.dev",
        apiUrl: "https://testnet.aurorascan.dev/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/auroria.js
var require_auroria = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auroria = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.auroria = (0, defineChain_js_1.defineChain)({
    id: 205205,
    name: "Auroria Testnet",
    network: "auroria",
    nativeCurrency: {
      name: "Auroria Stratis",
      symbol: "tSTRAX",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://auroria.rpc.stratisevm.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Auroria Testnet Explorer",
        url: "https://auroria.explorer.stratisevm.com"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/avalanche.js
var require_avalanche = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.avalanche = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.avalanche = (0, defineChain_js_1.defineChain)({
    id: 43114,
    name: "Avalanche",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "SnowScan",
        url: "https://snowscan.xyz",
        apiUrl: "https://api.snowscan.xyz/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 11907934
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/avalancheFuji.js
var require_avalancheFuji = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.avalancheFuji = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.avalancheFuji = (0, defineChain_js_1.defineChain)({
    id: 43113,
    name: "Avalanche Fuji",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche Fuji",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "SnowScan",
        url: "https://testnet.snowscan.xyz",
        apiUrl: "https://api-testnet.snowscan.xyz"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7096959
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/bahamut.js
var require_bahamut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bahamut = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bahamut = (0, defineChain_js_1.defineChain)({
    id: 5165,
    network: "bahamut",
    name: "Bahamut",
    nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://rpc1.bahamut.io",
          "https://bahamut-rpc.publicnode.com",
          "https://rpc2.bahamut.io"
        ],
        webSocket: [
          "wss://ws1.sahara.bahamutchain.com",
          "wss://bahamut-rpc.publicnode.com",
          "wss://ws2.sahara.bahamutchain.com"
        ]
      },
      public: {
        http: [
          "https://rpc1.bahamut.io",
          "https://bahamut-rpc.publicnode.com",
          "https://rpc2.bahamut.io"
        ],
        webSocket: [
          "wss://ws1.sahara.bahamutchain.com",
          "wss://bahamut-rpc.publicnode.com",
          "wss://ws2.sahara.bahamutchain.com"
        ]
      }
    },
    blockExplorers: {
      default: {
        name: "Ftnscan",
        url: "https://www.ftnscan.com",
        apiUrl: "https://www.ftnscan.com/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/base.js
var require_base2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.base = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.base = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 8453,
    name: "Base",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.base.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Basescan",
        url: "https://basescan.org",
        apiUrl: "https://api.basescan.org/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x56315b90c40730925ec5485cf004d835058518A0"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 5022
      },
      portal: {
        [sourceId]: {
          address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
          blockCreated: 17482143
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
          blockCreated: 17482143
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/baseGoerli.js
var require_baseGoerli = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baseGoerli = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 5;
  exports.baseGoerli = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 84531,
    name: "Base Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://goerli.base.org"] }
    },
    blockExplorers: {
      default: {
        name: "Basescan",
        url: "https://goerli.basescan.org",
        apiUrl: "https://goerli.basescan.org/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1376988
      },
      portal: {
        [sourceId]: {
          address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
        }
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/baseSepolia.js
var require_baseSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baseSepolia = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.baseSepolia = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 84532,
    network: "base-sepolia",
    name: "Base Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.base.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Basescan",
        url: "https://sepolia.basescan.org",
        apiUrl: "https://api-sepolia.basescan.org/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
        }
      },
      portal: {
        [sourceId]: {
          address: "0x49f53e41452c74589e85ca1677426ba426459e85",
          blockCreated: 4446677
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
          blockCreated: 4446677
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1059647
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/beam.js
var require_beam = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.beam = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.beam = (0, defineChain_js_1.defineChain)({
    id: 4337,
    name: "Beam",
    network: "beam",
    nativeCurrency: {
      decimals: 18,
      name: "Beam",
      symbol: "BEAM"
    },
    rpcUrls: {
      public: {
        http: ["https://build.onbeam.com/rpc"],
        webSocket: ["wss://build.onbeam.com/ws"]
      },
      default: {
        http: ["https://build.onbeam.com/rpc"],
        webSocket: ["wss://build.onbeam.com/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Beam Explorer",
        url: "https://subnets.avax.network/beam"
      }
    },
    contracts: {
      multicall3: {
        address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
        blockCreated: 1
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/beamTestnet.js
var require_beamTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.beamTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.beamTestnet = (0, defineChain_js_1.defineChain)({
    id: 13337,
    name: "Beam Testnet",
    network: "beam",
    nativeCurrency: {
      decimals: 18,
      name: "Beam",
      symbol: "BEAM"
    },
    rpcUrls: {
      public: {
        http: ["https://build.onbeam.com/rpc/testnet"],
        webSocket: ["wss://build.onbeam.com/ws/testnet"]
      },
      default: {
        http: ["https://build.onbeam.com/rpc/testnet"],
        webSocket: ["wss://build.onbeam.com/ws/testnet"]
      }
    },
    blockExplorers: {
      default: {
        name: "Beam Explorer",
        url: "https://subnets-test.avax.network/beam"
      }
    },
    contracts: {
      multicall3: {
        address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
        blockCreated: 3
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js
var require_bearNetworkChainMainnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearNetworkChainMainnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bearNetworkChainMainnet = (0, defineChain_js_1.defineChain)({
    id: 641230,
    name: "Bear Network Chain Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "BearNetworkChain",
      symbol: "BRNKC"
    },
    rpcUrls: {
      default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
    },
    blockExplorers: {
      default: {
        name: "BrnkScan",
        url: "https://brnkscan.bearnetwork.net",
        apiUrl: "https://brnkscan.bearnetwork.net/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js
var require_bearNetworkChainTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearNetworkChainTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bearNetworkChainTestnet = (0, defineChain_js_1.defineChain)({
    id: 751230,
    name: "Bear Network Chain Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "tBRNKC",
      symbol: "tBRNKC"
    },
    rpcUrls: {
      default: { http: ["https://brnkc-test.bearnetwork.net"] }
    },
    blockExplorers: {
      default: {
        name: "BrnkTestScan",
        url: "https://brnktest-scan.bearnetwork.net",
        apiUrl: "https://brnktest-scan.bearnetwork.net/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/berachainTestnet.js
var require_berachainTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.berachainTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.berachainTestnet = (0, defineChain_js_1.defineChain)({
    id: 80085,
    name: "Berachain Artio",
    nativeCurrency: {
      decimals: 18,
      name: "BERA Token",
      symbol: "BERA"
    },
    rpcUrls: {
      default: { http: ["https://artio.rpc.berachain.com"] }
    },
    blockExplorers: {
      default: {
        name: "Berachain",
        url: "https://artio.beratrail.io"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/bevmMainnet.js
var require_bevmMainnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bevmMainnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bevmMainnet = (0, defineChain_js_1.defineChain)({
    id: 11501,
    name: "BEVM Mainnet",
    nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://rpc-mainnet-1.bevm.io"] }
    },
    blockExplorers: {
      default: {
        name: "Bevmscan",
        url: "https://scan-mainnet.bevm.io",
        apiUrl: "https://scan-mainnet-api.bevm.io/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/bitTorrent.js
var require_bitTorrent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bitTorrent = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bitTorrent = (0, defineChain_js_1.defineChain)({
    id: 199,
    name: "BitTorrent",
    network: "bittorrent-chain-mainnet",
    nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://rpc.bittorrentchain.io"] },
      public: { http: ["https://rpc.bittorrentchain.io"] }
    },
    blockExplorers: {
      default: {
        name: "Bttcscan",
        url: "https://bttcscan.com",
        apiUrl: "https://api.bttcscan.com/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/bitTorrentTestnet.js
var require_bitTorrentTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bitTorrentTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bitTorrentTestnet = (0, defineChain_js_1.defineChain)({
    id: 1028,
    name: "BitTorrent Chain Testnet",
    network: "bittorrent-chain-testnet",
    nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://testrpc.bittorrentchain.io"] },
      public: { http: ["https://testrpc.bittorrentchain.io"] }
    },
    blockExplorers: {
      default: {
        name: "Bttcscan",
        url: "https://testnet.bttcscan.com",
        apiUrl: "https://testnet.bttcscan.com/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/blast.js
var require_blast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.blast = undefined;
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.blast = (0, defineChain_js_1.defineChain)({
    id: 81457,
    name: "Blast",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["https://rpc.blast.io"] }
    },
    blockExplorers: {
      default: {
        name: "Blastscan",
        url: "https://blastscan.io",
        apiUrl: "https://api.blastscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 212929
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/blastSepolia.js
var require_blastSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.blastSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.blastSepolia = (0, defineChain_js_1.defineChain)({
    id: 168587773,
    name: "Blast Sepolia",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://sepolia.blast.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blastscan",
        url: "https://sepolia.blastscan.io",
        apiUrl: "https://api-sepolia.blastscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 756690
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/boba.js
var require_boba = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boba = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.boba = (0, defineChain_js_1.defineChain)({
    id: 288,
    name: "Boba Network",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["https://mainnet.boba.network"] }
    },
    blockExplorers: {
      default: {
        name: "BOBAScan",
        url: "https://bobascan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 446859
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/bronos.js
var require_bronos = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bronos = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bronos = (0, defineChain_js_1.defineChain)({
    id: 1039,
    name: "Bronos",
    nativeCurrency: {
      decimals: 18,
      name: "BRO",
      symbol: "BRO"
    },
    rpcUrls: {
      default: { http: ["https://evm.bronos.org"] }
    },
    blockExplorers: {
      default: {
        name: "BronoScan",
        url: "https://broscan.bronos.org"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/bronosTestnet.js
var require_bronosTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bronosTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bronosTestnet = (0, defineChain_js_1.defineChain)({
    id: 1038,
    name: "Bronos Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Bronos Coin",
      symbol: "tBRO"
    },
    rpcUrls: {
      default: { http: ["https://evm-testnet.bronos.org"] }
    },
    blockExplorers: {
      default: {
        name: "BronoScan",
        url: "https://tbroscan.bronos.org"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/bsc.js
var require_bsc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bsc = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bsc = (0, defineChain_js_1.defineChain)({
    id: 56,
    name: "BNB Smart Chain",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "BNB"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/bsc"] }
    },
    blockExplorers: {
      default: {
        name: "BscScan",
        url: "https://bscscan.com",
        apiUrl: "https://api.bscscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 15921452
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/bscTestnet.js
var require_bscTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bscTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bscTestnet = (0, defineChain_js_1.defineChain)({
    id: 97,
    name: "Binance Smart Chain Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "tBNB"
    },
    rpcUrls: {
      default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
    },
    blockExplorers: {
      default: {
        name: "BscScan",
        url: "https://testnet.bscscan.com",
        apiUrl: "https://testnet.bscscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 17422483
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/bscGreenfield.js
var require_bscGreenfield = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bscGreenfield = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bscGreenfield = (0, defineChain_js_1.defineChain)({
    id: 1017,
    name: "BNB Greenfield Chain",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "BNB"
    },
    rpcUrls: {
      default: { http: ["https://greenfield-chain.bnbchain.org"] }
    },
    blockExplorers: {
      default: {
        name: "BNB Greenfield Mainnet Scan",
        url: "https://greenfieldscan.com"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/bxn.js
var require_bxn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bxn = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bxn = (0, defineChain_js_1.defineChain)({
    id: 4999,
    name: "BlackFort Exchange Network",
    nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.blackfort.network/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://explorer.blackfort.network",
        apiUrl: "https://explorer.blackfort.network/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/bxnTestnet.js
var require_bxnTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bxnTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.bxnTestnet = (0, defineChain_js_1.defineChain)({
    id: 4777,
    name: "BlackFort Exchange Network Testnet",
    nativeCurrency: {
      name: "BlackFort Testnet Token",
      symbol: "TBXN",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://testnet.blackfort.network/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://testnet-explorer.blackfort.network",
        apiUrl: "https://testnet-explorer.blackfort.network/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/canto.js
var require_canto = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.canto = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.canto = (0, defineChain_js_1.defineChain)({
    id: 7700,
    name: "Canto",
    nativeCurrency: {
      decimals: 18,
      name: "Canto",
      symbol: "CANTO"
    },
    rpcUrls: {
      default: { http: ["https://canto.gravitychain.io"] }
    },
    blockExplorers: {
      default: {
        name: "Tuber.Build (Blockscout)",
        url: "https://tuber.build"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 2905789
      }
    }
  });
});

// node_modules/viem/_cjs/celo/fees.js
var require_fees = __commonJS((exports) => {
  async function estimateFeePerGasInFeeCurrency(client, feeCurrency) {
    const fee = await client.request({
      method: "eth_gasPrice",
      params: [feeCurrency]
    });
    return BigInt(fee);
  }
  async function estimateMaxPriorityFeePerGasInFeeCurrency(client, feeCurrency) {
    const feesPerGas = await client.request({
      method: "eth_maxPriorityFeePerGas",
      params: [feeCurrency]
    });
    return BigInt(feesPerGas);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fees = undefined;
  exports.fees = {
    estimateFeesPerGas: async (params) => {
      if (!params.request?.feeCurrency)
        return null;
      const [maxFeePerGas, maxPriorityFeePerGas] = await Promise.all([
        estimateFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),
        estimateMaxPriorityFeePerGasInFeeCurrency(params.client, params.request.feeCurrency)
      ]);
      return {
        maxFeePerGas,
        maxPriorityFeePerGas
      };
    }
  };
});

// node_modules/viem/_cjs/celo/utils.js
var require_utils8 = __commonJS((exports) => {
  function isEmpty(value) {
    return value === 0 || value === 0n || value === undefined || value === null || value === "0" || value === "" || typeof value === "string" && ((0, trim_js_1.trim)(value).toLowerCase() === "0x" || (0, trim_js_1.trim)(value).toLowerCase() === "0x00");
  }
  function isPresent(value) {
    return !isEmpty(value);
  }
  function isEIP1559(transaction) {
    return typeof transaction.maxFeePerGas !== "undefined" && typeof transaction.maxPriorityFeePerGas !== "undefined";
  }
  function isCIP42(transaction) {
    if (transaction.type === "cip42") {
      return true;
    }
    return isEIP1559(transaction) && (isPresent(transaction.feeCurrency) || isPresent(transaction.gatewayFeeRecipient) || isPresent(transaction.gatewayFee));
  }
  function isCIP64(transaction) {
    if (transaction.type === "cip64") {
      return true;
    }
    return isEIP1559(transaction) && isPresent(transaction.feeCurrency) && isEmpty(transaction.gatewayFee) && isEmpty(transaction.gatewayFeeRecipient);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCIP64 = exports.isCIP42 = exports.isEIP1559 = exports.isPresent = exports.isEmpty = undefined;
  var trim_js_1 = require_trim();
  exports.isEmpty = isEmpty;
  exports.isPresent = isPresent;
  exports.isEIP1559 = isEIP1559;
  exports.isCIP42 = isCIP42;
  exports.isCIP64 = isCIP64;
});

// node_modules/viem/_cjs/celo/formatters.js
var require_formatters2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatters = undefined;
  var fromHex_js_1 = require_fromHex();
  var toHex_js_1 = require_toHex();
  var block_js_1 = require_block();
  var transaction_js_1 = require_transaction();
  var transactionRequest_js_1 = require_transactionRequest();
  var utils_js_1 = require_utils8();
  exports.formatters = {
    block: (0, block_js_1.defineBlock)({
      exclude: ["difficulty", "gasLimit", "mixHash", "nonce", "uncles"],
      format(args) {
        const transactions = args.transactions?.map((transaction) => {
          if (typeof transaction === "string")
            return transaction;
          return {
            ...(0, transaction_js_1.formatTransaction)(transaction),
            feeCurrency: transaction.feeCurrency,
            ...transaction.type !== "0x7b" ? {
              gatewayFee: transaction.gatewayFee ? (0, fromHex_js_1.hexToBigInt)(transaction.gatewayFee) : null,
              gatewayFeeRecipient: transaction.gatewayFeeRecipient || null
            } : {}
          };
        });
        return {
          randomness: args.randomness,
          transactions
        };
      }
    }),
    transaction: (0, transaction_js_1.defineTransaction)({
      format(args) {
        const transaction = { feeCurrency: args.feeCurrency };
        if (args.type === "0x7b")
          transaction.type = "cip64";
        else {
          if (args.type === "0x7c")
            transaction.type = "cip42";
          transaction.gatewayFee = args.gatewayFee ? (0, fromHex_js_1.hexToBigInt)(args.gatewayFee) : null;
          transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
        }
        return transaction;
      }
    }),
    transactionRequest: (0, transactionRequest_js_1.defineTransactionRequest)({
      format(args) {
        const request = {
          feeCurrency: args.feeCurrency
        };
        if ((0, utils_js_1.isCIP64)(args))
          request.type = "0x7b";
        else {
          if ((0, utils_js_1.isCIP42)(args))
            request.type = "0x7c";
          request.gatewayFee = typeof args.gatewayFee !== "undefined" ? (0, toHex_js_1.numberToHex)(args.gatewayFee) : undefined;
          request.gatewayFeeRecipient = args.gatewayFeeRecipient;
        }
        return request;
      }
    })
  };
});

// node_modules/viem/_cjs/celo/serializers.js
var require_serializers2 = __commonJS((exports) => {
  function serializeTransaction(transaction, signature) {
    if ((0, utils_js_1.isCIP64)(transaction))
      return serializeTransactionCIP64(transaction, signature);
    if ((0, utils_js_1.isCIP42)(transaction))
      return serializeTransactionCIP42(transaction, signature);
    return (0, serializeTransaction_js_1.serializeTransaction)(transaction, signature);
  }
  function serializeTransactionCIP42(transaction, signature) {
    assertTransactionCIP42(transaction);
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, gatewayFeeRecipient, gatewayFee, data } = transaction;
    const serializedTransaction = [
      (0, toHex_js_1.toHex)(chainId),
      nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
      maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      feeCurrency ?? "0x",
      gatewayFeeRecipient ?? "0x",
      gatewayFee ? (0, toHex_js_1.toHex)(gatewayFee) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      data ?? "0x",
      (0, serializeAccessList_js_1.serializeAccessList)(accessList),
      ...(0, serializeTransaction_js_1.toYParitySignatureArray)(transaction, signature)
    ];
    return (0, concat_js_1.concatHex)([
      "0x7c",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function serializeTransactionCIP64(transaction, signature) {
    assertTransactionCIP64(transaction);
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
    const serializedTransaction = [
      (0, toHex_js_1.toHex)(chainId),
      nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
      maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      data ?? "0x",
      (0, serializeAccessList_js_1.serializeAccessList)(accessList),
      feeCurrency,
      ...(0, serializeTransaction_js_1.toYParitySignatureArray)(transaction, signature)
    ];
    return (0, concat_js_1.concatHex)([
      "0x7b",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function assertTransactionCIP42(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency, gatewayFee, gatewayFeeRecipient } = transaction;
    if (chainId <= 0)
      throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
    if (gasPrice)
      throw new base_js_1.BaseError("`gasPrice` is not a valid CIP-42 Transaction attribute.");
    if ((0, utils_js_1.isPresent)(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
      throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if ((0, utils_js_1.isPresent)(maxPriorityFeePerGas) && (0, utils_js_1.isPresent)(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
      throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    if ((0, utils_js_1.isPresent)(gatewayFee) && (0, utils_js_1.isEmpty)(gatewayFeeRecipient) || (0, utils_js_1.isPresent)(gatewayFeeRecipient) && (0, utils_js_1.isEmpty)(gatewayFee)) {
      throw new base_js_1.BaseError("`gatewayFee` and `gatewayFeeRecipient` must be provided together.");
    }
    if ((0, utils_js_1.isPresent)(feeCurrency) && !(0, isAddress_js_1.isAddress)(feeCurrency)) {
      throw new base_js_1.BaseError("`feeCurrency` MUST be a token address for CIP-42 transactions.");
    }
    if ((0, utils_js_1.isPresent)(gatewayFeeRecipient) && !(0, isAddress_js_1.isAddress)(gatewayFeeRecipient)) {
      throw new address_js_1.InvalidAddressError(gatewayFeeRecipient);
    }
    if ((0, utils_js_1.isEmpty)(feeCurrency) && (0, utils_js_1.isEmpty)(gatewayFeeRecipient)) {
      throw new base_js_1.BaseError("Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.");
    }
  }
  function assertTransactionCIP64(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency } = transaction;
    if (chainId <= 0)
      throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
    if (gasPrice)
      throw new base_js_1.BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
    if ((0, utils_js_1.isPresent)(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
      throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if ((0, utils_js_1.isPresent)(maxPriorityFeePerGas) && (0, utils_js_1.isPresent)(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
      throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    if ((0, utils_js_1.isPresent)(feeCurrency) && !(0, isAddress_js_1.isAddress)(feeCurrency)) {
      throw new base_js_1.BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
    }
    if ((0, utils_js_1.isEmpty)(feeCurrency)) {
      throw new base_js_1.BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertTransactionCIP64 = exports.assertTransactionCIP42 = exports.serializers = exports.serializeTransaction = undefined;
  var address_js_1 = require_address();
  var base_js_1 = require_base();
  var chain_js_1 = require_chain();
  var node_js_1 = require_node();
  var isAddress_js_1 = require_isAddress();
  var concat_js_1 = require_concat();
  var toHex_js_1 = require_toHex();
  var toRlp_js_1 = require_toRlp();
  var serializeAccessList_js_1 = require_serializeAccessList();
  var serializeTransaction_js_1 = require_serializeTransaction();
  var utils_js_1 = require_utils8();
  exports.serializeTransaction = serializeTransaction;
  exports.serializers = {
    transaction: serializeTransaction
  };
  var MAX_MAX_FEE_PER_GAS = 2n ** 256n - 1n;
  exports.assertTransactionCIP42 = assertTransactionCIP42;
  exports.assertTransactionCIP64 = assertTransactionCIP64;
});

// node_modules/viem/_cjs/celo/chainConfig.js
var require_chainConfig2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chainConfig = undefined;
  var fees_js_1 = require_fees();
  var formatters_js_1 = require_formatters2();
  var serializers_js_1 = require_serializers2();
  exports.chainConfig = {
    formatters: formatters_js_1.formatters,
    serializers: serializers_js_1.serializers,
    fees: fees_js_1.fees
  };
});

// node_modules/viem/_cjs/chains/definitions/celo.js
var require_celo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.celo = undefined;
  var chainConfig_js_1 = require_chainConfig2();
  var defineChain_js_1 = require_defineChain();
  exports.celo = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 42220,
    name: "Celo",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "CELO"
    },
    rpcUrls: {
      default: { http: ["https://forno.celo.org"] }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/mainnet",
        apiUrl: "https://explorer.celo.org/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 13112599
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/celoAlfajores.js
var require_celoAlfajores = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.celoAlfajores = undefined;
  var chainConfig_js_1 = require_chainConfig2();
  var defineChain_js_1 = require_defineChain();
  exports.celoAlfajores = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 44787,
    name: "Alfajores",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "A-CELO"
    },
    rpcUrls: {
      default: {
        http: ["https://alfajores-forno.celo-testnet.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/alfajores",
        apiUrl: "https://explorer.celo.org/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 14569001
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/chiliz.js
var require_chiliz = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chiliz = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.chiliz = (0, defineChain_js_1.defineChain)({
    id: 88888,
    name: "Chiliz Chain",
    network: "chiliz-chain",
    nativeCurrency: {
      decimals: 18,
      name: "CHZ",
      symbol: "CHZ"
    },
    rpcUrls: {
      default: {
        http: [
          "https://rpc.ankr.com/chiliz",
          "https://chiliz-rpc.publicnode.com"
        ]
      }
    },
    blockExplorers: {
      default: {
        name: "Chiliz Explorer",
        url: "https://scan.chiliz.com",
        apiUrl: "https://scan.chiliz.com/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/classic.js
var require_classic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.classic = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.classic = (0, defineChain_js_1.defineChain)({
    id: 61,
    name: "Ethereum Classic",
    nativeCurrency: {
      decimals: 18,
      name: "ETC",
      symbol: "ETC"
    },
    rpcUrls: {
      default: { http: ["https://etc.rivet.link"] }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://blockscout.com/etc/mainnet"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/confluxESpace.js
var require_confluxESpace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.confluxESpace = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.confluxESpace = (0, defineChain_js_1.defineChain)({
    id: 1030,
    name: "Conflux eSpace",
    nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://evm.confluxrpc.org"],
        webSocket: ["wss://evm.confluxrpc.org/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "ConfluxScan",
        url: "https://evm.confluxscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
        blockCreated: 68602935
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/confluxESpaceTestnet.js
var require_confluxESpaceTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.confluxESpaceTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.confluxESpaceTestnet = (0, defineChain_js_1.defineChain)({
    id: 71,
    name: "Conflux eSpace Testnet",
    network: "cfx-espace-testnet",
    testnet: true,
    nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://evmtestnet.confluxrpc.org"],
        webSocket: ["wss://evmtestnet.confluxrpc.org/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "ConfluxScan",
        url: "https://evmtestnet.confluxscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
        blockCreated: 117499050
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/coreDao.js
var require_coreDao = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.coreDao = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.coreDao = (0, defineChain_js_1.defineChain)({
    id: 1116,
    name: "Core Dao",
    nativeCurrency: {
      decimals: 18,
      name: "Core",
      symbol: "CORE"
    },
    rpcUrls: {
      default: { http: ["https://rpc.coredao.org"] }
    },
    blockExplorers: {
      default: {
        name: "CoreDao",
        url: "https://scan.coredao.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 11907934
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/cronos.js
var require_cronos = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cronos = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.cronos = (0, defineChain_js_1.defineChain)({
    id: 25,
    name: "Cronos Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Cronos",
      symbol: "CRO"
    },
    rpcUrls: {
      default: { http: ["https://evm.cronos.org"] }
    },
    blockExplorers: {
      default: {
        name: "Cronos Explorer",
        url: "https://explorer.cronos.org",
        apiUrl: "https://explorer-api.cronos.org/mainnet/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1963112
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/cronosTestnet.js
var require_cronosTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cronosTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.cronosTestnet = (0, defineChain_js_1.defineChain)({
    id: 338,
    name: "Cronos Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "CRO",
      symbol: "tCRO"
    },
    rpcUrls: {
      default: { http: ["https://evm-t3.cronos.org"] }
    },
    blockExplorers: {
      default: {
        name: "Cronos Explorer",
        url: "https://cronos.org/explorer/testnet3"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 10191251
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/crossbell.js
var require_crossbell = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crossbell = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.crossbell = (0, defineChain_js_1.defineChain)({
    id: 3737,
    name: "Crossbell",
    nativeCurrency: {
      decimals: 18,
      name: "CSB",
      symbol: "CSB"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.crossbell.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "CrossScan",
        url: "https://scan.crossbell.io",
        apiUrl: "https://scan.crossbell.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 38246031
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/darwinia.js
var require_darwinia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.darwinia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.darwinia = (0, defineChain_js_1.defineChain)({
    id: 46,
    name: "Darwinia Network",
    nativeCurrency: {
      decimals: 18,
      name: "RING",
      symbol: "RING"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.darwinia.network"],
        webSocket: ["wss://rpc.darwinia.network"]
      }
    },
    blockExplorers: {
      default: { name: "Explorer", url: "https://darwinia.subscan.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 69420
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/defichainEvm.js
var require_defichainEvm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defichainEvm = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.defichainEvm = (0, defineChain_js_1.defineChain)({
    id: 1130,
    network: "defichain-evm",
    name: "DeFiChain EVM Mainnet",
    nativeCurrency: {
      name: "DeFiChain",
      symbol: "DFI",
      decimals: 8
    },
    rpcUrls: {
      default: {
        http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
      },
      public: {
        http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "DeFiScan",
        url: "https://meta.defiscan.live"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 137852
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/defichainEvmTestnet.js
var require_defichainEvmTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defichainEvmTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.defichainEvmTestnet = (0, defineChain_js_1.defineChain)({
    id: 1131,
    network: "defichain-evm-testnet",
    name: "DeFiChain EVM Testnet",
    nativeCurrency: {
      name: "DeFiChain",
      symbol: "DFI",
      decimals: 8
    },
    rpcUrls: {
      default: {
        http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
      },
      public: {
        http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "DeFiScan",
        url: "https://meta.defiscan.live/?network=TestNet"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 156462
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/degen.js
var require_degen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.degen = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.degen = (0, defineChain_js_1.defineChain)({
    id: 666666666,
    name: "Degen",
    nativeCurrency: {
      decimals: 18,
      name: "Degen",
      symbol: "DEGEN"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.degen.tips"],
        webSocket: ["wss://rpc.degen.tips"]
      }
    },
    blockExplorers: {
      default: {
        name: "Degen Chain Explorer",
        url: "https://explorer.degen.tips",
        apiUrl: "https://explorer.degen.tips/api/v2"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/dfk.js
var require_dfk = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dfk = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.dfk = (0, defineChain_js_1.defineChain)({
    id: 53935,
    name: "DFK Chain",
    nativeCurrency: {
      decimals: 18,
      name: "Jewel",
      symbol: "JEWEL"
    },
    rpcUrls: {
      default: {
        http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "DFKSubnetScan",
        url: "https://subnets.avax.network/defi-kingdoms"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14790551
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/dogechain.js
var require_dogechain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dogechain = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.dogechain = (0, defineChain_js_1.defineChain)({
    id: 2000,
    name: "Dogechain",
    nativeCurrency: {
      decimals: 18,
      name: "Dogechain",
      symbol: "DC"
    },
    rpcUrls: {
      default: { http: ["https://rpc.dogechain.dog"] }
    },
    blockExplorers: {
      default: {
        name: "DogeChainExplorer",
        url: "https://explorer.dogechain.dog",
        apiUrl: "https://explorer.dogechain.dog/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/edgeless.js
var require_edgeless = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.edgeless = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.edgeless = (0, defineChain_js_1.defineChain)({
    id: 2026,
    name: "Edgeless Network",
    nativeCurrency: {
      name: "Edgeless Wrapped ETH",
      symbol: "EwETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.edgeless.network/http"],
        webSocket: ["wss://rpc.edgeless.network/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Edgeless Explorer",
        url: "https://explorer.edgeless.network"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/edgelessTestnet.js
var require_edgelessTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.edgelessTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.edgelessTestnet = (0, defineChain_js_1.defineChain)({
    id: 202,
    name: "Edgeless Testnet",
    nativeCurrency: {
      name: "Edgeless Wrapped ETH",
      symbol: "EwETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
        webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Edgeless Testnet Explorer",
        url: "https://testnet.explorer.edgeless.network"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/edgeware.js
var require_edgeware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.edgeware = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.edgeware = (0, defineChain_js_1.defineChain)({
    id: 2021,
    name: "Edgeware EdgeEVM Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Edgeware",
      symbol: "EDG"
    },
    rpcUrls: {
      default: { http: ["https://edgeware-evm.jelliedowl.net"] }
    },
    blockExplorers: {
      default: {
        name: "Edgscan by Bharathcoorg",
        url: "https://edgscan.live",
        apiUrl: "https://edgscan.live/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 18117872
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js
var require_edgewareTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.edgewareTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.edgewareTestnet = (0, defineChain_js_1.defineChain)({
    id: 2022,
    name: "Beresheet BereEVM Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Testnet EDG",
      symbol: "tEDG"
    },
    rpcUrls: {
      default: { http: ["https://beresheet-evm.jelliedowl.net"] }
    },
    blockExplorers: {
      default: {
        name: "Edgscan by Bharathcoorg",
        url: "https://testnet.edgscan.live",
        apiUrl: "https://testnet.edgscan.live/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/eon.js
var require_eon = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.eon = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.eon = (0, defineChain_js_1.defineChain)({
    id: 7332,
    name: "Horizen EON",
    nativeCurrency: {
      decimals: 18,
      name: "ZEN",
      symbol: "ZEN"
    },
    rpcUrls: {
      default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
    },
    blockExplorers: {
      default: {
        name: "EON Explorer",
        url: "https://eon-explorer.horizenlabs.io"
      }
    },
    contracts: {}
  });
});

// node_modules/viem/_cjs/chains/definitions/eos.js
var require_eos = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.eos = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.eos = (0, defineChain_js_1.defineChain)({
    id: 17777,
    name: "EOS EVM",
    nativeCurrency: {
      decimals: 18,
      name: "EOS",
      symbol: "EOS"
    },
    rpcUrls: {
      default: { http: ["https://api.evm.eosnetwork.com"] }
    },
    blockExplorers: {
      default: {
        name: "EOS EVM Explorer",
        url: "https://explorer.evm.eosnetwork.com",
        apiUrl: "https://explorer.evm.eosnetwork.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7943933
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/eosTestnet.js
var require_eosTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.eosTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.eosTestnet = (0, defineChain_js_1.defineChain)({
    id: 15557,
    name: "EOS EVM Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "EOS",
      symbol: "EOS"
    },
    rpcUrls: {
      default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
    },
    blockExplorers: {
      default: {
        name: "EOS EVM Testnet Explorer",
        url: "https://explorer.testnet.evm.eosnetwork.com",
        apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 9067940
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/etherlinkTestnet.js
var require_etherlinkTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.etherlinkTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.etherlinkTestnet = (0, defineChain_js_1.defineChain)({
    id: 128123,
    name: "Etherlink Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Tez",
      symbol: "XTZ"
    },
    rpcUrls: {
      default: { http: ["https://node.ghostnet.etherlink.com"] }
    },
    blockExplorers: {
      default: {
        name: "Etherlink Testnet",
        url: "https://testnet-explorer.etherlink.com"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/evmos.js
var require_evmos = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evmos = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.evmos = (0, defineChain_js_1.defineChain)({
    id: 9001,
    name: "Evmos",
    nativeCurrency: {
      decimals: 18,
      name: "Evmos",
      symbol: "EVMOS"
    },
    rpcUrls: {
      default: { http: ["https://eth.bd.evmos.org:8545"] }
    },
    blockExplorers: {
      default: {
        name: "Evmos Block Explorer",
        url: "https://escan.live"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/evmosTestnet.js
var require_evmosTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evmosTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.evmosTestnet = (0, defineChain_js_1.defineChain)({
    id: 9000,
    name: "Evmos Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Evmos",
      symbol: "EVMOS"
    },
    rpcUrls: {
      default: { http: ["https://eth.bd.evmos.dev:8545"] }
    },
    blockExplorers: {
      default: {
        name: "Evmos Testnet Block Explorer",
        url: "https://evm.evmos.dev/"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/ekta.js
var require_ekta = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ekta = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.ekta = (0, defineChain_js_1.defineChain)({
    id: 1994,
    name: "Ekta",
    nativeCurrency: {
      decimals: 18,
      name: "EKTA",
      symbol: "EKTA"
    },
    rpcUrls: {
      default: { http: ["https://main.ekta.io"] }
    },
    blockExplorers: {
      default: {
        name: "Ektascan",
        url: "https://ektascan.io",
        apiUrl: "https://ektascan.io/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/ektaTestnet.js
var require_ektaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ektaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.ektaTestnet = (0, defineChain_js_1.defineChain)({
    id: 1004,
    name: "Ekta Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "EKTA",
      symbol: "EKTA"
    },
    rpcUrls: {
      default: { http: ["https://test.ekta.io:8545"] }
    },
    blockExplorers: {
      default: {
        name: "Test Ektascan",
        url: "https://test.ektascan.io",
        apiUrl: "https://test.ektascan.io/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/fantom.js
var require_fantom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fantom = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.fantom = (0, defineChain_js_1.defineChain)({
    id: 250,
    name: "Fantom",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/fantom"] }
    },
    blockExplorers: {
      default: {
        name: "FTMScan",
        url: "https://ftmscan.com",
        apiUrl: "https://api.ftmscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 33001987
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/fantomSonicTestnet.js
var require_fantomSonicTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fantomSonicTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.fantomSonicTestnet = (0, defineChain_js_1.defineChain)({
    id: 64240,
    name: "Fantom Sonic Open Testnet",
    network: "fantom-sonic-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpcapi.sonic.fantom.network"] }
    },
    blockExplorers: {
      default: {
        name: "Fantom Sonic Open Testnet Explorer",
        url: "https://public-sonic.fantom.network"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/fantomTestnet.js
var require_fantomTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fantomTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.fantomTestnet = (0, defineChain_js_1.defineChain)({
    id: 4002,
    name: "Fantom Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.testnet.fantom.network"] }
    },
    blockExplorers: {
      default: {
        name: "FTMScan",
        url: "https://testnet.ftmscan.com",
        apiUrl: "https://testnet.ftmscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 8328688
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/fibo.js
var require_fibo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fibo = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.fibo = (0, defineChain_js_1.defineChain)({
    id: 12306,
    name: "Fibo Chain",
    nativeCurrency: {
      decimals: 18,
      name: "fibo",
      symbol: "FIBO"
    },
    rpcUrls: {
      default: { http: ["https://network.hzroc.art"] }
    },
    blockExplorers: {
      default: {
        name: "FiboScan",
        url: "https://scan.fibochain.org"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/filecoin.js
var require_filecoin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filecoin = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.filecoin = (0, defineChain_js_1.defineChain)({
    id: 314,
    name: "Filecoin Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "filecoin",
      symbol: "FIL"
    },
    rpcUrls: {
      default: { http: ["https://api.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: {
        name: "Filfox",
        url: "https://filfox.info/en"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 3328594
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js
var require_filecoinCalibration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filecoinCalibration = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.filecoinCalibration = (0, defineChain_js_1.defineChain)({
    id: 314159,
    name: "Filecoin Calibration",
    nativeCurrency: {
      decimals: 18,
      name: "testnet filecoin",
      symbol: "tFIL"
    },
    rpcUrls: {
      default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: {
        name: "Filscan",
        url: "https://calibration.filscan.io"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js
var require_filecoinHyperspace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filecoinHyperspace = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.filecoinHyperspace = (0, defineChain_js_1.defineChain)({
    id: 3141,
    name: "Filecoin Hyperspace",
    nativeCurrency: {
      decimals: 18,
      name: "testnet filecoin",
      symbol: "tFIL"
    },
    rpcUrls: {
      default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: {
        name: "Filfox",
        url: "https://hyperspace.filfox.info/en"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/flare.js
var require_flare = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flare = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.flare = (0, defineChain_js_1.defineChain)({
    id: 14,
    name: "Flare Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "flare",
      symbol: "FLR"
    },
    rpcUrls: {
      default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Flare Explorer",
        url: "https://flare-explorer.flare.network",
        apiUrl: "https://flare-explorer.flare.network/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/flareTestnet.js
var require_flareTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flareTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.flareTestnet = (0, defineChain_js_1.defineChain)({
    id: 114,
    name: "Coston2",
    nativeCurrency: {
      decimals: 18,
      name: "coston2flare",
      symbol: "C2FLR"
    },
    rpcUrls: {
      default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Coston2 Explorer",
        url: "https://coston2-explorer.flare.network",
        apiUrl: "https://coston2-explorer.flare.network/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/flowPreviewnet.js
var require_flowPreviewnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flowPreviewnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.flowPreviewnet = (0, defineChain_js_1.defineChain)({
    id: 646,
    name: "FlowEVM Previewnet",
    nativeCurrency: {
      decimals: 18,
      name: "Flow",
      symbol: "FLOW"
    },
    rpcUrls: {
      default: {
        http: ["https://previewnet.evm.nodes.onflow.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Previewnet Explorer",
        url: "https://previewnet.flowdiver.io"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/flowMainnet.js
var require_flowMainnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flowMainnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.flowMainnet = (0, defineChain_js_1.defineChain)({
    id: 747,
    name: "FlowEVM Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Flow",
      symbol: "FLOW"
    },
    rpcUrls: {
      default: {
        http: ["https://mainnet.evm.nodes.onflow.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Mainnet Explorer",
        url: "https://flowdiver.io"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/foundry.js
var require_foundry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.foundry = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.foundry = (0, defineChain_js_1.defineChain)({
    id: 31337,
    name: "Foundry",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["http://127.0.0.1:8545"],
        webSocket: ["ws://127.0.0.1:8545"]
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/fraxtal.js
var require_fraxtal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fraxtal = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.fraxtal = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 252,
    name: "Fraxtal",
    nativeCurrency: { name: "Frax Ether", symbol: "frxETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.frax.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "fraxscan",
        url: "https://fraxscan.com",
        apiUrl: "https://api.fraxscan.com/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11"
      },
      portal: {
        [sourceId]: {
          address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
          blockCreated: 19135323
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
          blockCreated: 19135323
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/fraxtalTestnet.js
var require_fraxtalTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fraxtalTestnet = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 17000;
  exports.fraxtalTestnet = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 2522,
    name: "Fraxtal Testnet",
    nativeCurrency: { name: "Frax Ether", symbol: "frxETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.testnet.frax.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "fraxscan testnet",
        url: "https://holesky.fraxscan.com",
        apiUrl: "https://api-holesky.fraxscan.com/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11"
      },
      portal: {
        [sourceId]: {
          address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
          blockCreated: 318416
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
          blockCreated: 318416
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/fuse.js
var require_fuse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fuse = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.fuse = (0, defineChain_js_1.defineChain)({
    id: 122,
    name: "Fuse",
    nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://rpc.fuse.io"] }
    },
    blockExplorers: {
      default: {
        name: "Fuse Explorer",
        url: "https://explorer.fuse.io",
        apiUrl: "https://explorer.fuse.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 16146628
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/fuseSparknet.js
var require_fuseSparknet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fuseSparknet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.fuseSparknet = (0, defineChain_js_1.defineChain)({
    id: 123,
    name: "Fuse Sparknet",
    nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://rpc.fusespark.io"] }
    },
    blockExplorers: {
      default: {
        name: "Sparkent Explorer",
        url: "https://explorer.fusespark.io",
        apiUrl: "https://explorer.fusespark.io/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/iotex.js
var require_iotex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iotex = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.iotex = (0, defineChain_js_1.defineChain)({
    id: 4689,
    name: "IoTeX",
    nativeCurrency: {
      decimals: 18,
      name: "IoTeX",
      symbol: "IOTX"
    },
    rpcUrls: {
      default: {
        http: ["https://babel-api.mainnet.iotex.io"],
        webSocket: ["wss://babel-api.mainnet.iotex.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "IoTeXScan",
        url: "https://iotexscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 22163670
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/iotexTestnet.js
var require_iotexTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iotexTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.iotexTestnet = (0, defineChain_js_1.defineChain)({
    id: 4690,
    name: "IoTeX Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "IoTeX",
      symbol: "IOTX"
    },
    rpcUrls: {
      default: {
        http: ["https://babel-api.testnet.iotex.io"],
        webSocket: ["wss://babel-api.testnet.iotex.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "IoTeXScan",
        url: "https://testnet.iotexscan.io"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/jbc.js
var require_jbc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.jbc = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.jbc = (0, defineChain_js_1.defineChain)({
    id: 8899,
    name: "JIBCHAIN L1",
    network: "jbc",
    nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc-l1.jibchain.net"]
      },
      public: {
        http: ["https://rpc-l1.jibchain.net"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://exp-l1.jibchain.net",
        apiUrl: "https://exp-l1.jibchain.net/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
        blockCreated: 2299048
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/karura.js
var require_karura = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.karura = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.karura = (0, defineChain_js_1.defineChain)({
    id: 686,
    name: "Karura",
    network: "karura",
    nativeCurrency: {
      name: "Karura",
      symbol: "KAR",
      decimals: 18
    },
    rpcUrls: {
      public: {
        http: ["https://eth-rpc-karura.aca-api.network"],
        webSocket: ["wss://eth-rpc-karura.aca-api.network"]
      },
      default: {
        http: ["https://eth-rpc-karura.aca-api.network"],
        webSocket: ["wss://eth-rpc-karura.aca-api.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Karura Blockscout",
        url: "https://blockscout.karura.network",
        apiUrl: "https://blockscout.karura.network/api"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/gobi.js
var require_gobi = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.gobi = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.gobi = (0, defineChain_js_1.defineChain)({
    id: 1663,
    name: "Horizen Gobi Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Test ZEN",
      symbol: "tZEN"
    },
    rpcUrls: {
      default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
    },
    blockExplorers: {
      default: {
        name: "Gobi Explorer",
        url: "https://gobi-explorer.horizen.io"
      }
    },
    contracts: {},
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/goerli.js
var require_goerli = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.goerli = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.goerli = (0, defineChain_js_1.defineChain)({
    id: 5,
    name: "Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.ankr.com/eth_goerli"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://goerli.etherscan.io",
        apiUrl: "https://api-goerli.etherscan.io/api"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
        blockCreated: 10339206
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6507670
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/gnosis.js
var require_gnosis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.gnosis = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.gnosis = (0, defineChain_js_1.defineChain)({
    id: 100,
    name: "Gnosis",
    nativeCurrency: {
      decimals: 18,
      name: "Gnosis",
      symbol: "xDAI"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.gnosischain.com"],
        webSocket: ["wss://rpc.gnosischain.com/wss"]
      }
    },
    blockExplorers: {
      default: {
        name: "Gnosisscan",
        url: "https://gnosisscan.io",
        apiUrl: "https://api.gnosisscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 21022491
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/gnosisChiado.js
var require_gnosisChiado = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.gnosisChiado = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.gnosisChiado = (0, defineChain_js_1.defineChain)({
    id: 10200,
    name: "Gnosis Chiado",
    nativeCurrency: {
      decimals: 18,
      name: "Gnosis",
      symbol: "xDAI"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.chiadochain.net"],
        webSocket: ["wss://rpc.chiadochain.net/wss"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://blockscout.chiadochain.net",
        apiUrl: "https://blockscout.chiadochain.net/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 4967313
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/hardhat.js
var require_hardhat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hardhat = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.hardhat = (0, defineChain_js_1.defineChain)({
    id: 31337,
    name: "Hardhat",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["http://127.0.0.1:8545"] }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/harmonyOne.js
var require_harmonyOne = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.harmonyOne = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.harmonyOne = (0, defineChain_js_1.defineChain)({
    id: 1666600000,
    name: "Harmony One",
    nativeCurrency: {
      name: "Harmony",
      symbol: "ONE",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/harmony"] }
    },
    blockExplorers: {
      default: {
        name: "Harmony Explorer",
        url: "https://explorer.harmony.one"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 24185753
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/haqqMainnet.js
var require_haqqMainnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.haqqMainnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.haqqMainnet = (0, defineChain_js_1.defineChain)({
    id: 11235,
    name: "HAQQ Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Islamic Coin",
      symbol: "ISLM"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.eth.haqq.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "HAQQ Explorer",
        url: "https://explorer.haqq.network",
        apiUrl: "https://explorer.haqq.network/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js
var require_haqqTestedge2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.haqqTestedge2 = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.haqqTestedge2 = (0, defineChain_js_1.defineChain)({
    id: 54211,
    name: "HAQQ Testedge 2",
    nativeCurrency: {
      decimals: 18,
      name: "Islamic Coin",
      symbol: "ISLMT"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.eth.testedge2.haqq.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "HAQQ Explorer",
        url: "https://explorer.testedge2.haqq.network",
        apiUrl: "https://explorer.testedge2.haqq.network/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/hedera.js
var require_hedera = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hedera = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.hedera = (0, defineChain_js_1.defineChain)({
    id: 295,
    name: "Hedera Mainnet",
    network: "hedera-mainnet",
    nativeCurrency: {
      symbol: "HBAR",
      name: "HBAR",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://mainnet.hashio.io/api"]
      }
    },
    blockExplorers: {
      default: {
        name: "Hashscan",
        url: "https://hashscan.io/mainnet"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/hederaTestnet.js
var require_hederaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hederaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.hederaTestnet = (0, defineChain_js_1.defineChain)({
    id: 296,
    name: "Hedera Testnet",
    network: "hedera-testnet",
    nativeCurrency: {
      symbol: "HBAR",
      name: "HBAR",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://testnet.hashio.io/api"]
      }
    },
    blockExplorers: {
      default: {
        name: "Hashscan",
        url: "https://hashscan.io/testnet"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/hederaPreviewnet.js
var require_hederaPreviewnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hederaPreviewnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.hederaPreviewnet = (0, defineChain_js_1.defineChain)({
    id: 297,
    name: "Hedera Previewnet",
    network: "hedera-previewnet",
    nativeCurrency: {
      symbol: "HBAR",
      name: "HBAR",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://previewnet.hashio.io/api"]
      }
    },
    blockExplorers: {
      default: {
        name: "Hashscan",
        url: "https://hashscan.io/previewnet"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/holesky.js
var require_holesky = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.holesky = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.holesky = (0, defineChain_js_1.defineChain)({
    id: 17000,
    name: "Holesky",
    nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://ethereum-holesky-rpc.publicnode.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://holesky.etherscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 77
      },
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        blockCreated: 801613
      },
      ensUniversalResolver: {
        address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
        blockCreated: 973484
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/immutableZkEvm.js
var require_immutableZkEvm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immutableZkEvm = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.immutableZkEvm = (0, defineChain_js_1.defineChain)({
    id: 13371,
    name: "Immutable zkEVM",
    nativeCurrency: {
      decimals: 18,
      name: "Immutable Coin",
      symbol: "IMX"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.immutable.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Immutable Explorer",
        url: "https://explorer.immutable.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
        blockCreated: 4335972
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/immutableZkEvmTestnet.js
var require_immutableZkEvmTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immutableZkEvmTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.immutableZkEvmTestnet = (0, defineChain_js_1.defineChain)({
    id: 13473,
    name: "Immutable zkEVM Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Immutable Coin",
      symbol: "IMX"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.testnet.immutable.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Immutable Testnet Explorer",
        url: "https://explorer.testnet.immutable.com/"
      }
    },
    contracts: {
      multicall3: {
        address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
        blockCreated: 5977391
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/kakarotSepolia.js
var require_kakarotSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kakarotSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.kakarotSepolia = (0, defineChain_js_1.defineChain)({
    id: 107107114116,
    name: "Kakarot Sepolia",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://sepolia-rpc.kakarot.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Kakarot Scan",
        url: "https://sepolia.kakarotscan.org"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/kava.js
var require_kava = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kava = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.kava = (0, defineChain_js_1.defineChain)({
    id: 2222,
    name: "Kava EVM",
    network: "kava-mainnet",
    nativeCurrency: {
      name: "Kava",
      symbol: "KAVA",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://evm.kava.io"] }
    },
    blockExplorers: {
      default: {
        name: "Kava EVM Explorer",
        url: "https://kavascan.com",
        apiUrl: "https://kavascan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 3661165
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/kavaTestnet.js
var require_kavaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kavaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.kavaTestnet = (0, defineChain_js_1.defineChain)({
    id: 2221,
    name: "Kava EVM Testnet",
    network: "kava-testnet",
    nativeCurrency: {
      name: "Kava",
      symbol: "KAVA",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://evm.testnet.kava.io"] }
    },
    blockExplorers: {
      default: {
        name: "Kava EVM Testnet Explorer",
        url: "https://testnet.kavascan.com/",
        apiUrl: "https://testnet.kavascan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
        blockCreated: 7242179
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/kcc.js
var require_kcc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kcc = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.kcc = (0, defineChain_js_1.defineChain)({
    id: 321,
    name: "KCC Mainnet",
    network: "KCC Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "KCS",
      symbol: "KCS"
    },
    rpcUrls: {
      default: {
        http: ["https://kcc-rpc.com"]
      },
      public: {
        http: ["https://kcc-rpc.com"]
      }
    },
    blockExplorers: {
      default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 11760430
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/klaytn.js
var require_klaytn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.klaytn = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.klaytn = (0, defineChain_js_1.defineChain)({
    id: 8217,
    name: "Klaytn",
    nativeCurrency: {
      decimals: 18,
      name: "Klaytn",
      symbol: "KLAY"
    },
    rpcUrls: {
      default: { http: ["https://public-en-cypress.klaytn.net"] }
    },
    blockExplorers: {
      default: {
        name: "KlaytnScope",
        url: "https://scope.klaytn.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 96002415
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/klaytnBaobab.js
var require_klaytnBaobab = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.klaytnBaobab = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.klaytnBaobab = (0, defineChain_js_1.defineChain)({
    id: 1001,
    name: "Klaytn Baobab Testnet",
    network: "klaytn-baobab",
    nativeCurrency: {
      decimals: 18,
      name: "Baobab Klaytn",
      symbol: "KLAY"
    },
    rpcUrls: {
      default: { http: ["https://public-en-baobab.klaytn.net"] }
    },
    blockExplorers: {
      default: {
        name: "KlaytnScope",
        url: "https://baobab.klaytnscope.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 123390593
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/kroma.js
var require_kroma = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kroma = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.kroma = (0, defineChain_js_1.defineChain)({
    id: 255,
    name: "Kroma",
    nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://api.kroma.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Kroma Explorer",
        url: "https://blockscout.kroma.network",
        apiUrl: "https://blockscout.kroma.network/api"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/kromaSepolia.js
var require_kromaSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kromaSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.kromaSepolia = (0, defineChain_js_1.defineChain)({
    id: 2358,
    name: "Kroma Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://api.sepolia.kroma.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Kroma Sepolia Explorer",
        url: "https://blockscout.sepolia.kroma.network",
        apiUrl: "https://blockscout.sepolia.kroma.network/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/lightlinkPegasus.js
var require_lightlinkPegasus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lightlinkPegasus = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.lightlinkPegasus = (0, defineChain_js_1.defineChain)({
    id: 1891,
    name: "LightLink Pegasus Testnet",
    network: "lightlink-pegasus",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
      }
    },
    blockExplorers: {
      default: {
        name: "LightLink Pegasus Explorer",
        url: "https://pegasus.lightlink.io"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/lightlinkPhoenix.js
var require_lightlinkPhoenix = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lightlinkPhoenix = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.lightlinkPhoenix = (0, defineChain_js_1.defineChain)({
    id: 1890,
    name: "LightLink Phoenix Mainnet",
    network: "lightlink-phoenix",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
      }
    },
    blockExplorers: {
      default: {
        name: "LightLink Phoenix Explorer",
        url: "https://phoenix.lightlink.io"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/linea.js
var require_linea = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.linea = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.linea = (0, defineChain_js_1.defineChain)({
    id: 59144,
    name: "Linea Mainnet",
    nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.linea.build"],
        webSocket: ["wss://rpc.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://lineascan.build",
        apiUrl: "https://api.lineascan.build/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 42
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/lineaGoerli.js
var require_lineaGoerli = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lineaGoerli = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.lineaGoerli = (0, defineChain_js_1.defineChain)({
    id: 59140,
    name: "Linea Goerli Testnet",
    nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://goerli.lineascan.build",
        apiUrl: "https://api-goerli.lineascan.build/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 498623
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/lineaSepolia.js
var require_lineaSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lineaSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.lineaSepolia = (0, defineChain_js_1.defineChain)({
    id: 59141,
    name: "Linea Sepolia Testnet",
    nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.sepolia.linea.build"],
        webSocket: ["wss://rpc.sepolia.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://sepolia.lineascan.build",
        apiUrl: "https://api-sepolia.lineascan.build/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 227427
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/lineaTestnet.js
var require_lineaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lineaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.lineaTestnet = (0, defineChain_js_1.defineChain)({
    id: 59140,
    name: "Linea Goerli Testnet",
    nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://goerli.lineascan.build",
        apiUrl: "https://goerli.lineascan.build/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 498623
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/liskSepolia.js
var require_liskSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.liskSepolia = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.liskSepolia = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 4202,
    network: "lisk-sepolia",
    name: "Lisk Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.sepolia-api.lisk.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://sepolia-blockscout.lisk.com",
        apiUrl: "https://sepolia-blockscout.lisk.com/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11"
      },
      portal: {
        [sourceId]: {
          address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
        }
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/localhost.js
var require_localhost = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.localhost = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.localhost = (0, defineChain_js_1.defineChain)({
    id: 1337,
    name: "Localhost",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["http://127.0.0.1:8545"] }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/lukso.js
var require_lukso = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lukso = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.lukso = (0, defineChain_js_1.defineChain)({
    id: 42,
    network: "lukso",
    name: "LUKSO",
    nativeCurrency: {
      name: "LUKSO",
      symbol: "LYX",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.mainnet.lukso.network"],
        webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "LUKSO Mainnet Explorer",
        url: "https://explorer.execution.mainnet.lukso.network",
        apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 468183
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/luksoTestnet.js
var require_luksoTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.luksoTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.luksoTestnet = (0, defineChain_js_1.defineChain)({
    id: 4201,
    name: "LUKSO Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "LUKSO Testnet",
      symbol: "LYXt"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.testnet.lukso.network"],
        webSocket: ["wss://ws-rpc.testnet.lukso.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "LUKSO Testnet Explorer",
        url: "https://explorer.execution.testnet.lukso.network",
        apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 605348
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/mainnet.js
var require_mainnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mainnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mainnet = (0, defineChain_js_1.defineChain)({
    id: 1,
    name: "Ethereum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://cloudflare-eth.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://etherscan.io",
        apiUrl: "https://api.etherscan.io/api"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
        blockCreated: 19258213
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/mandala.js
var require_mandala = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mandala = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mandala = (0, defineChain_js_1.defineChain)({
    id: 595,
    name: "Mandala TC9",
    network: "mandala",
    nativeCurrency: {
      name: "Mandala",
      symbol: "mACA",
      decimals: 18
    },
    rpcUrls: {
      public: {
        http: ["https://eth-rpc-tc9.aca-staging.network"],
        webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
      },
      default: {
        http: ["https://eth-rpc-tc9.aca-staging.network"],
        webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Mandala Blockscout",
        url: "https://blockscout.mandala.aca-staging.network",
        apiUrl: "https://blockscout.mandala.aca-staging.network/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/manta.js
var require_manta = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.manta = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.manta = (0, defineChain_js_1.defineChain)({
    id: 169,
    name: "Manta Pacific Mainnet",
    network: "manta",
    nativeCurrency: {
      decimals: 18,
      name: "ETH",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["https://pacific-rpc.manta.network/http"] }
    },
    blockExplorers: {
      default: {
        name: "Manta Explorer",
        url: "https://pacific-explorer.manta.network",
        apiUrl: "https://pacific-explorer.manta.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 332890
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/mantaSepoliaTestnet.js
var require_mantaSepoliaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mantaSepoliaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mantaSepoliaTestnet = (0, defineChain_js_1.defineChain)({
    id: 3441006,
    name: "Manta Pacific Sepolia Testnet",
    network: "manta-sepolia",
    nativeCurrency: {
      decimals: 18,
      name: "ETH",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
      }
    },
    blockExplorers: {
      default: {
        name: "Manta Sepolia Testnet Explorer",
        url: "https://pacific-explorer.sepolia-testnet.manta.network",
        apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca54918f7B525C8df894668846506767412b53E3",
        blockCreated: 479584
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/mantaTestnet.js
var require_mantaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mantaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mantaTestnet = (0, defineChain_js_1.defineChain)({
    id: 3441005,
    name: "Manta Pacific Testnet",
    network: "manta-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "ETH",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
    },
    blockExplorers: {
      default: {
        name: "Manta Testnet Explorer",
        url: "https://pacific-explorer.testnet.manta.network",
        apiUrl: "https://pacific-explorer.testnet.manta.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
        blockCreated: 419915
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/mantle.js
var require_mantle = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mantle = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mantle = (0, defineChain_js_1.defineChain)({
    id: 5000,
    name: "Mantle",
    nativeCurrency: {
      decimals: 18,
      name: "MNT",
      symbol: "MNT"
    },
    rpcUrls: {
      default: { http: ["https://rpc.mantle.xyz"] }
    },
    blockExplorers: {
      default: {
        name: "Mantle Explorer",
        url: "https://explorer.mantle.xyz",
        apiUrl: "https://explorer.mantle.xyz/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 304717
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/mantleSepoliaTestnet.js
var require_mantleSepoliaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mantleSepoliaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mantleSepoliaTestnet = (0, defineChain_js_1.defineChain)({
    id: 5003,
    name: "Mantle Sepolia Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "MNT",
      symbol: "MNT"
    },
    rpcUrls: {
      default: { http: ["https://rpc.sepolia.mantle.xyz"] }
    },
    blockExplorers: {
      default: {
        name: "Mantle Testnet Explorer",
        url: "https://explorer.sepolia.mantle.xyz/",
        apiUrl: "https://explorer.sepolia.mantle.xyz/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 4584012
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/mantleTestnet.js
var require_mantleTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mantleTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mantleTestnet = (0, defineChain_js_1.defineChain)({
    id: 5001,
    name: "Mantle Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "MNT",
      symbol: "MNT"
    },
    rpcUrls: {
      default: { http: ["https://rpc.testnet.mantle.xyz"] }
    },
    blockExplorers: {
      default: {
        name: "Mantle Testnet Explorer",
        url: "https://explorer.testnet.mantle.xyz",
        apiUrl: "https://explorer.testnet.mantle.xyz/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 561333
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/merlin.js
var require_merlin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merlin = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.merlin = (0, defineChain_js_1.defineChain)({
    id: 4200,
    name: "Merlin",
    nativeCurrency: {
      name: "BTC",
      symbol: "BTC",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://rpc.merlinchain.io"] }
    },
    blockExplorers: {
      default: {
        name: "blockscout",
        url: "https://scan.merlinchain.io",
        apiUrl: "https://scan.merlinchain.io/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/metachain.js
var require_metachain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metachain = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.metachain = (0, defineChain_js_1.defineChain)({
    id: 571,
    name: "MetaChain Mainnet",
    nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.metatime.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "MetaExplorer",
        url: "https://explorer.metatime.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0x0000000000000000000000000000000000003001",
        blockCreated: 0
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/metachainIstanbul.js
var require_metachainIstanbul = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metachainIstanbul = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.metachainIstanbul = (0, defineChain_js_1.defineChain)({
    id: 1453,
    name: "MetaChain Istanbul",
    nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://istanbul-rpc.metachain.dev"]
      }
    },
    blockExplorers: {
      default: {
        name: "MetaExplorer",
        url: "https://istanbul-explorer.metachain.dev"
      }
    },
    contracts: {
      multicall3: {
        address: "0x0000000000000000000000000000000000003001",
        blockCreated: 0
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/meter.js
var require_meter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.meter = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.meter = (0, defineChain_js_1.defineChain)({
    id: 82,
    name: "Meter",
    nativeCurrency: {
      decimals: 18,
      name: "MTR",
      symbol: "MTR"
    },
    rpcUrls: {
      default: { http: ["https://rpc.meter.io"] }
    },
    blockExplorers: {
      default: {
        name: "MeterScan",
        url: "https://scan.meter.io"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/meterTestnet.js
var require_meterTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.meterTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.meterTestnet = (0, defineChain_js_1.defineChain)({
    id: 83,
    name: "Meter Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "MTR",
      symbol: "MTR"
    },
    rpcUrls: {
      default: { http: ["https://rpctest.meter.io"] }
    },
    blockExplorers: {
      default: {
        name: "MeterTestnetScan",
        url: "https://scan-warringstakes.meter.io"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/metis.js
var require_metis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metis = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.metis = (0, defineChain_js_1.defineChain)({
    id: 1088,
    name: "Metis",
    nativeCurrency: {
      decimals: 18,
      name: "Metis",
      symbol: "METIS"
    },
    rpcUrls: {
      default: { http: ["https://andromeda.metis.io/?owner=1088"] }
    },
    blockExplorers: {
      default: {
        name: "Andromeda Explorer",
        url: "https://andromeda-explorer.metis.io",
        apiUrl: "https://andromeda-explorer.metis.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 2338552
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/metisGoerli.js
var require_metisGoerli = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metisGoerli = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.metisGoerli = (0, defineChain_js_1.defineChain)({
    id: 599,
    name: "Metis Goerli",
    nativeCurrency: {
      decimals: 18,
      name: "Metis Goerli",
      symbol: "METIS"
    },
    rpcUrls: {
      default: { http: ["https://goerli.gateway.metisdevops.link"] }
    },
    blockExplorers: {
      default: {
        name: "Metis Goerli Explorer",
        url: "https://goerli.explorer.metisdevops.link",
        apiUrl: "https://goerli.explorer.metisdevops.link/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1006207
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/mev.js
var require_mev = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mev = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mev = (0, defineChain_js_1.defineChain)({
    id: 7518,
    name: "MEVerse Chain Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "MEVerse",
      symbol: "MEV"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.meversemainnet.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Explorer",
        url: "https://www.meversescan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 86881340
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/mevTestnet.js
var require_mevTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mevTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mevTestnet = (0, defineChain_js_1.defineChain)({
    id: 4759,
    name: "MEVerse Chain Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "MEVerse",
      symbol: "MEV"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.meversetestnet.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Explorer",
        url: "https://testnet.meversescan.io/"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 64371115
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/mintSepoliaTestnet.js
var require_mintSepoliaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mintSepoliaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.mintSepoliaTestnet = (0, defineChain_js_1.defineChain)({
    id: 1686,
    name: "Mint Sepolia Testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet-rpc.mintchain.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Mintchain Testnet explorer",
        url: "https://testnet-explorer.mintchain.io"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/mode.js
var require_mode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mode = undefined;
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.mode = (0, defineChain_js_1.defineChain)({
    id: 34443,
    name: "Mode Mainnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.mode.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Modescan",
        url: "https://modescan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 2465882
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/modeTestnet.js
var require_modeTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.modeTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.modeTestnet = (0, defineChain_js_1.defineChain)({
    id: 919,
    name: "Mode Testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.mode.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://sepolia.explorer.mode.network",
        apiUrl: "https://sepolia.explorer.mode.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
        blockCreated: 3019007
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js
var require_moonbaseAlpha = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.moonbaseAlpha = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.moonbaseAlpha = (0, defineChain_js_1.defineChain)({
    id: 1287,
    name: "Moonbase Alpha",
    nativeCurrency: {
      decimals: 18,
      name: "DEV",
      symbol: "DEV"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.api.moonbase.moonbeam.network"],
        webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonbase.moonscan.io",
        apiUrl: "https://moonbase.moonscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1850686
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/moonbeam.js
var require_moonbeam = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.moonbeam = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.moonbeam = (0, defineChain_js_1.defineChain)({
    id: 1284,
    name: "Moonbeam",
    nativeCurrency: {
      decimals: 18,
      name: "GLMR",
      symbol: "GLMR"
    },
    rpcUrls: {
      default: {
        http: ["https://moonbeam.public.blastapi.io"],
        webSocket: ["wss://moonbeam.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonscan.io",
        apiUrl: "https://api-moonbeam.moonscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 609002
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/moonbeamDev.js
var require_moonbeamDev = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.moonbeamDev = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.moonbeamDev = (0, defineChain_js_1.defineChain)({
    id: 1281,
    name: "Moonbeam Development Node",
    nativeCurrency: {
      decimals: 18,
      name: "DEV",
      symbol: "DEV"
    },
    rpcUrls: {
      default: {
        http: ["http://127.0.0.1:9944"],
        webSocket: ["wss://127.0.0.1:9944"]
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/moonriver.js
var require_moonriver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.moonriver = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.moonriver = (0, defineChain_js_1.defineChain)({
    id: 1285,
    name: "Moonriver",
    nativeCurrency: {
      decimals: 18,
      name: "MOVR",
      symbol: "MOVR"
    },
    rpcUrls: {
      default: {
        http: ["https://moonriver.public.blastapi.io"],
        webSocket: ["wss://moonriver.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonriver.moonscan.io",
        apiUrl: "https://api-moonriver.moonscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1597904
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/morphSepolia.js
var require_morphSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.morphSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.morphSepolia = (0, defineChain_js_1.defineChain)({
    id: 2710,
    name: "Morph Sepolia",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc-testnet.morphl2.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Morph Testnet Explorer",
        url: "https://explorer-testnet.morphl2.io",
        apiUrl: "https://explorer-api-testnet.morphl2.io/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/neonDevnet.js
var require_neonDevnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.neonDevnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.neonDevnet = (0, defineChain_js_1.defineChain)({
    id: 245022926,
    name: "Neon EVM DevNet",
    nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://devnet.neonevm.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Neonscan",
        url: "https://devnet.neonscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 205206112
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/neonMainnet.js
var require_neonMainnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.neonMainnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.neonMainnet = (0, defineChain_js_1.defineChain)({
    id: 245022934,
    network: "neonMainnet",
    name: "Neon EVM MainNet",
    nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://neon-proxy-mainnet.solana.p2p.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Neonscan",
        url: "https://neonscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 206545524
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/nexi.js
var require_nexi = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nexi = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.nexi = (0, defineChain_js_1.defineChain)({
    id: 4242,
    name: "Nexi",
    nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.chain.nexi.technology"]
      }
    },
    blockExplorers: {
      default: {
        name: "NexiScan",
        url: "https://www.nexiscan.com",
        apiUrl: "https://www.nexiscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
        blockCreated: 25770160
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/nexilix.js
var require_nexilix = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nexilix = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.nexilix = (0, defineChain_js_1.defineChain)({
    id: 240,
    name: "Nexilix Smart Chain",
    nativeCurrency: {
      decimals: 18,
      name: "Nexilix",
      symbol: "NEXILIX"
    },
    rpcUrls: {
      default: { http: ["https://rpcurl.pos.nexilix.com"] }
    },
    blockExplorers: {
      default: {
        name: "NexilixScan",
        url: "https://scan.nexilix.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
        blockCreated: 74448
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/oasys.js
var require_oasys = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.oasys = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.oasys = (0, defineChain_js_1.defineChain)({
    id: 248,
    name: "Oasys",
    nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.mainnet.oasys.games"]
      }
    },
    blockExplorers: {
      default: {
        name: "OasysScan",
        url: "https://scan.oasys.games",
        apiUrl: "https://scan.oasys.games/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/oasisTestnet.js
var require_oasisTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.oasisTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.oasisTestnet = (0, defineChain_js_1.defineChain)({
    id: 4090,
    network: "oasis-testnet",
    name: "Oasis Testnet",
    nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://rpc1.oasis.bahamutchain.com"] },
      public: { http: ["https://rpc1.oasis.bahamutchain.com"] }
    },
    blockExplorers: {
      default: {
        name: "Ftnscan",
        url: "https://oasis.ftnscan.com",
        apiUrl: "https://oasis.ftnscan.com/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/okc.js
var require_okc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.okc = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.okc = (0, defineChain_js_1.defineChain)({
    id: 66,
    name: "OKC",
    nativeCurrency: {
      decimals: 18,
      name: "OKT",
      symbol: "OKT"
    },
    rpcUrls: {
      default: { http: ["https://exchainrpc.okex.org"] }
    },
    blockExplorers: {
      default: {
        name: "oklink",
        url: "https://www.oklink.com/okc"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 10364792
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/optimism.js
var require_optimism = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.optimism = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.optimism = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 10,
    name: "OP Mainnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.optimism.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Optimism Explorer",
        url: "https://optimistic.etherscan.io",
        apiUrl: "https://api-optimistic.etherscan.io/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 4286263
      },
      portal: {
        [sourceId]: {
          address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/optimismGoerli.js
var require_optimismGoerli = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.optimismGoerli = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 5;
  exports.optimismGoerli = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 420,
    name: "Optimism Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://goerli.optimism.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io",
        apiUrl: "https://goerli-optimism.etherscan.io/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 49461
      },
      portal: {
        [sourceId]: {
          address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
        }
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/optimismSepolia.js
var require_optimismSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.optimismSepolia = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.optimismSepolia = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 11155420,
    name: "OP Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.optimism.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://optimism-sepolia.blockscout.com",
        apiUrl: "https://optimism-sepolia.blockscout.com/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      disputeGameFactory: {
        [sourceId]: {
          address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
        }
      },
      l2OutputOracle: {
        [sourceId]: {
          address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1620204
      },
      portal: {
        [sourceId]: {
          address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
        }
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/opBNB.js
var require_opBNB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.opBNB = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.opBNB = (0, defineChain_js_1.defineChain)({
    id: 204,
    name: "opBNB",
    nativeCurrency: {
      name: "BNB",
      symbol: "BNB",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
    },
    blockExplorers: {
      default: {
        name: "opbnbscan",
        url: "https://mainnet.opbnbscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 512881
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js
var require_opBNBTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.opBNBTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.opBNBTestnet = (0, defineChain_js_1.defineChain)({
    id: 5611,
    name: "opBNB Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "tBNB",
      symbol: "tBNB"
    },
    rpcUrls: {
      default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
    },
    blockExplorers: {
      default: {
        name: "opbnbscan",
        url: "https://testnet.opbnbscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 3705108
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/oortmainnetDev.js
var require_oortmainnetDev = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.oortMainnetDev = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.oortMainnetDev = (0, defineChain_js_1.defineChain)({
    id: 9700,
    name: "OORT MainnetDev",
    nativeCurrency: {
      decimals: 18,
      name: "OORT",
      symbol: "OORT"
    },
    rpcUrls: {
      default: { http: ["https://dev-rpc.oortech.com"] }
    },
    blockExplorers: {
      oort: {
        name: "OORT MainnetDev Explorer",
        url: "https://dev-scan.oortech.com"
      },
      default: {
        name: "OORT MainnetDev Explorer",
        url: "https://dev-scan.oortech.com"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/palm.js
var require_palm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.palm = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.palm = (0, defineChain_js_1.defineChain)({
    id: 11297108109,
    name: "Palm",
    nativeCurrency: {
      decimals: 18,
      name: "PALM",
      symbol: "PALM"
    },
    rpcUrls: {
      default: {
        http: ["https://palm-mainnet.public.blastapi.io"],
        webSocket: ["wss://palm-mainnet.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Chainlens",
        url: "https://palm.chainlens.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 15429248
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/palmTestnet.js
var require_palmTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.palmTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.palmTestnet = (0, defineChain_js_1.defineChain)({
    id: 11297108099,
    name: "Palm Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "PALM",
      symbol: "PALM"
    },
    rpcUrls: {
      default: {
        http: ["https://palm-mainnet.public.blastapi.io"],
        webSocket: ["wss://palm-mainnet.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Chainlens",
        url: "https://palm.chainlens.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 15429248
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/zksync/formatters.js
var require_formatters3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatters = undefined;
  var fromHex_js_1 = require_fromHex();
  var toBytes_js_1 = require_toBytes();
  var toHex_js_1 = require_toHex();
  var block_js_1 = require_block();
  var log_js_1 = require_log();
  var transaction_js_1 = require_transaction();
  var transactionReceipt_js_1 = require_transactionReceipt();
  var transactionRequest_js_1 = require_transactionRequest();
  exports.formatters = {
    block: (0, block_js_1.defineBlock)({
      format(args) {
        const transactions = args.transactions?.map((transaction) => {
          if (typeof transaction === "string")
            return transaction;
          const formatted = exports.formatters.transaction?.format(transaction);
          if (formatted.typeHex === "0x71")
            formatted.type = "eip712";
          else if (formatted.typeHex === "0xff")
            formatted.type = "priority";
          return formatted;
        });
        return {
          l1BatchNumber: args.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber) : null,
          l1BatchTimestamp: args.l1BatchTimestamp ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTimestamp) : null,
          transactions
        };
      }
    }),
    transaction: (0, transaction_js_1.defineTransaction)({
      format(args) {
        const transaction = {};
        if (args.type === "0x71")
          transaction.type = "eip712";
        else if (args.type === "0xff")
          transaction.type = "priority";
        return {
          ...transaction,
          l1BatchNumber: args.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber) : null,
          l1BatchTxIndex: args.l1BatchTxIndex ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTxIndex) : null
        };
      }
    }),
    transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
      format(args) {
        return {
          l1BatchNumber: args.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber) : null,
          l1BatchTxIndex: args.l1BatchTxIndex ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTxIndex) : null,
          logs: args.logs.map((log) => {
            return {
              ...(0, log_js_1.formatLog)(log),
              l1BatchNumber: log.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(log.l1BatchNumber) : null,
              transactionLogIndex: (0, fromHex_js_1.hexToNumber)(log.transactionLogIndex),
              logType: log.logType
            };
          }),
          l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
            return {
              blockNumber: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.blockHash),
              blockHash: l2ToL1Log.blockHash,
              l1BatchNumber: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.l1BatchNumber),
              transactionIndex: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.transactionIndex),
              shardId: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.shardId),
              isService: l2ToL1Log.isService,
              sender: l2ToL1Log.sender,
              key: l2ToL1Log.key,
              value: l2ToL1Log.value,
              transactionHash: l2ToL1Log.transactionHash,
              logIndex: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.logIndex)
            };
          })
        };
      }
    }),
    transactionRequest: (0, transactionRequest_js_1.defineTransactionRequest)({
      exclude: [
        "customSignature",
        "factoryDeps",
        "gasPerPubdata",
        "paymaster",
        "paymasterInput"
      ],
      format(args) {
        if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
          return {
            eip712Meta: {
              ...args.gasPerPubdata ? { gasPerPubdata: (0, toHex_js_1.toHex)(args.gasPerPubdata) } : {},
              ...args.paymaster && args.paymasterInput ? {
                paymasterParams: {
                  paymaster: args.paymaster,
                  paymasterInput: Array.from((0, toBytes_js_1.hexToBytes)(args.paymasterInput))
                }
              } : {},
              ...args.factoryDeps ? {
                factoryDeps: args.factoryDeps.map((dep) => Array.from((0, toBytes_js_1.hexToBytes)(dep)))
              } : {},
              ...args.customSignature ? {
                customSignature: Array.from((0, toBytes_js_1.hexToBytes)(args.customSignature))
              } : {}
            },
            type: "0x71"
          };
        return {};
      }
    })
  };
});

// node_modules/viem/_cjs/zksync/errors/transaction.js
var require_transaction3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidEip712TransactionError = undefined;
  var base_js_1 = require_base();

  class InvalidEip712TransactionError extends base_js_1.BaseError {
    constructor() {
      super([
        "Transaction is not an EIP712 transaction.",
        "",
        "Transaction must:",
        '  - include `type: "eip712"`',
        "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidEip712TransactionError"
      });
    }
  }
  exports.InvalidEip712TransactionError = InvalidEip712TransactionError;
});

// node_modules/viem/_cjs/zksync/utils/isEip712Transaction.js
var require_isEip712Transaction = __commonJS((exports) => {
  function isEIP712Transaction(transaction) {
    if (transaction.type === "eip712")
      return true;
    if ("customSignature" in transaction && transaction.customSignature || "paymaster" in transaction && transaction.paymaster || "paymasterInput" in transaction && transaction.paymasterInput || "gasPerPubdata" in transaction && typeof transaction.gasPerPubdata === "bigint" || "factoryDeps" in transaction && transaction.factoryDeps)
      return true;
    return false;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEIP712Transaction = undefined;
  exports.isEIP712Transaction = isEIP712Transaction;
});

// node_modules/viem/_cjs/zksync/utils/assertEip712Transaction.js
var require_assertEip712Transaction = __commonJS((exports) => {
  function assertEip712Transaction(transaction) {
    const { chainId, to, from, paymaster, paymasterInput } = transaction;
    if (!(0, isEip712Transaction_js_1.isEIP712Transaction)(transaction))
      throw new transaction_js_1.InvalidEip712TransactionError;
    if (!chainId || chainId <= 0)
      throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
      throw new address_js_1.InvalidAddressError({ address: to });
    if (from && !(0, isAddress_js_1.isAddress)(from))
      throw new address_js_1.InvalidAddressError({ address: from });
    if (paymaster && !(0, isAddress_js_1.isAddress)(paymaster))
      throw new address_js_1.InvalidAddressError({ address: paymaster });
    if (paymaster && !paymasterInput) {
      throw new base_js_1.BaseError("`paymasterInput` must be provided when `paymaster` is defined");
    }
    if (!paymaster && paymasterInput) {
      throw new base_js_1.BaseError("`paymaster` must be provided when `paymasterInput` is defined");
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertEip712Transaction = undefined;
  var address_js_1 = require_address();
  var base_js_1 = require_base();
  var chain_js_1 = require_chain();
  var isAddress_js_1 = require_isAddress();
  var transaction_js_1 = require_transaction3();
  var isEip712Transaction_js_1 = require_isEip712Transaction();
  exports.assertEip712Transaction = assertEip712Transaction;
});

// node_modules/viem/_cjs/zksync/serializers.js
var require_serializers3 = __commonJS((exports) => {
  function serializeTransaction(transaction, signature) {
    if ((0, isEip712Transaction_js_1.isEIP712Transaction)(transaction))
      return serializeTransactionEIP712(transaction);
    return (0, serializeTransaction_js_1.serializeTransaction)(transaction, signature);
  }
  function serializeTransactionEIP712(transaction) {
    const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
    (0, assertEip712Transaction_js_1.assertEip712Transaction)(transaction);
    const serializedTransaction = [
      nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
      maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
      gas ? (0, toHex_js_1.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_1.toHex)(value) : "0x",
      data ?? "0x0",
      (0, toHex_js_1.toHex)(chainId),
      (0, toHex_js_1.toHex)(""),
      (0, toHex_js_1.toHex)(""),
      (0, toHex_js_1.toHex)(chainId),
      from ?? "0x",
      gasPerPubdata ? (0, toHex_js_1.toHex)(gasPerPubdata) : "0x",
      factoryDeps ?? [],
      customSignature ?? "0x",
      paymaster && paymasterInput ? [paymaster, paymasterInput] : []
    ];
    return (0, concat_js_1.concatHex)([
      "0x71",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializers = exports.serializeTransaction = undefined;
  var concat_js_1 = require_concat();
  var toHex_js_1 = require_toHex();
  var toRlp_js_1 = require_toRlp();
  var serializeTransaction_js_1 = require_serializeTransaction();
  var assertEip712Transaction_js_1 = require_assertEip712Transaction();
  var isEip712Transaction_js_1 = require_isEip712Transaction();
  exports.serializeTransaction = serializeTransaction;
  exports.serializers = {
    transaction: serializeTransaction
  };
});

// node_modules/viem/_cjs/zksync/constants/number.js
var require_number2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.maxBytecodeSize = undefined;
  var number_js_1 = require_number();
  exports.maxBytecodeSize = number_js_1.maxUint16 * 32n;
});

// node_modules/viem/_cjs/zksync/errors/bytecode.js
var require_bytecode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BytecodeLengthMustBeDivisibleBy32Error = exports.BytecodeLengthInWordsMustBeOddError = exports.BytecodeLengthExceedsMaxSizeError = undefined;
  var base_js_1 = require_base();

  class BytecodeLengthExceedsMaxSizeError extends base_js_1.BaseError {
    constructor({ givenLength, maxBytecodeSize }) {
      super(`Bytecode cannot be longer than ${maxBytecodeSize} bytes. Given length: ${givenLength}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BytecodeLengthExceedsMaxSizeError"
      });
    }
  }
  exports.BytecodeLengthExceedsMaxSizeError = BytecodeLengthExceedsMaxSizeError;

  class BytecodeLengthInWordsMustBeOddError extends base_js_1.BaseError {
    constructor({ givenLengthInWords }) {
      super(`Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BytecodeLengthInWordsMustBeOddError"
      });
    }
  }
  exports.BytecodeLengthInWordsMustBeOddError = BytecodeLengthInWordsMustBeOddError;

  class BytecodeLengthMustBeDivisibleBy32Error extends base_js_1.BaseError {
    constructor({ givenLength }) {
      super(`The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BytecodeLengthMustBeDivisibleBy32Error"
      });
    }
  }
  exports.BytecodeLengthMustBeDivisibleBy32Error = BytecodeLengthMustBeDivisibleBy32Error;
});

// node_modules/viem/_cjs/zksync/utils/hashBytecode.js
var require_hashBytecode = __commonJS((exports) => {
  function hashBytecode(bytecode) {
    const bytecodeBytes = (0, toBytes_js_1.toBytes)(bytecode);
    if (bytecodeBytes.length % 32 !== 0)
      throw new bytecode_js_1.BytecodeLengthMustBeDivisibleBy32Error({
        givenLength: bytecodeBytes.length
      });
    if (bytecodeBytes.length > number_js_1.maxBytecodeSize)
      throw new bytecode_js_1.BytecodeLengthExceedsMaxSizeError({
        givenLength: bytecodeBytes.length,
        maxBytecodeSize: number_js_1.maxBytecodeSize
      });
    const hashStr = (0, sha256_js_1.sha256)(bytecodeBytes);
    const hash2 = (0, toBytes_js_1.toBytes)(hashStr);
    const bytecodeLengthInWords = bytecodeBytes.length / 32;
    if (bytecodeLengthInWords % 2 === 0) {
      throw new bytecode_js_1.BytecodeLengthInWordsMustBeOddError({
        givenLengthInWords: bytecodeLengthInWords
      });
    }
    const bytecodeLength = (0, toBytes_js_1.toBytes)(bytecodeLengthInWords);
    const bytecodeLengthPadded = (0, pad_js_1.pad)(bytecodeLength, { size: 2 });
    const codeHashVersion = new Uint8Array([1, 0]);
    hash2.set(codeHashVersion, 0);
    hash2.set(bytecodeLengthPadded, 2);
    return hash2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hashBytecode = undefined;
  var pad_js_1 = require_pad();
  var toBytes_js_1 = require_toBytes();
  var sha256_js_1 = require_sha2562();
  var number_js_1 = require_number2();
  var bytecode_js_1 = require_bytecode();
  exports.hashBytecode = hashBytecode;
});

// node_modules/viem/_cjs/zksync/utils/getEip712Domain.js
var require_getEip712Domain = __commonJS((exports) => {
  function transactionToMessage(transaction) {
    const { gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
    return {
      txType: 113n,
      from: BigInt(from),
      to: to ? BigInt(to) : 0n,
      gasLimit: gas ?? 0n,
      gasPerPubdataByteLimit: gasPerPubdata ?? 0n,
      maxFeePerGas: maxFeePerGas ?? 0n,
      maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
      paymaster: paymaster ? BigInt(paymaster) : 0n,
      nonce: nonce ? BigInt(nonce) : 0n,
      value: value ?? 0n,
      data: data ? data : "0x0",
      factoryDeps: factoryDeps?.map((dep) => (0, toHex_js_1.toHex)((0, hashBytecode_js_1.hashBytecode)(dep))) ?? [],
      paymasterInput: paymasterInput ? paymasterInput : "0x"
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEip712Domain = undefined;
  var toHex_js_1 = require_toHex();
  var assertEip712Transaction_js_1 = require_assertEip712Transaction();
  var hashBytecode_js_1 = require_hashBytecode();
  var getEip712Domain = (transaction) => {
    (0, assertEip712Transaction_js_1.assertEip712Transaction)(transaction);
    const message = transactionToMessage(transaction);
    return {
      domain: {
        name: "zkSync",
        version: "2",
        chainId: transaction.chainId
      },
      types: {
        Transaction: [
          { name: "txType", type: "uint256" },
          { name: "from", type: "uint256" },
          { name: "to", type: "uint256" },
          { name: "gasLimit", type: "uint256" },
          { name: "gasPerPubdataByteLimit", type: "uint256" },
          { name: "maxFeePerGas", type: "uint256" },
          { name: "maxPriorityFeePerGas", type: "uint256" },
          { name: "paymaster", type: "uint256" },
          { name: "nonce", type: "uint256" },
          { name: "value", type: "uint256" },
          { name: "data", type: "bytes" },
          { name: "factoryDeps", type: "bytes32[]" },
          { name: "paymasterInput", type: "bytes" }
        ]
      },
      primaryType: "Transaction",
      message
    };
  };
  exports.getEip712Domain = getEip712Domain;
});

// node_modules/viem/_cjs/zksync/chainConfig.js
var require_chainConfig3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chainConfig = undefined;
  var formatters_js_1 = require_formatters3();
  var serializers_js_1 = require_serializers3();
  var getEip712Domain_js_1 = require_getEip712Domain();
  exports.chainConfig = {
    formatters: formatters_js_1.formatters,
    serializers: serializers_js_1.serializers,
    custom: {
      getEip712Domain: getEip712Domain_js_1.getEip712Domain
    }
  };
});

// node_modules/viem/_cjs/chains/definitions/playfiAlbireo.js
var require_playfiAlbireo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.playfiAlbireo = undefined;
  var defineChain_js_1 = require_defineChain();
  var chainConfig_js_1 = require_chainConfig3();
  exports.playfiAlbireo = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 1612127,
    name: "PlayFi Albireo Testnet",
    network: "albireo",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://albireo-rpc.playfi.ai"],
        webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "PlayFi Albireo Explorer",
        url: "https://albireo-explorer.playfi.ai"
      }
    },
    contracts: {
      multicall3: {
        address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/pgn.js
var require_pgn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pgn = undefined;
  var formatters_js_1 = require_formatters();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.pgn = (0, defineChain_js_1.defineChain)({
    id: 424,
    network: "pgn",
    name: "PGN",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.publicgoods.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "PGN Explorer",
        url: "https://explorer.publicgoods.network",
        apiUrl: "https://explorer.publicgoods.network/api"
      },
      blocksout: {
        name: "PGN Explorer",
        url: "https://explorer.publicgoods.network",
        apiUrl: "https://explorer.publicgoods.network/api"
      }
    },
    contracts: {
      l2OutputOracle: {
        [sourceId]: {
          address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
        }
      },
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 3380209
      },
      portal: {
        [sourceId]: {
          address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
        }
      }
    },
    formatters: formatters_js_1.formatters,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/pgnTestnet.js
var require_pgnTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pgnTestnet = undefined;
  var formatters_js_1 = require_formatters();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.pgnTestnet = (0, defineChain_js_1.defineChain)({
    id: 58008,
    network: "pgn-testnet",
    name: "PGN ",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.publicgoods.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "PGN Testnet Explorer",
        url: "https://explorer.sepolia.publicgoods.network",
        apiUrl: "https://explorer.sepolia.publicgoods.network/api"
      },
      blocksout: {
        name: "PGN Testnet Explorer",
        url: "https://explorer.sepolia.publicgoods.network",
        apiUrl: "https://explorer.sepolia.publicgoods.network/api"
      }
    },
    contracts: {
      l2OutputOracle: {
        [sourceId]: {
          address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
        }
      },
      portal: {
        [sourceId]: {
          address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
        }
      },
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 3754925
      }
    },
    formatters: formatters_js_1.formatters,
    sourceId,
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/phoenix.js
var require_phoenix = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.phoenix = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.phoenix = (0, defineChain_js_1.defineChain)({
    id: 13381,
    name: "Phoenix Blockchain",
    nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.phoenixplorer.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Phoenixplorer",
        url: "https://phoenixplorer.com",
        apiUrl: "https://phoenixplorer.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
        blockCreated: 5620192
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/plinga.js
var require_plinga = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.plinga = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.plinga = (0, defineChain_js_1.defineChain)({
    id: 242,
    name: "Plinga",
    nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpcurl.mainnet.plgchain.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Plgscan",
        url: "https://www.plgscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0x0989576160f2e7092908BB9479631b901060b6e4",
        blockCreated: 204489
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/plumeTestnet.js
var require_plumeTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.plumeTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.plumeTestnet = (0, defineChain_js_1.defineChain)({
    id: 161221135,
    name: "Plume Testnet",
    nativeCurrency: {
      name: "Plume Sepolia Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://testnet-rpc.plumenetwork.xyz/http"],
        webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://testnet-explorer.plumenetwork.xyz",
        apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/polygon.js
var require_polygon = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.polygon = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.polygon = (0, defineChain_js_1.defineChain)({
    id: 137,
    name: "Polygon",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://polygon-rpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://polygonscan.com",
        apiUrl: "https://api.polygonscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/polygonAmoy.js
var require_polygonAmoy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.polygonAmoy = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.polygonAmoy = (0, defineChain_js_1.defineChain)({
    id: 80002,
    name: "Polygon Amoy",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc-amoy.polygon.technology"]
      }
    },
    blockExplorers: {
      default: {
        name: "OK LINK",
        url: "https://www.oklink.com/amoy"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 3127388
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/polygonMumbai.js
var require_polygonMumbai = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.polygonMumbai = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.polygonMumbai = (0, defineChain_js_1.defineChain)({
    id: 80001,
    name: "Polygon Mumbai",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.ankr.com/polygon_mumbai"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com",
        apiUrl: "https://api-testnet.polygonscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js
var require_polygonZkEvm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.polygonZkEvm = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.polygonZkEvm = (0, defineChain_js_1.defineChain)({
    id: 1101,
    name: "Polygon zkEVM",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://zkevm-rpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://zkevm.polygonscan.com",
        apiUrl: "https://api-zkevm.polygonscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 57746
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/polygonZkEvmCardona.js
var require_polygonZkEvmCardona = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.polygonZkEvmCardona = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.polygonZkEvmCardona = (0, defineChain_js_1.defineChain)({
    id: 2442,
    name: "Polygon zkEVM Cardona",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.cardona.zkevm-rpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://cardona-zkevm.polygonscan.com",
        apiUrl: "https://cardona-zkevm.polygonscan.com/api"
      }
    },
    testnet: true,
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 114091
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js
var require_polygonZkEvmTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.polygonZkEvmTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.polygonZkEvmTestnet = (0, defineChain_js_1.defineChain)({
    id: 1442,
    name: "Polygon zkEVM Testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.public.zkevm-test.net"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://testnet-zkevm.polygonscan.com",
        apiUrl: "https://testnet-zkevm.polygonscan.com/api"
      }
    },
    testnet: true,
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 525686
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/pulsechain.js
var require_pulsechain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pulsechain = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.pulsechain = (0, defineChain_js_1.defineChain)({
    id: 369,
    name: "PulseChain",
    nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
    testnet: false,
    rpcUrls: {
      default: {
        http: ["https://rpc.pulsechain.com"],
        webSocket: ["wss://ws.pulsechain.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PulseScan",
        url: "https://scan.pulsechain.com",
        apiUrl: "https://api.scan.pulsechain.com/api"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/pulsechainV4.js
var require_pulsechainV4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pulsechainV4 = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.pulsechainV4 = (0, defineChain_js_1.defineChain)({
    id: 943,
    name: "PulseChain V4",
    testnet: true,
    nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.v4.testnet.pulsechain.com"],
        webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PulseScan",
        url: "https://scan.v4.testnet.pulsechain.com",
        apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/qMainnet.js
var require_qMainnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.qMainnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.qMainnet = (0, defineChain_js_1.defineChain)({
    id: 35441,
    name: "Q Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Q",
      symbol: "Q"
    },
    rpcUrls: {
      default: { http: ["https://rpc.q.org"] }
    },
    blockExplorers: {
      default: {
        name: "Q Mainnet Explorer",
        url: "https://explorer.q.org",
        apiUrl: "https://explorer.q.org/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/qTestnet.js
var require_qTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.qTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.qTestnet = (0, defineChain_js_1.defineChain)({
    id: 35443,
    name: "Q Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Q",
      symbol: "Q"
    },
    rpcUrls: {
      default: { http: ["https://rpc.qtestnet.org"] }
    },
    blockExplorers: {
      default: {
        name: "Q Testnet Explorer",
        url: "https://explorer.qtestnet.org",
        apiUrl: "https://explorer.qtestnet.org/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/reyaNetwork.js
var require_reyaNetwork = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reyaNetwork = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.reyaNetwork = (0, defineChain_js_1.defineChain)({
    id: 1729,
    name: "Reya Network",
    nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
    rpcUrls: {
      default: {
        http: ["https://rpc.reya.network"],
        webSocket: ["wss://ws.reya.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Reya Network Explorer",
        url: "https://explorer.reya.network"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/rollux.js
var require_rollux = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rollux = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.rollux = (0, defineChain_js_1.defineChain)({
    id: 570,
    name: "Rollux Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Syscoin",
      symbol: "SYS"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.rollux.com"],
        webSocket: ["wss://rpc.rollux.com/wss"]
      }
    },
    blockExplorers: {
      default: {
        name: "RolluxExplorer",
        url: "https://explorer.rollux.com",
        apiUrl: "https://explorer.rollux.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 119222
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js
var require_rolluxTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rolluxTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.rolluxTestnet = (0, defineChain_js_1.defineChain)({
    id: 57000,
    name: "Rollux Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Syscoin",
      symbol: "SYS"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc-tanenbaum.rollux.com/"],
        webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
      }
    },
    blockExplorers: {
      default: {
        name: "RolluxTestnetExplorer",
        url: "https://rollux.tanenbaum.io",
        apiUrl: "https://rollux.tanenbaum.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1813675
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/ronin.js
var require_ronin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ronin = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.ronin = (0, defineChain_js_1.defineChain)({
    id: 2020,
    name: "Ronin",
    nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://api.roninchain.com/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Ronin Explorer",
        url: "https://app.roninchain.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 26023535
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/rootstock.js
var require_rootstock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rootstock = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.rootstock = (0, defineChain_js_1.defineChain)({
    id: 30,
    name: "Rootstock Mainnet",
    network: "rootstock",
    nativeCurrency: {
      decimals: 18,
      name: "Rootstock Bitcoin",
      symbol: "RBTC"
    },
    rpcUrls: {
      default: { http: ["https://public-node.rsk.co"] }
    },
    blockExplorers: {
      default: {
        name: "RSK Explorer",
        url: "https://explorer.rsk.co"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 4249540
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/rss3.js
var require_rss3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rss3 = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.rss3 = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 12553,
    name: "RSS3 VSL Mainnet",
    nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.rss3.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "RSS3 VSL Mainnet Scan",
        url: "https://scan.rss3.io",
        apiUrl: "https://scan.rss3.io/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14193
      },
      portal: {
        [sourceId]: {
          address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
          blockCreated: 19387057
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/rss3Sepolia.js
var require_rss3Sepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rss3Sepolia = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.rss3Sepolia = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 2331,
    name: "RSS3 VSL Sepolia Testnet",
    nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.testnet.rss3.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "RSS3 VSL Sepolia Testnet Scan",
        url: "https://scan.testnet.rss3.io",
        apiUrl: "https://scan.testnet.rss3.io/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 55697
      },
      portal: {
        [sourceId]: {
          address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
          blockCreated: 5345035
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
        }
      }
    },
    testnet: true,
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/saigon.js
var require_saigon = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.saigon = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.saigon = (0, defineChain_js_1.defineChain)({
    id: 2021,
    name: "Saigon Testnet",
    nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://saigon-testnet.roninchain.com/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Saigon Explorer",
        url: "https://saigon-app.roninchain.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 18736871
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/sapphire.js
var require_sapphire = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sapphire = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.sapphire = (0, defineChain_js_1.defineChain)({
    id: 23294,
    name: "Oasis Sapphire",
    network: "sapphire",
    nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sapphire.oasis.io"],
        webSocket: ["wss://sapphire.oasis.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Oasis Sapphire Explorer",
        url: "https://explorer.sapphire.oasis.io",
        apiUrl: "https://explorer.sapphire.oasis.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 734531
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/sapphireTestnet.js
var require_sapphireTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sapphireTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.sapphireTestnet = (0, defineChain_js_1.defineChain)({
    id: 23295,
    name: "Oasis Sapphire Testnet",
    network: "sapphire-testnet",
    nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.sapphire.oasis.dev"],
        webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Oasis Sapphire Testnet Explorer",
        url: "https://testnet.explorer.sapphire.oasis.dev",
        apiUrl: "https://testnet.explorer.sapphire.oasis.dev/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/scroll.js
var require_scroll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scroll = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.scroll = (0, defineChain_js_1.defineChain)({
    id: 534352,
    name: "Scroll",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.scroll.io"],
        webSocket: ["wss://wss-rpc.scroll.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Scrollscan",
        url: "https://scrollscan.com",
        apiUrl: "https://api.scrollscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/scrollSepolia.js
var require_scrollSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scrollSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.scrollSepolia = (0, defineChain_js_1.defineChain)({
    id: 534351,
    name: "Scroll Sepolia",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia-rpc.scroll.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://sepolia-blockscout.scroll.io",
        apiUrl: "https://sepolia-blockscout.scroll.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 9473
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/scrollTestnet.js
var require_scrollTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scrollTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.scrollTestnet = (0, defineChain_js_1.defineChain)({
    id: 534353,
    name: "Scroll Testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://alpha-rpc.scroll.io/l2"],
        webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://blockscout.scroll.io",
        apiUrl: "https://blockscout.scroll.io/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/seiDevnet.js
var require_seiDevnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.seiDevnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.seiDevnet = (0, defineChain_js_1.defineChain)({
    id: 713715,
    name: "Sei Devnet",
    nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://evm-rpc-arctic-1.sei-apis.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Seitrace",
        url: "https://seitrace.com"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/sepolia.js
var require_sepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.sepolia = (0, defineChain_js_1.defineChain)({
    id: 11155111,
    name: "Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.sepolia.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://sepolia.etherscan.io",
        apiUrl: "https://api-sepolia.etherscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 751532
      },
      ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
      ensUniversalResolver: {
        address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
        blockCreated: 5317080
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/shimmer.js
var require_shimmer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shimmer = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.shimmer = (0, defineChain_js_1.defineChain)({
    id: 148,
    name: "Shimmer",
    network: "shimmer",
    nativeCurrency: {
      decimals: 18,
      name: "Shimmer",
      symbol: "SMR"
    },
    rpcUrls: {
      default: {
        http: ["https://json-rpc.evm.shimmer.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Shimmer Network Explorer",
        url: "https://explorer.evm.shimmer.network",
        apiUrl: "https://explorer.evm.shimmer.network/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/shimmerTestnet.js
var require_shimmerTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shimmerTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.shimmerTestnet = (0, defineChain_js_1.defineChain)({
    id: 1073,
    name: "Shimmer Testnet",
    network: "shimmer-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Shimmer",
      symbol: "SMR"
    },
    rpcUrls: {
      default: {
        http: ["https://json-rpc.evm.testnet.shimmer.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Shimmer Network Explorer",
        url: "https://explorer.evm.testnet.shimmer.network",
        apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/brawl.js
var require_brawl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleBlockBrawlers = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleBlockBrawlers = (0, defineChain_js_1.defineChain)({
    id: 391845894,
    name: "SKALE | Block Brawlers",
    nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/calypso.js
var require_calypso = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleCalypso = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleCalypso = (0, defineChain_js_1.defineChain)({
    id: 1564830818,
    name: "SKALE | Calypso NFT Hub",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
        webSocket: [
          "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
        ]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 3107626
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js
var require_calypsoTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleCalypsoTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleCalypsoTestnet = (0, defineChain_js_1.defineChain)({
    id: 974399131,
    name: "SKALE Calypso Testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
        webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 103220
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js
var require_cryptoBlades = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleCryptoBlades = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleCryptoBlades = (0, defineChain_js_1.defineChain)({
    id: 1026062157,
    name: "SKALE | CryptoBlades",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
        webSocket: [
          "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
        ]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js
var require_cryptoColosseum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleCryptoColosseum = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleCryptoColosseum = (0, defineChain_js_1.defineChain)({
    id: 2046399126,
    name: "SKALE | Crypto Colosseum",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/europa.js
var require_europa = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleEuropa = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleEuropa = (0, defineChain_js_1.defineChain)({
    id: 2046399126,
    name: "SKALE | Europa Liquidity Hub",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 3113495
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js
var require_europaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleEuropaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleEuropaTestnet = (0, defineChain_js_1.defineChain)({
    id: 1444673419,
    name: "SKALE Europa Testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
        webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 110858
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/exorde.js
var require_exorde = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleExorde = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleExorde = (0, defineChain_js_1.defineChain)({
    id: 2139927552,
    name: "SKALE | Exorde",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js
var require_humanProtocol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleHumanProtocol = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleHumanProtocol = (0, defineChain_js_1.defineChain)({
    id: 1273227453,
    name: "SKALE | Human Protocol",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/nebula.js
var require_nebula = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleNebula = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleNebula = (0, defineChain_js_1.defineChain)({
    id: 1482601649,
    name: "SKALE | Nebula Gaming Hub",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 2372986
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js
var require_nebulaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleNebulaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleNebulaTestnet = (0, defineChain_js_1.defineChain)({
    id: 37084624,
    name: "SKALE Nebula Testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
        webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 105141
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/razor.js
var require_razor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleRazor = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleRazor = (0, defineChain_js_1.defineChain)({
    id: 278611351,
    name: "SKALE | Razor Network",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/titan.js
var require_titan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleTitan = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleTitan = (0, defineChain_js_1.defineChain)({
    id: 1350216234,
    name: "SKALE | Titan Community Hub",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
        webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 2076458
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js
var require_titanTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skaleTitanTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.skaleTitanTestnet = (0, defineChain_js_1.defineChain)({
    id: 1020352220,
    name: "SKALE Titan Hub",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
        webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
      }
    },
    blockExplorers: {
      default: {
        name: "SKALE Explorer",
        url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 104072
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/songbird.js
var require_songbird = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.songbird = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.songbird = (0, defineChain_js_1.defineChain)({
    id: 19,
    name: "Songbird Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "songbird",
      symbol: "SGB"
    },
    rpcUrls: {
      default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Songbird Explorer",
        url: "https://songbird-explorer.flare.network",
        apiUrl: "https://songbird-explorer.flare.network/api"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js
var require_songbirdTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.songbirdTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.songbirdTestnet = (0, defineChain_js_1.defineChain)({
    id: 16,
    name: "Coston",
    nativeCurrency: {
      decimals: 18,
      name: "costonflare",
      symbol: "CFLR"
    },
    rpcUrls: {
      default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Coston Explorer",
        url: "https://coston-explorer.flare.network",
        apiUrl: "https://coston-explorer.flare.network/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/spicy.js
var require_spicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.spicy = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.spicy = (0, defineChain_js_1.defineChain)({
    id: 88882,
    name: "Chiliz Spicy Testnet",
    network: "chiliz-spicy-Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "CHZ",
      symbol: "CHZ"
    },
    rpcUrls: {
      default: {
        http: [
          "https://spicy-rpc.chiliz.com",
          "https://chiliz-spicy-rpc.publicnode.com"
        ],
        webSocket: [
          "wss://spicy-rpc-ws.chiliz.com",
          "wss://chiliz-spicy-rpc.publicnode.com"
        ]
      }
    },
    blockExplorers: {
      default: {
        name: "Chiliz Explorer",
        url: "http://spicy-explorer.chiliz.com",
        apiUrl: "http://spicy-explorer.chiliz.com/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js
var require_shardeumSphinx = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shardeumSphinx = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.shardeumSphinx = (0, defineChain_js_1.defineChain)({
    id: 8082,
    name: "Shardeum Sphinx",
    nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sphinx.shardeum.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Shardeum Explorer",
        url: "https://explorer-sphinx.shardeum.org"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/shibarium.js
var require_shibarium = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shibarium = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.shibarium = (0, defineChain_js_1.defineChain)({
    id: 109,
    name: "Shibarium",
    network: "shibarium",
    nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.shibrpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://shibariumscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
        blockCreated: 265900
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/stratis.js
var require_stratis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stratis = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.stratis = (0, defineChain_js_1.defineChain)({
    id: 105105,
    name: "Stratis Mainnet",
    network: "stratis",
    nativeCurrency: {
      name: "Stratis",
      symbol: "STRAX",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.stratisevm.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Stratis Explorer",
        url: "https://explorer.stratisevm.com"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/syscoin.js
var require_syscoin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.syscoin = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.syscoin = (0, defineChain_js_1.defineChain)({
    id: 57,
    name: "Syscoin Mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Syscoin",
      symbol: "SYS"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.syscoin.org"],
        webSocket: ["wss://rpc.syscoin.org/wss"]
      }
    },
    blockExplorers: {
      default: {
        name: "SyscoinExplorer",
        url: "https://explorer.syscoin.org",
        apiUrl: "https://explorer.syscoin.org/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 287139
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js
var require_syscoinTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.syscoinTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.syscoinTestnet = (0, defineChain_js_1.defineChain)({
    id: 5700,
    name: "Syscoin Tanenbaum Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Syscoin",
      symbol: "SYS"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.tanenbaum.io"],
        webSocket: ["wss://rpc.tanenbaum.io/wss"]
      }
    },
    blockExplorers: {
      default: {
        name: "SyscoinTestnetExplorer",
        url: "https://tanenbaum.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 271288
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/taraxa.js
var require_taraxa = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.taraxa = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.taraxa = (0, defineChain_js_1.defineChain)({
    id: 841,
    name: "Taraxa Mainnet",
    nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.mainnet.taraxa.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Taraxa Explorer",
        url: "https://explorer.mainnet.taraxa.io"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/taikoHekla.js
var require_taikoHekla = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.taikoHekla = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.taikoHekla = (0, defineChain_js_1.defineChain)({
    id: 167009,
    name: "Taiko Hekla L2",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.hekla.taiko.xyz"]
      }
    },
    blockExplorers: {
      default: {
        name: "Taikoscan",
        url: "https://hekla.taikoscan.network"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/taikoJolnir.js
var require_taikoJolnir = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.taikoJolnir = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.taikoJolnir = (0, defineChain_js_1.defineChain)({
    id: 167007,
    name: "Taiko Jolnir (Alpha-5 Testnet)",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.jolnir.taiko.xyz"]
      }
    },
    blockExplorers: {
      default: {
        name: "blockscout",
        url: "https://explorer.jolnir.taiko.xyz"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 732706
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/taikoKatla.js
var require_taikoKatla = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.taikoKatla = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.taikoKatla = (0, defineChain_js_1.defineChain)({
    id: 167008,
    name: "Taiko Katla (Alpha-6 Testnet)",
    network: "tko-katla",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.katla.taiko.xyz"]
      },
      public: {
        http: ["https://rpc.katla.taiko.xyz"]
      }
    },
    blockExplorers: {
      default: {
        name: "blockscout",
        url: "https://explorer.katla.taiko.xyz"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js
var require_taikoTestnetSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.taikoTestnetSepolia = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.taikoTestnetSepolia = (0, defineChain_js_1.defineChain)({
    id: 167005,
    name: "Taiko (Alpha-3 Testnet)",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.test.taiko.xyz"]
      }
    },
    blockExplorers: {
      default: {
        name: "blockscout",
        url: "https://explorer.test.taiko.xyz"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js
var require_taraxaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.taraxaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.taraxaTestnet = (0, defineChain_js_1.defineChain)({
    id: 842,
    name: "Taraxa Testnet",
    nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.testnet.taraxa.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Taraxa Explorer",
        url: "https://explorer.testnet.taraxa.io"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/telos.js
var require_telos = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.telos = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.telos = (0, defineChain_js_1.defineChain)({
    id: 40,
    name: "Telos",
    nativeCurrency: {
      decimals: 18,
      name: "Telos",
      symbol: "TLOS"
    },
    rpcUrls: {
      default: { http: ["https://mainnet.telos.net/evm"] }
    },
    blockExplorers: {
      default: {
        name: "Teloscan",
        url: "https://www.teloscan.io/"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 246530709
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/telosTestnet.js
var require_telosTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.telosTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.telosTestnet = (0, defineChain_js_1.defineChain)({
    id: 41,
    name: "Telos",
    nativeCurrency: {
      decimals: 18,
      name: "Telos",
      symbol: "TLOS"
    },
    rpcUrls: {
      default: { http: ["https://testnet.telos.net/evm"] }
    },
    blockExplorers: {
      default: {
        name: "Teloscan (testnet)",
        url: "https://testnet.teloscan.io/"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/tenet.js
var require_tenet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tenet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.tenet = (0, defineChain_js_1.defineChain)({
    id: 1559,
    name: "Tenet",
    network: "tenet-mainnet",
    nativeCurrency: {
      name: "TENET",
      symbol: "TENET",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://rpc.tenet.org"] }
    },
    blockExplorers: {
      default: {
        name: "TenetScan Mainnet",
        url: "https://tenetscan.io",
        apiUrl: "https://tenetscan.io/api"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/thunderTestnet.js
var require_thunderTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.thunderTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.thunderTestnet = (0, defineChain_js_1.defineChain)({
    id: 997,
    name: "5ireChain Thunder Testnet",
    nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc-testnet.5ire.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "5ireChain Explorer",
        url: "https://explorer.5ire.network"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/vechain.js
var require_vechain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.vechain = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.vechain = (0, defineChain_js_1.defineChain)({
    id: 100009,
    name: "Vechain",
    nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.vechain.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Vechain Explorer",
        url: "https://explore.vechain.org"
      },
      vechainStats: {
        name: "Vechain Stats",
        url: "https://vechainstats.com"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/wanchain.js
var require_wanchain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wanchain = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.wanchain = (0, defineChain_js_1.defineChain)({
    id: 888,
    name: "Wanchain",
    nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://gwan-ssl.wandevs.org:56891",
          "https://gwan2-ssl.wandevs.org"
        ]
      }
    },
    blockExplorers: {
      default: {
        name: "WanScan",
        url: "https://wanscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
        blockCreated: 25312390
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js
var require_wanchainTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wanchainTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.wanchainTestnet = (0, defineChain_js_1.defineChain)({
    id: 999,
    name: "Wanchain Testnet",
    nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://gwan-ssl.wandevs.org:46891"]
      }
    },
    blockExplorers: {
      default: {
        name: "WanScanTest",
        url: "https://wanscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
        blockCreated: 24743448
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/wemix.js
var require_wemix = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wemix = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.wemix = (0, defineChain_js_1.defineChain)({
    id: 1111,
    name: "WEMIX",
    network: "wemix-mainnet",
    nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://api.wemix.com"] },
      public: { http: ["https://api.wemix.com"] }
    },
    blockExplorers: {
      default: {
        name: "wemixExplorer",
        url: "https://explorer.wemix.com"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/wemixTestnet.js
var require_wemixTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wemixTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.wemixTestnet = (0, defineChain_js_1.defineChain)({
    id: 1112,
    name: "WEMIX Testnet",
    network: "wemix-testnet",
    nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://api.test.wemix.com"] },
      public: { http: ["https://api.test.wemix.com"] }
    },
    blockExplorers: {
      default: {
        name: "wemixExplorer",
        url: "https://testnet.wemixscan.com",
        apiUrl: "https://testnet.wemixscan.com/api"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/x1Testnet.js
var require_x1Testnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.x1Testnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.x1Testnet = (0, defineChain_js_1.defineChain)({
    id: 195,
    name: "X1 Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "OKB",
      symbol: "OKB"
    },
    rpcUrls: {
      default: { http: ["https://x1testrpc.okx.com"] }
    },
    blockExplorers: {
      default: {
        name: "OKLink",
        url: "https://www.oklink.com/x1-test"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 624344
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/xdc.js
var require_xdc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.xdc = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.xdc = (0, defineChain_js_1.defineChain)({
    id: 50,
    name: "XinFin Network",
    nativeCurrency: {
      decimals: 18,
      name: "XDC",
      symbol: "XDC"
    },
    rpcUrls: {
      default: { http: ["https://rpc.xinfin.network"] }
    },
    blockExplorers: {
      xinfin: {
        name: "XinFin",
        url: "https://explorer.xinfin.network"
      },
      default: {
        name: "Blocksscan",
        url: "https://xdc.blocksscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 71542788
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/xdcTestnet.js
var require_xdcTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.xdcTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.xdcTestnet = (0, defineChain_js_1.defineChain)({
    id: 51,
    name: "Apothem Network",
    nativeCurrency: {
      decimals: 18,
      name: "TXDC",
      symbol: "TXDC"
    },
    rpcUrls: {
      default: { http: ["https://erpc.apothem.network"] }
    },
    blockExplorers: {
      default: {
        name: "Blocksscan",
        url: "https://apothem.blocksscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 59765389
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/zetachain.js
var require_zetachain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zetachain = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.zetachain = (0, defineChain_js_1.defineChain)({
    id: 7000,
    name: "ZetaChain",
    nativeCurrency: {
      decimals: 18,
      name: "Zeta",
      symbol: "ZETA"
    },
    rpcUrls: {
      default: {
        http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
      }
    },
    blockExplorers: {
      default: {
        name: "ZetaScan",
        url: "https://explorer.zetachain.com"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js
var require_zetachainAthensTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zetachainAthensTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.zetachainAthensTestnet = (0, defineChain_js_1.defineChain)({
    id: 7001,
    name: "ZetaChain Athens Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Zeta",
      symbol: "aZETA"
    },
    rpcUrls: {
      default: {
        http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
      }
    },
    blockExplorers: {
      default: {
        name: "ZetaScan",
        url: "https://athens.explorer.zetachain.com"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zhejiang.js
var require_zhejiang = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zhejiang = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.zhejiang = (0, defineChain_js_1.defineChain)({
    id: 1337803,
    name: "Zhejiang",
    nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.zhejiang.ethpandaops.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Beaconchain",
        url: "https://zhejiang.beaconcha.in"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zilliqa.js
var require_zilliqa = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zilliqa = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.zilliqa = (0, defineChain_js_1.defineChain)({
    id: 32769,
    name: "Zilliqa",
    network: "zilliqa",
    nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://api.zilliqa.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Ethernal",
        url: "https://evmx.zilliqa.com"
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/zilliqaTestnet.js
var require_zilliqaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zilliqaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.zilliqaTestnet = (0, defineChain_js_1.defineChain)({
    id: 33101,
    name: "Zilliqa Testnet",
    network: "zilliqa-testnet",
    nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://dev-api.zilliqa.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Ethernal",
        url: "https://evmx.testnet.zilliqa.com"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zkFair.js
var require_zkFair = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zkFair = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.zkFair = (0, defineChain_js_1.defineChain)({
    id: 42766,
    name: "ZKFair Mainnet",
    network: "zkfair-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "USD Coin",
      symbol: "USDC"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.zkfair.io"]
      },
      public: {
        http: ["https://rpc.zkfair.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkFair Explorer",
        url: "https://scan.zkfair.io",
        apiUrl: "https://scan.zkfair.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6090959
      }
    },
    testnet: false
  });
});

// node_modules/viem/_cjs/chains/definitions/zkFairTestnet.js
var require_zkFairTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zkFairTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  exports.zkFairTestnet = (0, defineChain_js_1.defineChain)({
    id: 43851,
    name: "ZKFair Testnet",
    network: "zkfair-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "USD Coin",
      symbol: "USDC"
    },
    rpcUrls: {
      default: {
        http: ["https://testnet-rpc.zkfair.io"]
      },
      public: {
        http: ["https://testnet-rpc.zkfair.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkFair Explorer",
        url: "https://testnet-scan.zkfair.io"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zkSync.js
var require_zkSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zkSync = undefined;
  var defineChain_js_1 = require_defineChain();
  var chainConfig_js_1 = require_chainConfig3();
  exports.zkSync = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 324,
    name: "zkSync Era",
    network: "zksync-era",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://mainnet.era.zksync.io"],
        webSocket: ["wss://mainnet.era.zksync.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://era.zksync.network/",
        apiUrl: "https://api-era.zksync.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
      }
    }
  });
});

// node_modules/viem/_cjs/chains/definitions/zkSyncInMemoryNode.js
var require_zkSyncInMemoryNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zkSyncInMemoryNode = undefined;
  var defineChain_js_1 = require_defineChain();
  var chainConfig_js_1 = require_chainConfig3();
  exports.zkSyncInMemoryNode = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 260,
    name: "zkSync InMemory Node",
    network: "zksync-in-memory-node",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["http://localhost:8011"]
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zkSyncLocalNode.js
var require_zkSyncLocalNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zkSyncLocalNode = undefined;
  var defineChain_js_1 = require_defineChain();
  var chainConfig_js_1 = require_chainConfig3();
  exports.zkSyncLocalNode = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 270,
    name: "zkSync CLI Local Node",
    network: "zksync-cli-local-node",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["http://localhost:3050"]
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zkSyncSepoliaTestnet.js
var require_zkSyncSepoliaTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zkSyncSepoliaTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  var chainConfig_js_1 = require_chainConfig3();
  exports.zkSyncSepoliaTestnet = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 300,
    name: "zkSync Sepolia Testnet",
    network: "zksync-sepolia-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.era.zksync.dev"],
        webSocket: ["wss://sepolia.era.zksync.dev/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkExplorer",
        url: "https://sepolia.explorer.zksync.io/"
      }
    },
    contracts: {
      multicall3: {
        address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js
var require_zkSyncTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zkSyncTestnet = undefined;
  var defineChain_js_1 = require_defineChain();
  var chainConfig_js_1 = require_chainConfig3();
  exports.zkSyncTestnet = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 280,
    name: "zkSync Era Testnet",
    network: "zksync-era-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.era.zksync.dev"],
        webSocket: ["wss://testnet.era.zksync.dev/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkExplorer",
        url: "https://goerli.explorer.zksync.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
      }
    },
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zora.js
var require_zora = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zora = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 1;
  exports.zora = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 7777777,
    name: "Zora",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.zora.energy"],
        webSocket: ["wss://rpc.zora.energy"]
      }
    },
    blockExplorers: {
      default: {
        name: "Explorer",
        url: "https://explorer.zora.energy",
        apiUrl: "https://explorer.zora.energy/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
        }
      },
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 5882
      },
      portal: {
        [sourceId]: {
          address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
        }
      }
    },
    sourceId
  });
});

// node_modules/viem/_cjs/chains/definitions/zoraSepolia.js
var require_zoraSepolia = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zoraSepolia = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 11155111;
  exports.zoraSepolia = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 999999999,
    name: "Zora Sepolia",
    network: "zora-sepolia",
    nativeCurrency: {
      decimals: 18,
      name: "Zora Sepolia",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://sepolia.rpc.zora.energy"],
        webSocket: ["wss://sepolia.rpc.zora.energy"]
      }
    },
    blockExplorers: {
      default: {
        name: "Zora Sepolia Explorer",
        url: "https://sepolia.explorer.zora.energy/",
        apiUrl: "https://sepolia.explorer.zora.energy/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
        }
      },
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 83160
      },
      portal: {
        [sourceId]: {
          address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
        }
      }
    },
    sourceId,
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/definitions/zoraTestnet.js
var require_zoraTestnet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zoraTestnet = undefined;
  var chainConfig_js_1 = require_chainConfig();
  var defineChain_js_1 = require_defineChain();
  var sourceId = 5;
  exports.zoraTestnet = (0, defineChain_js_1.defineChain)({
    ...chainConfig_js_1.chainConfig,
    id: 999,
    name: "Zora Goerli Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Zora Goerli",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://testnet.rpc.zora.energy"],
        webSocket: ["wss://testnet.rpc.zora.energy"]
      }
    },
    blockExplorers: {
      default: {
        name: "Explorer",
        url: "https://testnet.explorer.zora.energy",
        apiUrl: "https://testnet.explorer.zora.energy/api"
      }
    },
    contracts: {
      ...chainConfig_js_1.chainConfig.contracts,
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 189123
      },
      portal: {
        [sourceId]: {
          address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
        }
      }
    },
    sourceId,
    testnet: true
  });
});

// node_modules/viem/_cjs/chains/index.js
var require_chains = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cronos = exports.coreDao = exports.confluxESpaceTestnet = exports.confluxESpace = exports.classic = exports.chiliz = exports.celoAlfajores = exports.celo = exports.canto = exports.bxnTestnet = exports.bxn = exports.bscGreenfield = exports.bscTestnet = exports.bsc = exports.bronosTestnet = exports.bronos = exports.boba = exports.blastSepolia = exports.blast = exports.bitTorrentTestnet = exports.bitTorrent = exports.bevmMainnet = exports.berachainTestnet = exports.bearNetworkChainTestnet = exports.bearNetworkChainMainnet = exports.beamTestnet = exports.beam = exports.baseSepolia = exports.baseGoerli = exports.base = exports.bahamut = exports.avalancheFuji = exports.avalanche = exports.auroria = exports.auroraTestnet = exports.aurora = exports.areonNetworkTestnet = exports.areonNetwork = exports.arbitrumSepolia = exports.astarZkyoto = exports.astarZkEVM = exports.astar = exports.arbitrumNova = exports.arbitrumGoerli = exports.arbitrum = exports.apexTestnet = exports.anvil = exports.ancient8Sepolia = exports.ancient8 = exports.acala = undefined;
  exports.hederaTestnet = exports.hedera = exports.haqqTestedge2 = exports.haqqMainnet = exports.harmonyOne = exports.hardhat = exports.gnosisChiado = exports.gnosis = exports.goerli = exports.gobi = exports.karura = exports.jbc = exports.iotexTestnet = exports.iotex = exports.fuseSparknet = exports.fuse = exports.fraxtalTestnet = exports.fraxtal = exports.foundry = exports.flowMainnet = exports.flowPreviewnet = exports.flareTestnet = exports.flare = exports.filecoinHyperspace = exports.filecoinCalibration = exports.filecoin = exports.fibo = exports.fantomTestnet = exports.fantomSonicTestnet = exports.fantom = exports.ektaTestnet = exports.ekta = exports.evmosTestnet = exports.evmos = exports.etherlinkTestnet = exports.eosTestnet = exports.eos = exports.eon = exports.edgewareTestnet = exports.edgeware = exports.edgelessTestnet = exports.edgeless = exports.dogechain = exports.dfk = exports.degen = exports.defichainEvmTestnet = exports.defichainEvm = exports.darwinia = exports.crossbell = exports.cronosTestnet = undefined;
  exports.nexi = exports.neonMainnet = exports.neonDevnet = exports.morphSepolia = exports.moonriver = exports.moonbeamDev = exports.moonbeam = exports.moonbaseAlpha = exports.modeTestnet = exports.mode = exports.mintSepoliaTestnet = exports.mevTestnet = exports.mev = exports.metisGoerli = exports.metis = exports.meterTestnet = exports.meter = exports.metachainIstanbul = exports.metachain = exports.merlin = exports.mantleTestnet = exports.mantleSepoliaTestnet = exports.mantle = exports.mantaTestnet = exports.mantaSepoliaTestnet = exports.manta = exports.mandala = exports.mainnet = exports.luksoTestnet = exports.lukso = exports.localhost = exports.liskSepolia = exports.lineaTestnet = exports.lineaSepolia = exports.lineaGoerli = exports.linea = exports.lightlinkPhoenix = exports.lightlinkPegasus = exports.kromaSepolia = exports.kroma = exports.klaytnBaobab = exports.klaytn = exports.kcc = exports.kavaTestnet = exports.kava = exports.kakarotSepolia = exports.immutableZkEvmTestnet = exports.immutableZkEvm = exports.holesky = exports.hederaPreviewnet = undefined;
  exports.skaleCryptoColosseum = exports.skaleCryptoBlades = exports.skaleCalypsoTestnet = exports.skaleCalypso = exports.skaleBlockBrawlers = exports.shimmerTestnet = exports.shimmer = exports.sepolia = exports.seiDevnet = exports.scrollTestnet = exports.scrollSepolia = exports.scroll = exports.sapphireTestnet = exports.sapphire = exports.saigon = exports.rss3Sepolia = exports.rss3 = exports.rootstock = exports.ronin = exports.rolluxTestnet = exports.rollux = exports.reyaNetwork = exports.qTestnet = exports.qMainnet = exports.pulsechainV4 = exports.pulsechain = exports.polygonZkEvmTestnet = exports.polygonZkEvmCardona = exports.polygonZkEvm = exports.polygonMumbai = exports.polygonAmoy = exports.polygon = exports.plumeTestnet = exports.plinga = exports.phoenix = exports.pgnTestnet = exports.pgn = exports.playfiAlbireo = exports.palmTestnet = exports.palm = exports.oortMainnetDev = exports.opBNBTestnet = exports.opBNB = exports.optimismSepolia = exports.optimismGoerli = exports.optimism = exports.okc = exports.oasisTestnet = exports.oasys = exports.nexilix = undefined;
  exports.zoraTestnet = exports.zoraSepolia = exports.zora = exports.zkSyncTestnet = exports.zkSyncSepoliaTestnet = exports.zkSyncLocalNode = exports.zkSyncInMemoryNode = exports.zkSync = exports.zkFairTestnet = exports.zkFair = exports.zilliqaTestnet = exports.zilliqa = exports.zhejiang = exports.zetachainAthensTestnet = exports.zetachain = exports.xdcTestnet = exports.xdc = exports.x1Testnet = exports.wemixTestnet = exports.wemix = exports.wanchainTestnet = exports.wanchain = exports.vechain = exports.thunderTestnet = exports.tenet = exports.telosTestnet = exports.telos = exports.taraxaTestnet = exports.taikoTestnetSepolia = exports.taikoKatla = exports.taikoJolnir = exports.taikoHekla = exports.taraxa = exports.syscoinTestnet = exports.syscoin = exports.stratis = exports.shibarium = exports.shardeumSphinx = exports.spicy = exports.songbirdTestnet = exports.songbird = exports.skaleTitanTestnet = exports.skaleTitan = exports.skaleRazor = exports.skaleNebulaTestnet = exports.skaleNebula = exports.skaleHumanProtocol = exports.skaleExorde = exports.skaleEuropaTestnet = exports.skaleEuropa = undefined;
  var acala_js_1 = require_acala();
  Object.defineProperty(exports, "acala", { enumerable: true, get: function() {
    return acala_js_1.acala;
  } });
  var ancient8_js_1 = require_ancient8();
  Object.defineProperty(exports, "ancient8", { enumerable: true, get: function() {
    return ancient8_js_1.ancient8;
  } });
  var ancient8Sepolia_js_1 = require_ancient8Sepolia();
  Object.defineProperty(exports, "ancient8Sepolia", { enumerable: true, get: function() {
    return ancient8Sepolia_js_1.ancient8Sepolia;
  } });
  var anvil_js_1 = require_anvil();
  Object.defineProperty(exports, "anvil", { enumerable: true, get: function() {
    return anvil_js_1.anvil;
  } });
  var apexTestnet_js_1 = require_apexTestnet();
  Object.defineProperty(exports, "apexTestnet", { enumerable: true, get: function() {
    return apexTestnet_js_1.apexTestnet;
  } });
  var arbitrum_js_1 = require_arbitrum();
  Object.defineProperty(exports, "arbitrum", { enumerable: true, get: function() {
    return arbitrum_js_1.arbitrum;
  } });
  var arbitrumGoerli_js_1 = require_arbitrumGoerli();
  Object.defineProperty(exports, "arbitrumGoerli", { enumerable: true, get: function() {
    return arbitrumGoerli_js_1.arbitrumGoerli;
  } });
  var arbitrumNova_js_1 = require_arbitrumNova();
  Object.defineProperty(exports, "arbitrumNova", { enumerable: true, get: function() {
    return arbitrumNova_js_1.arbitrumNova;
  } });
  var astar_js_1 = require_astar();
  Object.defineProperty(exports, "astar", { enumerable: true, get: function() {
    return astar_js_1.astar;
  } });
  var astarZkEVM_js_1 = require_astarZkEVM();
  Object.defineProperty(exports, "astarZkEVM", { enumerable: true, get: function() {
    return astarZkEVM_js_1.astarZkEVM;
  } });
  var astarZkyoto_js_1 = require_astarZkyoto();
  Object.defineProperty(exports, "astarZkyoto", { enumerable: true, get: function() {
    return astarZkyoto_js_1.astarZkyoto;
  } });
  var arbitrumSepolia_js_1 = require_arbitrumSepolia();
  Object.defineProperty(exports, "arbitrumSepolia", { enumerable: true, get: function() {
    return arbitrumSepolia_js_1.arbitrumSepolia;
  } });
  var areonNetwork_js_1 = require_areonNetwork();
  Object.defineProperty(exports, "areonNetwork", { enumerable: true, get: function() {
    return areonNetwork_js_1.areonNetwork;
  } });
  var areonNetworkTestnet_js_1 = require_areonNetworkTestnet();
  Object.defineProperty(exports, "areonNetworkTestnet", { enumerable: true, get: function() {
    return areonNetworkTestnet_js_1.areonNetworkTestnet;
  } });
  var aurora_js_1 = require_aurora();
  Object.defineProperty(exports, "aurora", { enumerable: true, get: function() {
    return aurora_js_1.aurora;
  } });
  var auroraTestnet_js_1 = require_auroraTestnet();
  Object.defineProperty(exports, "auroraTestnet", { enumerable: true, get: function() {
    return auroraTestnet_js_1.auroraTestnet;
  } });
  var auroria_js_1 = require_auroria();
  Object.defineProperty(exports, "auroria", { enumerable: true, get: function() {
    return auroria_js_1.auroria;
  } });
  var avalanche_js_1 = require_avalanche();
  Object.defineProperty(exports, "avalanche", { enumerable: true, get: function() {
    return avalanche_js_1.avalanche;
  } });
  var avalancheFuji_js_1 = require_avalancheFuji();
  Object.defineProperty(exports, "avalancheFuji", { enumerable: true, get: function() {
    return avalancheFuji_js_1.avalancheFuji;
  } });
  var bahamut_js_1 = require_bahamut();
  Object.defineProperty(exports, "bahamut", { enumerable: true, get: function() {
    return bahamut_js_1.bahamut;
  } });
  var base_js_1 = require_base2();
  Object.defineProperty(exports, "base", { enumerable: true, get: function() {
    return base_js_1.base;
  } });
  var baseGoerli_js_1 = require_baseGoerli();
  Object.defineProperty(exports, "baseGoerli", { enumerable: true, get: function() {
    return baseGoerli_js_1.baseGoerli;
  } });
  var baseSepolia_js_1 = require_baseSepolia();
  Object.defineProperty(exports, "baseSepolia", { enumerable: true, get: function() {
    return baseSepolia_js_1.baseSepolia;
  } });
  var beam_js_1 = require_beam();
  Object.defineProperty(exports, "beam", { enumerable: true, get: function() {
    return beam_js_1.beam;
  } });
  var beamTestnet_js_1 = require_beamTestnet();
  Object.defineProperty(exports, "beamTestnet", { enumerable: true, get: function() {
    return beamTestnet_js_1.beamTestnet;
  } });
  var bearNetworkChainMainnet_js_1 = require_bearNetworkChainMainnet();
  Object.defineProperty(exports, "bearNetworkChainMainnet", { enumerable: true, get: function() {
    return bearNetworkChainMainnet_js_1.bearNetworkChainMainnet;
  } });
  var bearNetworkChainTestnet_js_1 = require_bearNetworkChainTestnet();
  Object.defineProperty(exports, "bearNetworkChainTestnet", { enumerable: true, get: function() {
    return bearNetworkChainTestnet_js_1.bearNetworkChainTestnet;
  } });
  var berachainTestnet_js_1 = require_berachainTestnet();
  Object.defineProperty(exports, "berachainTestnet", { enumerable: true, get: function() {
    return berachainTestnet_js_1.berachainTestnet;
  } });
  var bevmMainnet_js_1 = require_bevmMainnet();
  Object.defineProperty(exports, "bevmMainnet", { enumerable: true, get: function() {
    return bevmMainnet_js_1.bevmMainnet;
  } });
  var bitTorrent_js_1 = require_bitTorrent();
  Object.defineProperty(exports, "bitTorrent", { enumerable: true, get: function() {
    return bitTorrent_js_1.bitTorrent;
  } });
  var bitTorrentTestnet_js_1 = require_bitTorrentTestnet();
  Object.defineProperty(exports, "bitTorrentTestnet", { enumerable: true, get: function() {
    return bitTorrentTestnet_js_1.bitTorrentTestnet;
  } });
  var blast_js_1 = require_blast();
  Object.defineProperty(exports, "blast", { enumerable: true, get: function() {
    return blast_js_1.blast;
  } });
  var blastSepolia_js_1 = require_blastSepolia();
  Object.defineProperty(exports, "blastSepolia", { enumerable: true, get: function() {
    return blastSepolia_js_1.blastSepolia;
  } });
  var boba_js_1 = require_boba();
  Object.defineProperty(exports, "boba", { enumerable: true, get: function() {
    return boba_js_1.boba;
  } });
  var bronos_js_1 = require_bronos();
  Object.defineProperty(exports, "bronos", { enumerable: true, get: function() {
    return bronos_js_1.bronos;
  } });
  var bronosTestnet_js_1 = require_bronosTestnet();
  Object.defineProperty(exports, "bronosTestnet", { enumerable: true, get: function() {
    return bronosTestnet_js_1.bronosTestnet;
  } });
  var bsc_js_1 = require_bsc();
  Object.defineProperty(exports, "bsc", { enumerable: true, get: function() {
    return bsc_js_1.bsc;
  } });
  var bscTestnet_js_1 = require_bscTestnet();
  Object.defineProperty(exports, "bscTestnet", { enumerable: true, get: function() {
    return bscTestnet_js_1.bscTestnet;
  } });
  var bscGreenfield_js_1 = require_bscGreenfield();
  Object.defineProperty(exports, "bscGreenfield", { enumerable: true, get: function() {
    return bscGreenfield_js_1.bscGreenfield;
  } });
  var bxn_js_1 = require_bxn();
  Object.defineProperty(exports, "bxn", { enumerable: true, get: function() {
    return bxn_js_1.bxn;
  } });
  var bxnTestnet_js_1 = require_bxnTestnet();
  Object.defineProperty(exports, "bxnTestnet", { enumerable: true, get: function() {
    return bxnTestnet_js_1.bxnTestnet;
  } });
  var canto_js_1 = require_canto();
  Object.defineProperty(exports, "canto", { enumerable: true, get: function() {
    return canto_js_1.canto;
  } });
  var celo_js_1 = require_celo();
  Object.defineProperty(exports, "celo", { enumerable: true, get: function() {
    return celo_js_1.celo;
  } });
  var celoAlfajores_js_1 = require_celoAlfajores();
  Object.defineProperty(exports, "celoAlfajores", { enumerable: true, get: function() {
    return celoAlfajores_js_1.celoAlfajores;
  } });
  var chiliz_js_1 = require_chiliz();
  Object.defineProperty(exports, "chiliz", { enumerable: true, get: function() {
    return chiliz_js_1.chiliz;
  } });
  var classic_js_1 = require_classic();
  Object.defineProperty(exports, "classic", { enumerable: true, get: function() {
    return classic_js_1.classic;
  } });
  var confluxESpace_js_1 = require_confluxESpace();
  Object.defineProperty(exports, "confluxESpace", { enumerable: true, get: function() {
    return confluxESpace_js_1.confluxESpace;
  } });
  var confluxESpaceTestnet_js_1 = require_confluxESpaceTestnet();
  Object.defineProperty(exports, "confluxESpaceTestnet", { enumerable: true, get: function() {
    return confluxESpaceTestnet_js_1.confluxESpaceTestnet;
  } });
  var coreDao_js_1 = require_coreDao();
  Object.defineProperty(exports, "coreDao", { enumerable: true, get: function() {
    return coreDao_js_1.coreDao;
  } });
  var cronos_js_1 = require_cronos();
  Object.defineProperty(exports, "cronos", { enumerable: true, get: function() {
    return cronos_js_1.cronos;
  } });
  var cronosTestnet_js_1 = require_cronosTestnet();
  Object.defineProperty(exports, "cronosTestnet", { enumerable: true, get: function() {
    return cronosTestnet_js_1.cronosTestnet;
  } });
  var crossbell_js_1 = require_crossbell();
  Object.defineProperty(exports, "crossbell", { enumerable: true, get: function() {
    return crossbell_js_1.crossbell;
  } });
  var darwinia_js_1 = require_darwinia();
  Object.defineProperty(exports, "darwinia", { enumerable: true, get: function() {
    return darwinia_js_1.darwinia;
  } });
  var defichainEvm_js_1 = require_defichainEvm();
  Object.defineProperty(exports, "defichainEvm", { enumerable: true, get: function() {
    return defichainEvm_js_1.defichainEvm;
  } });
  var defichainEvmTestnet_js_1 = require_defichainEvmTestnet();
  Object.defineProperty(exports, "defichainEvmTestnet", { enumerable: true, get: function() {
    return defichainEvmTestnet_js_1.defichainEvmTestnet;
  } });
  var degen_js_1 = require_degen();
  Object.defineProperty(exports, "degen", { enumerable: true, get: function() {
    return degen_js_1.degen;
  } });
  var dfk_js_1 = require_dfk();
  Object.defineProperty(exports, "dfk", { enumerable: true, get: function() {
    return dfk_js_1.dfk;
  } });
  var dogechain_js_1 = require_dogechain();
  Object.defineProperty(exports, "dogechain", { enumerable: true, get: function() {
    return dogechain_js_1.dogechain;
  } });
  var edgeless_js_1 = require_edgeless();
  Object.defineProperty(exports, "edgeless", { enumerable: true, get: function() {
    return edgeless_js_1.edgeless;
  } });
  var edgelessTestnet_js_1 = require_edgelessTestnet();
  Object.defineProperty(exports, "edgelessTestnet", { enumerable: true, get: function() {
    return edgelessTestnet_js_1.edgelessTestnet;
  } });
  var edgeware_js_1 = require_edgeware();
  Object.defineProperty(exports, "edgeware", { enumerable: true, get: function() {
    return edgeware_js_1.edgeware;
  } });
  var edgewareTestnet_js_1 = require_edgewareTestnet();
  Object.defineProperty(exports, "edgewareTestnet", { enumerable: true, get: function() {
    return edgewareTestnet_js_1.edgewareTestnet;
  } });
  var eon_js_1 = require_eon();
  Object.defineProperty(exports, "eon", { enumerable: true, get: function() {
    return eon_js_1.eon;
  } });
  var eos_js_1 = require_eos();
  Object.defineProperty(exports, "eos", { enumerable: true, get: function() {
    return eos_js_1.eos;
  } });
  var eosTestnet_js_1 = require_eosTestnet();
  Object.defineProperty(exports, "eosTestnet", { enumerable: true, get: function() {
    return eosTestnet_js_1.eosTestnet;
  } });
  var etherlinkTestnet_js_1 = require_etherlinkTestnet();
  Object.defineProperty(exports, "etherlinkTestnet", { enumerable: true, get: function() {
    return etherlinkTestnet_js_1.etherlinkTestnet;
  } });
  var evmos_js_1 = require_evmos();
  Object.defineProperty(exports, "evmos", { enumerable: true, get: function() {
    return evmos_js_1.evmos;
  } });
  var evmosTestnet_js_1 = require_evmosTestnet();
  Object.defineProperty(exports, "evmosTestnet", { enumerable: true, get: function() {
    return evmosTestnet_js_1.evmosTestnet;
  } });
  var ekta_js_1 = require_ekta();
  Object.defineProperty(exports, "ekta", { enumerable: true, get: function() {
    return ekta_js_1.ekta;
  } });
  var ektaTestnet_js_1 = require_ektaTestnet();
  Object.defineProperty(exports, "ektaTestnet", { enumerable: true, get: function() {
    return ektaTestnet_js_1.ektaTestnet;
  } });
  var fantom_js_1 = require_fantom();
  Object.defineProperty(exports, "fantom", { enumerable: true, get: function() {
    return fantom_js_1.fantom;
  } });
  var fantomSonicTestnet_js_1 = require_fantomSonicTestnet();
  Object.defineProperty(exports, "fantomSonicTestnet", { enumerable: true, get: function() {
    return fantomSonicTestnet_js_1.fantomSonicTestnet;
  } });
  var fantomTestnet_js_1 = require_fantomTestnet();
  Object.defineProperty(exports, "fantomTestnet", { enumerable: true, get: function() {
    return fantomTestnet_js_1.fantomTestnet;
  } });
  var fibo_js_1 = require_fibo();
  Object.defineProperty(exports, "fibo", { enumerable: true, get: function() {
    return fibo_js_1.fibo;
  } });
  var filecoin_js_1 = require_filecoin();
  Object.defineProperty(exports, "filecoin", { enumerable: true, get: function() {
    return filecoin_js_1.filecoin;
  } });
  var filecoinCalibration_js_1 = require_filecoinCalibration();
  Object.defineProperty(exports, "filecoinCalibration", { enumerable: true, get: function() {
    return filecoinCalibration_js_1.filecoinCalibration;
  } });
  var filecoinHyperspace_js_1 = require_filecoinHyperspace();
  Object.defineProperty(exports, "filecoinHyperspace", { enumerable: true, get: function() {
    return filecoinHyperspace_js_1.filecoinHyperspace;
  } });
  var flare_js_1 = require_flare();
  Object.defineProperty(exports, "flare", { enumerable: true, get: function() {
    return flare_js_1.flare;
  } });
  var flareTestnet_js_1 = require_flareTestnet();
  Object.defineProperty(exports, "flareTestnet", { enumerable: true, get: function() {
    return flareTestnet_js_1.flareTestnet;
  } });
  var flowPreviewnet_js_1 = require_flowPreviewnet();
  Object.defineProperty(exports, "flowPreviewnet", { enumerable: true, get: function() {
    return flowPreviewnet_js_1.flowPreviewnet;
  } });
  var flowMainnet_js_1 = require_flowMainnet();
  Object.defineProperty(exports, "flowMainnet", { enumerable: true, get: function() {
    return flowMainnet_js_1.flowMainnet;
  } });
  var foundry_js_1 = require_foundry();
  Object.defineProperty(exports, "foundry", { enumerable: true, get: function() {
    return foundry_js_1.foundry;
  } });
  var fraxtal_js_1 = require_fraxtal();
  Object.defineProperty(exports, "fraxtal", { enumerable: true, get: function() {
    return fraxtal_js_1.fraxtal;
  } });
  var fraxtalTestnet_js_1 = require_fraxtalTestnet();
  Object.defineProperty(exports, "fraxtalTestnet", { enumerable: true, get: function() {
    return fraxtalTestnet_js_1.fraxtalTestnet;
  } });
  var fuse_js_1 = require_fuse();
  Object.defineProperty(exports, "fuse", { enumerable: true, get: function() {
    return fuse_js_1.fuse;
  } });
  var fuseSparknet_js_1 = require_fuseSparknet();
  Object.defineProperty(exports, "fuseSparknet", { enumerable: true, get: function() {
    return fuseSparknet_js_1.fuseSparknet;
  } });
  var iotex_js_1 = require_iotex();
  Object.defineProperty(exports, "iotex", { enumerable: true, get: function() {
    return iotex_js_1.iotex;
  } });
  var iotexTestnet_js_1 = require_iotexTestnet();
  Object.defineProperty(exports, "iotexTestnet", { enumerable: true, get: function() {
    return iotexTestnet_js_1.iotexTestnet;
  } });
  var jbc_js_1 = require_jbc();
  Object.defineProperty(exports, "jbc", { enumerable: true, get: function() {
    return jbc_js_1.jbc;
  } });
  var karura_js_1 = require_karura();
  Object.defineProperty(exports, "karura", { enumerable: true, get: function() {
    return karura_js_1.karura;
  } });
  var gobi_js_1 = require_gobi();
  Object.defineProperty(exports, "gobi", { enumerable: true, get: function() {
    return gobi_js_1.gobi;
  } });
  var goerli_js_1 = require_goerli();
  Object.defineProperty(exports, "goerli", { enumerable: true, get: function() {
    return goerli_js_1.goerli;
  } });
  var gnosis_js_1 = require_gnosis();
  Object.defineProperty(exports, "gnosis", { enumerable: true, get: function() {
    return gnosis_js_1.gnosis;
  } });
  var gnosisChiado_js_1 = require_gnosisChiado();
  Object.defineProperty(exports, "gnosisChiado", { enumerable: true, get: function() {
    return gnosisChiado_js_1.gnosisChiado;
  } });
  var hardhat_js_1 = require_hardhat();
  Object.defineProperty(exports, "hardhat", { enumerable: true, get: function() {
    return hardhat_js_1.hardhat;
  } });
  var harmonyOne_js_1 = require_harmonyOne();
  Object.defineProperty(exports, "harmonyOne", { enumerable: true, get: function() {
    return harmonyOne_js_1.harmonyOne;
  } });
  var haqqMainnet_js_1 = require_haqqMainnet();
  Object.defineProperty(exports, "haqqMainnet", { enumerable: true, get: function() {
    return haqqMainnet_js_1.haqqMainnet;
  } });
  var haqqTestedge2_js_1 = require_haqqTestedge2();
  Object.defineProperty(exports, "haqqTestedge2", { enumerable: true, get: function() {
    return haqqTestedge2_js_1.haqqTestedge2;
  } });
  var hedera_js_1 = require_hedera();
  Object.defineProperty(exports, "hedera", { enumerable: true, get: function() {
    return hedera_js_1.hedera;
  } });
  var hederaTestnet_js_1 = require_hederaTestnet();
  Object.defineProperty(exports, "hederaTestnet", { enumerable: true, get: function() {
    return hederaTestnet_js_1.hederaTestnet;
  } });
  var hederaPreviewnet_js_1 = require_hederaPreviewnet();
  Object.defineProperty(exports, "hederaPreviewnet", { enumerable: true, get: function() {
    return hederaPreviewnet_js_1.hederaPreviewnet;
  } });
  var holesky_js_1 = require_holesky();
  Object.defineProperty(exports, "holesky", { enumerable: true, get: function() {
    return holesky_js_1.holesky;
  } });
  var immutableZkEvm_js_1 = require_immutableZkEvm();
  Object.defineProperty(exports, "immutableZkEvm", { enumerable: true, get: function() {
    return immutableZkEvm_js_1.immutableZkEvm;
  } });
  var immutableZkEvmTestnet_js_1 = require_immutableZkEvmTestnet();
  Object.defineProperty(exports, "immutableZkEvmTestnet", { enumerable: true, get: function() {
    return immutableZkEvmTestnet_js_1.immutableZkEvmTestnet;
  } });
  var kakarotSepolia_js_1 = require_kakarotSepolia();
  Object.defineProperty(exports, "kakarotSepolia", { enumerable: true, get: function() {
    return kakarotSepolia_js_1.kakarotSepolia;
  } });
  var kava_js_1 = require_kava();
  Object.defineProperty(exports, "kava", { enumerable: true, get: function() {
    return kava_js_1.kava;
  } });
  var kavaTestnet_js_1 = require_kavaTestnet();
  Object.defineProperty(exports, "kavaTestnet", { enumerable: true, get: function() {
    return kavaTestnet_js_1.kavaTestnet;
  } });
  var kcc_js_1 = require_kcc();
  Object.defineProperty(exports, "kcc", { enumerable: true, get: function() {
    return kcc_js_1.kcc;
  } });
  var klaytn_js_1 = require_klaytn();
  Object.defineProperty(exports, "klaytn", { enumerable: true, get: function() {
    return klaytn_js_1.klaytn;
  } });
  var klaytnBaobab_js_1 = require_klaytnBaobab();
  Object.defineProperty(exports, "klaytnBaobab", { enumerable: true, get: function() {
    return klaytnBaobab_js_1.klaytnBaobab;
  } });
  var kroma_js_1 = require_kroma();
  Object.defineProperty(exports, "kroma", { enumerable: true, get: function() {
    return kroma_js_1.kroma;
  } });
  var kromaSepolia_js_1 = require_kromaSepolia();
  Object.defineProperty(exports, "kromaSepolia", { enumerable: true, get: function() {
    return kromaSepolia_js_1.kromaSepolia;
  } });
  var lightlinkPegasus_js_1 = require_lightlinkPegasus();
  Object.defineProperty(exports, "lightlinkPegasus", { enumerable: true, get: function() {
    return lightlinkPegasus_js_1.lightlinkPegasus;
  } });
  var lightlinkPhoenix_js_1 = require_lightlinkPhoenix();
  Object.defineProperty(exports, "lightlinkPhoenix", { enumerable: true, get: function() {
    return lightlinkPhoenix_js_1.lightlinkPhoenix;
  } });
  var linea_js_1 = require_linea();
  Object.defineProperty(exports, "linea", { enumerable: true, get: function() {
    return linea_js_1.linea;
  } });
  var lineaGoerli_js_1 = require_lineaGoerli();
  Object.defineProperty(exports, "lineaGoerli", { enumerable: true, get: function() {
    return lineaGoerli_js_1.lineaGoerli;
  } });
  var lineaSepolia_js_1 = require_lineaSepolia();
  Object.defineProperty(exports, "lineaSepolia", { enumerable: true, get: function() {
    return lineaSepolia_js_1.lineaSepolia;
  } });
  var lineaTestnet_js_1 = require_lineaTestnet();
  Object.defineProperty(exports, "lineaTestnet", { enumerable: true, get: function() {
    return lineaTestnet_js_1.lineaTestnet;
  } });
  var liskSepolia_js_1 = require_liskSepolia();
  Object.defineProperty(exports, "liskSepolia", { enumerable: true, get: function() {
    return liskSepolia_js_1.liskSepolia;
  } });
  var localhost_js_1 = require_localhost();
  Object.defineProperty(exports, "localhost", { enumerable: true, get: function() {
    return localhost_js_1.localhost;
  } });
  var lukso_js_1 = require_lukso();
  Object.defineProperty(exports, "lukso", { enumerable: true, get: function() {
    return lukso_js_1.lukso;
  } });
  var luksoTestnet_js_1 = require_luksoTestnet();
  Object.defineProperty(exports, "luksoTestnet", { enumerable: true, get: function() {
    return luksoTestnet_js_1.luksoTestnet;
  } });
  var mainnet_js_1 = require_mainnet();
  Object.defineProperty(exports, "mainnet", { enumerable: true, get: function() {
    return mainnet_js_1.mainnet;
  } });
  var mandala_js_1 = require_mandala();
  Object.defineProperty(exports, "mandala", { enumerable: true, get: function() {
    return mandala_js_1.mandala;
  } });
  var manta_js_1 = require_manta();
  Object.defineProperty(exports, "manta", { enumerable: true, get: function() {
    return manta_js_1.manta;
  } });
  var mantaSepoliaTestnet_js_1 = require_mantaSepoliaTestnet();
  Object.defineProperty(exports, "mantaSepoliaTestnet", { enumerable: true, get: function() {
    return mantaSepoliaTestnet_js_1.mantaSepoliaTestnet;
  } });
  var mantaTestnet_js_1 = require_mantaTestnet();
  Object.defineProperty(exports, "mantaTestnet", { enumerable: true, get: function() {
    return mantaTestnet_js_1.mantaTestnet;
  } });
  var mantle_js_1 = require_mantle();
  Object.defineProperty(exports, "mantle", { enumerable: true, get: function() {
    return mantle_js_1.mantle;
  } });
  var mantleSepoliaTestnet_js_1 = require_mantleSepoliaTestnet();
  Object.defineProperty(exports, "mantleSepoliaTestnet", { enumerable: true, get: function() {
    return mantleSepoliaTestnet_js_1.mantleSepoliaTestnet;
  } });
  var mantleTestnet_js_1 = require_mantleTestnet();
  Object.defineProperty(exports, "mantleTestnet", { enumerable: true, get: function() {
    return mantleTestnet_js_1.mantleTestnet;
  } });
  var merlin_js_1 = require_merlin();
  Object.defineProperty(exports, "merlin", { enumerable: true, get: function() {
    return merlin_js_1.merlin;
  } });
  var metachain_js_1 = require_metachain();
  Object.defineProperty(exports, "metachain", { enumerable: true, get: function() {
    return metachain_js_1.metachain;
  } });
  var metachainIstanbul_js_1 = require_metachainIstanbul();
  Object.defineProperty(exports, "metachainIstanbul", { enumerable: true, get: function() {
    return metachainIstanbul_js_1.metachainIstanbul;
  } });
  var meter_js_1 = require_meter();
  Object.defineProperty(exports, "meter", { enumerable: true, get: function() {
    return meter_js_1.meter;
  } });
  var meterTestnet_js_1 = require_meterTestnet();
  Object.defineProperty(exports, "meterTestnet", { enumerable: true, get: function() {
    return meterTestnet_js_1.meterTestnet;
  } });
  var metis_js_1 = require_metis();
  Object.defineProperty(exports, "metis", { enumerable: true, get: function() {
    return metis_js_1.metis;
  } });
  var metisGoerli_js_1 = require_metisGoerli();
  Object.defineProperty(exports, "metisGoerli", { enumerable: true, get: function() {
    return metisGoerli_js_1.metisGoerli;
  } });
  var mev_js_1 = require_mev();
  Object.defineProperty(exports, "mev", { enumerable: true, get: function() {
    return mev_js_1.mev;
  } });
  var mevTestnet_js_1 = require_mevTestnet();
  Object.defineProperty(exports, "mevTestnet", { enumerable: true, get: function() {
    return mevTestnet_js_1.mevTestnet;
  } });
  var mintSepoliaTestnet_js_1 = require_mintSepoliaTestnet();
  Object.defineProperty(exports, "mintSepoliaTestnet", { enumerable: true, get: function() {
    return mintSepoliaTestnet_js_1.mintSepoliaTestnet;
  } });
  var mode_js_1 = require_mode();
  Object.defineProperty(exports, "mode", { enumerable: true, get: function() {
    return mode_js_1.mode;
  } });
  var modeTestnet_js_1 = require_modeTestnet();
  Object.defineProperty(exports, "modeTestnet", { enumerable: true, get: function() {
    return modeTestnet_js_1.modeTestnet;
  } });
  var moonbaseAlpha_js_1 = require_moonbaseAlpha();
  Object.defineProperty(exports, "moonbaseAlpha", { enumerable: true, get: function() {
    return moonbaseAlpha_js_1.moonbaseAlpha;
  } });
  var moonbeam_js_1 = require_moonbeam();
  Object.defineProperty(exports, "moonbeam", { enumerable: true, get: function() {
    return moonbeam_js_1.moonbeam;
  } });
  var moonbeamDev_js_1 = require_moonbeamDev();
  Object.defineProperty(exports, "moonbeamDev", { enumerable: true, get: function() {
    return moonbeamDev_js_1.moonbeamDev;
  } });
  var moonriver_js_1 = require_moonriver();
  Object.defineProperty(exports, "moonriver", { enumerable: true, get: function() {
    return moonriver_js_1.moonriver;
  } });
  var morphSepolia_js_1 = require_morphSepolia();
  Object.defineProperty(exports, "morphSepolia", { enumerable: true, get: function() {
    return morphSepolia_js_1.morphSepolia;
  } });
  var neonDevnet_js_1 = require_neonDevnet();
  Object.defineProperty(exports, "neonDevnet", { enumerable: true, get: function() {
    return neonDevnet_js_1.neonDevnet;
  } });
  var neonMainnet_js_1 = require_neonMainnet();
  Object.defineProperty(exports, "neonMainnet", { enumerable: true, get: function() {
    return neonMainnet_js_1.neonMainnet;
  } });
  var nexi_js_1 = require_nexi();
  Object.defineProperty(exports, "nexi", { enumerable: true, get: function() {
    return nexi_js_1.nexi;
  } });
  var nexilix_js_1 = require_nexilix();
  Object.defineProperty(exports, "nexilix", { enumerable: true, get: function() {
    return nexilix_js_1.nexilix;
  } });
  var oasys_js_1 = require_oasys();
  Object.defineProperty(exports, "oasys", { enumerable: true, get: function() {
    return oasys_js_1.oasys;
  } });
  var oasisTestnet_js_1 = require_oasisTestnet();
  Object.defineProperty(exports, "oasisTestnet", { enumerable: true, get: function() {
    return oasisTestnet_js_1.oasisTestnet;
  } });
  var okc_js_1 = require_okc();
  Object.defineProperty(exports, "okc", { enumerable: true, get: function() {
    return okc_js_1.okc;
  } });
  var optimism_js_1 = require_optimism();
  Object.defineProperty(exports, "optimism", { enumerable: true, get: function() {
    return optimism_js_1.optimism;
  } });
  var optimismGoerli_js_1 = require_optimismGoerli();
  Object.defineProperty(exports, "optimismGoerli", { enumerable: true, get: function() {
    return optimismGoerli_js_1.optimismGoerli;
  } });
  var optimismSepolia_js_1 = require_optimismSepolia();
  Object.defineProperty(exports, "optimismSepolia", { enumerable: true, get: function() {
    return optimismSepolia_js_1.optimismSepolia;
  } });
  var opBNB_js_1 = require_opBNB();
  Object.defineProperty(exports, "opBNB", { enumerable: true, get: function() {
    return opBNB_js_1.opBNB;
  } });
  var opBNBTestnet_js_1 = require_opBNBTestnet();
  Object.defineProperty(exports, "opBNBTestnet", { enumerable: true, get: function() {
    return opBNBTestnet_js_1.opBNBTestnet;
  } });
  var oortmainnetDev_js_1 = require_oortmainnetDev();
  Object.defineProperty(exports, "oortMainnetDev", { enumerable: true, get: function() {
    return oortmainnetDev_js_1.oortMainnetDev;
  } });
  var palm_js_1 = require_palm();
  Object.defineProperty(exports, "palm", { enumerable: true, get: function() {
    return palm_js_1.palm;
  } });
  var palmTestnet_js_1 = require_palmTestnet();
  Object.defineProperty(exports, "palmTestnet", { enumerable: true, get: function() {
    return palmTestnet_js_1.palmTestnet;
  } });
  var playfiAlbireo_js_1 = require_playfiAlbireo();
  Object.defineProperty(exports, "playfiAlbireo", { enumerable: true, get: function() {
    return playfiAlbireo_js_1.playfiAlbireo;
  } });
  var pgn_js_1 = require_pgn();
  Object.defineProperty(exports, "pgn", { enumerable: true, get: function() {
    return pgn_js_1.pgn;
  } });
  var pgnTestnet_js_1 = require_pgnTestnet();
  Object.defineProperty(exports, "pgnTestnet", { enumerable: true, get: function() {
    return pgnTestnet_js_1.pgnTestnet;
  } });
  var phoenix_js_1 = require_phoenix();
  Object.defineProperty(exports, "phoenix", { enumerable: true, get: function() {
    return phoenix_js_1.phoenix;
  } });
  var plinga_js_1 = require_plinga();
  Object.defineProperty(exports, "plinga", { enumerable: true, get: function() {
    return plinga_js_1.plinga;
  } });
  var plumeTestnet_js_1 = require_plumeTestnet();
  Object.defineProperty(exports, "plumeTestnet", { enumerable: true, get: function() {
    return plumeTestnet_js_1.plumeTestnet;
  } });
  var polygon_js_1 = require_polygon();
  Object.defineProperty(exports, "polygon", { enumerable: true, get: function() {
    return polygon_js_1.polygon;
  } });
  var polygonAmoy_js_1 = require_polygonAmoy();
  Object.defineProperty(exports, "polygonAmoy", { enumerable: true, get: function() {
    return polygonAmoy_js_1.polygonAmoy;
  } });
  var polygonMumbai_js_1 = require_polygonMumbai();
  Object.defineProperty(exports, "polygonMumbai", { enumerable: true, get: function() {
    return polygonMumbai_js_1.polygonMumbai;
  } });
  var polygonZkEvm_js_1 = require_polygonZkEvm();
  Object.defineProperty(exports, "polygonZkEvm", { enumerable: true, get: function() {
    return polygonZkEvm_js_1.polygonZkEvm;
  } });
  var polygonZkEvmCardona_js_1 = require_polygonZkEvmCardona();
  Object.defineProperty(exports, "polygonZkEvmCardona", { enumerable: true, get: function() {
    return polygonZkEvmCardona_js_1.polygonZkEvmCardona;
  } });
  var polygonZkEvmTestnet_js_1 = require_polygonZkEvmTestnet();
  Object.defineProperty(exports, "polygonZkEvmTestnet", { enumerable: true, get: function() {
    return polygonZkEvmTestnet_js_1.polygonZkEvmTestnet;
  } });
  var pulsechain_js_1 = require_pulsechain();
  Object.defineProperty(exports, "pulsechain", { enumerable: true, get: function() {
    return pulsechain_js_1.pulsechain;
  } });
  var pulsechainV4_js_1 = require_pulsechainV4();
  Object.defineProperty(exports, "pulsechainV4", { enumerable: true, get: function() {
    return pulsechainV4_js_1.pulsechainV4;
  } });
  var qMainnet_js_1 = require_qMainnet();
  Object.defineProperty(exports, "qMainnet", { enumerable: true, get: function() {
    return qMainnet_js_1.qMainnet;
  } });
  var qTestnet_js_1 = require_qTestnet();
  Object.defineProperty(exports, "qTestnet", { enumerable: true, get: function() {
    return qTestnet_js_1.qTestnet;
  } });
  var reyaNetwork_js_1 = require_reyaNetwork();
  Object.defineProperty(exports, "reyaNetwork", { enumerable: true, get: function() {
    return reyaNetwork_js_1.reyaNetwork;
  } });
  var rollux_js_1 = require_rollux();
  Object.defineProperty(exports, "rollux", { enumerable: true, get: function() {
    return rollux_js_1.rollux;
  } });
  var rolluxTestnet_js_1 = require_rolluxTestnet();
  Object.defineProperty(exports, "rolluxTestnet", { enumerable: true, get: function() {
    return rolluxTestnet_js_1.rolluxTestnet;
  } });
  var ronin_js_1 = require_ronin();
  Object.defineProperty(exports, "ronin", { enumerable: true, get: function() {
    return ronin_js_1.ronin;
  } });
  var rootstock_js_1 = require_rootstock();
  Object.defineProperty(exports, "rootstock", { enumerable: true, get: function() {
    return rootstock_js_1.rootstock;
  } });
  var rss3_js_1 = require_rss3();
  Object.defineProperty(exports, "rss3", { enumerable: true, get: function() {
    return rss3_js_1.rss3;
  } });
  var rss3Sepolia_js_1 = require_rss3Sepolia();
  Object.defineProperty(exports, "rss3Sepolia", { enumerable: true, get: function() {
    return rss3Sepolia_js_1.rss3Sepolia;
  } });
  var saigon_js_1 = require_saigon();
  Object.defineProperty(exports, "saigon", { enumerable: true, get: function() {
    return saigon_js_1.saigon;
  } });
  var sapphire_js_1 = require_sapphire();
  Object.defineProperty(exports, "sapphire", { enumerable: true, get: function() {
    return sapphire_js_1.sapphire;
  } });
  var sapphireTestnet_js_1 = require_sapphireTestnet();
  Object.defineProperty(exports, "sapphireTestnet", { enumerable: true, get: function() {
    return sapphireTestnet_js_1.sapphireTestnet;
  } });
  var scroll_js_1 = require_scroll();
  Object.defineProperty(exports, "scroll", { enumerable: true, get: function() {
    return scroll_js_1.scroll;
  } });
  var scrollSepolia_js_1 = require_scrollSepolia();
  Object.defineProperty(exports, "scrollSepolia", { enumerable: true, get: function() {
    return scrollSepolia_js_1.scrollSepolia;
  } });
  var scrollTestnet_js_1 = require_scrollTestnet();
  Object.defineProperty(exports, "scrollTestnet", { enumerable: true, get: function() {
    return scrollTestnet_js_1.scrollTestnet;
  } });
  var seiDevnet_js_1 = require_seiDevnet();
  Object.defineProperty(exports, "seiDevnet", { enumerable: true, get: function() {
    return seiDevnet_js_1.seiDevnet;
  } });
  var sepolia_js_1 = require_sepolia();
  Object.defineProperty(exports, "sepolia", { enumerable: true, get: function() {
    return sepolia_js_1.sepolia;
  } });
  var shimmer_js_1 = require_shimmer();
  Object.defineProperty(exports, "shimmer", { enumerable: true, get: function() {
    return shimmer_js_1.shimmer;
  } });
  var shimmerTestnet_js_1 = require_shimmerTestnet();
  Object.defineProperty(exports, "shimmerTestnet", { enumerable: true, get: function() {
    return shimmerTestnet_js_1.shimmerTestnet;
  } });
  var brawl_js_1 = require_brawl();
  Object.defineProperty(exports, "skaleBlockBrawlers", { enumerable: true, get: function() {
    return brawl_js_1.skaleBlockBrawlers;
  } });
  var calypso_js_1 = require_calypso();
  Object.defineProperty(exports, "skaleCalypso", { enumerable: true, get: function() {
    return calypso_js_1.skaleCalypso;
  } });
  var calypsoTestnet_js_1 = require_calypsoTestnet();
  Object.defineProperty(exports, "skaleCalypsoTestnet", { enumerable: true, get: function() {
    return calypsoTestnet_js_1.skaleCalypsoTestnet;
  } });
  var cryptoBlades_js_1 = require_cryptoBlades();
  Object.defineProperty(exports, "skaleCryptoBlades", { enumerable: true, get: function() {
    return cryptoBlades_js_1.skaleCryptoBlades;
  } });
  var cryptoColosseum_js_1 = require_cryptoColosseum();
  Object.defineProperty(exports, "skaleCryptoColosseum", { enumerable: true, get: function() {
    return cryptoColosseum_js_1.skaleCryptoColosseum;
  } });
  var europa_js_1 = require_europa();
  Object.defineProperty(exports, "skaleEuropa", { enumerable: true, get: function() {
    return europa_js_1.skaleEuropa;
  } });
  var europaTestnet_js_1 = require_europaTestnet();
  Object.defineProperty(exports, "skaleEuropaTestnet", { enumerable: true, get: function() {
    return europaTestnet_js_1.skaleEuropaTestnet;
  } });
  var exorde_js_1 = require_exorde();
  Object.defineProperty(exports, "skaleExorde", { enumerable: true, get: function() {
    return exorde_js_1.skaleExorde;
  } });
  var humanProtocol_js_1 = require_humanProtocol();
  Object.defineProperty(exports, "skaleHumanProtocol", { enumerable: true, get: function() {
    return humanProtocol_js_1.skaleHumanProtocol;
  } });
  var nebula_js_1 = require_nebula();
  Object.defineProperty(exports, "skaleNebula", { enumerable: true, get: function() {
    return nebula_js_1.skaleNebula;
  } });
  var nebulaTestnet_js_1 = require_nebulaTestnet();
  Object.defineProperty(exports, "skaleNebulaTestnet", { enumerable: true, get: function() {
    return nebulaTestnet_js_1.skaleNebulaTestnet;
  } });
  var razor_js_1 = require_razor();
  Object.defineProperty(exports, "skaleRazor", { enumerable: true, get: function() {
    return razor_js_1.skaleRazor;
  } });
  var titan_js_1 = require_titan();
  Object.defineProperty(exports, "skaleTitan", { enumerable: true, get: function() {
    return titan_js_1.skaleTitan;
  } });
  var titanTestnet_js_1 = require_titanTestnet();
  Object.defineProperty(exports, "skaleTitanTestnet", { enumerable: true, get: function() {
    return titanTestnet_js_1.skaleTitanTestnet;
  } });
  var songbird_js_1 = require_songbird();
  Object.defineProperty(exports, "songbird", { enumerable: true, get: function() {
    return songbird_js_1.songbird;
  } });
  var songbirdTestnet_js_1 = require_songbirdTestnet();
  Object.defineProperty(exports, "songbirdTestnet", { enumerable: true, get: function() {
    return songbirdTestnet_js_1.songbirdTestnet;
  } });
  var spicy_js_1 = require_spicy();
  Object.defineProperty(exports, "spicy", { enumerable: true, get: function() {
    return spicy_js_1.spicy;
  } });
  var shardeumSphinx_js_1 = require_shardeumSphinx();
  Object.defineProperty(exports, "shardeumSphinx", { enumerable: true, get: function() {
    return shardeumSphinx_js_1.shardeumSphinx;
  } });
  var shibarium_js_1 = require_shibarium();
  Object.defineProperty(exports, "shibarium", { enumerable: true, get: function() {
    return shibarium_js_1.shibarium;
  } });
  var stratis_js_1 = require_stratis();
  Object.defineProperty(exports, "stratis", { enumerable: true, get: function() {
    return stratis_js_1.stratis;
  } });
  var syscoin_js_1 = require_syscoin();
  Object.defineProperty(exports, "syscoin", { enumerable: true, get: function() {
    return syscoin_js_1.syscoin;
  } });
  var syscoinTestnet_js_1 = require_syscoinTestnet();
  Object.defineProperty(exports, "syscoinTestnet", { enumerable: true, get: function() {
    return syscoinTestnet_js_1.syscoinTestnet;
  } });
  var taraxa_js_1 = require_taraxa();
  Object.defineProperty(exports, "taraxa", { enumerable: true, get: function() {
    return taraxa_js_1.taraxa;
  } });
  var taikoHekla_js_1 = require_taikoHekla();
  Object.defineProperty(exports, "taikoHekla", { enumerable: true, get: function() {
    return taikoHekla_js_1.taikoHekla;
  } });
  var taikoJolnir_js_1 = require_taikoJolnir();
  Object.defineProperty(exports, "taikoJolnir", { enumerable: true, get: function() {
    return taikoJolnir_js_1.taikoJolnir;
  } });
  var taikoKatla_js_1 = require_taikoKatla();
  Object.defineProperty(exports, "taikoKatla", { enumerable: true, get: function() {
    return taikoKatla_js_1.taikoKatla;
  } });
  var taikoTestnetSepolia_js_1 = require_taikoTestnetSepolia();
  Object.defineProperty(exports, "taikoTestnetSepolia", { enumerable: true, get: function() {
    return taikoTestnetSepolia_js_1.taikoTestnetSepolia;
  } });
  var taraxaTestnet_js_1 = require_taraxaTestnet();
  Object.defineProperty(exports, "taraxaTestnet", { enumerable: true, get: function() {
    return taraxaTestnet_js_1.taraxaTestnet;
  } });
  var telos_js_1 = require_telos();
  Object.defineProperty(exports, "telos", { enumerable: true, get: function() {
    return telos_js_1.telos;
  } });
  var telosTestnet_js_1 = require_telosTestnet();
  Object.defineProperty(exports, "telosTestnet", { enumerable: true, get: function() {
    return telosTestnet_js_1.telosTestnet;
  } });
  var tenet_js_1 = require_tenet();
  Object.defineProperty(exports, "tenet", { enumerable: true, get: function() {
    return tenet_js_1.tenet;
  } });
  var thunderTestnet_js_1 = require_thunderTestnet();
  Object.defineProperty(exports, "thunderTestnet", { enumerable: true, get: function() {
    return thunderTestnet_js_1.thunderTestnet;
  } });
  var vechain_js_1 = require_vechain();
  Object.defineProperty(exports, "vechain", { enumerable: true, get: function() {
    return vechain_js_1.vechain;
  } });
  var wanchain_js_1 = require_wanchain();
  Object.defineProperty(exports, "wanchain", { enumerable: true, get: function() {
    return wanchain_js_1.wanchain;
  } });
  var wanchainTestnet_js_1 = require_wanchainTestnet();
  Object.defineProperty(exports, "wanchainTestnet", { enumerable: true, get: function() {
    return wanchainTestnet_js_1.wanchainTestnet;
  } });
  var wemix_js_1 = require_wemix();
  Object.defineProperty(exports, "wemix", { enumerable: true, get: function() {
    return wemix_js_1.wemix;
  } });
  var wemixTestnet_js_1 = require_wemixTestnet();
  Object.defineProperty(exports, "wemixTestnet", { enumerable: true, get: function() {
    return wemixTestnet_js_1.wemixTestnet;
  } });
  var x1Testnet_js_1 = require_x1Testnet();
  Object.defineProperty(exports, "x1Testnet", { enumerable: true, get: function() {
    return x1Testnet_js_1.x1Testnet;
  } });
  var xdc_js_1 = require_xdc();
  Object.defineProperty(exports, "xdc", { enumerable: true, get: function() {
    return xdc_js_1.xdc;
  } });
  var xdcTestnet_js_1 = require_xdcTestnet();
  Object.defineProperty(exports, "xdcTestnet", { enumerable: true, get: function() {
    return xdcTestnet_js_1.xdcTestnet;
  } });
  var zetachain_js_1 = require_zetachain();
  Object.defineProperty(exports, "zetachain", { enumerable: true, get: function() {
    return zetachain_js_1.zetachain;
  } });
  var zetachainAthensTestnet_js_1 = require_zetachainAthensTestnet();
  Object.defineProperty(exports, "zetachainAthensTestnet", { enumerable: true, get: function() {
    return zetachainAthensTestnet_js_1.zetachainAthensTestnet;
  } });
  var zhejiang_js_1 = require_zhejiang();
  Object.defineProperty(exports, "zhejiang", { enumerable: true, get: function() {
    return zhejiang_js_1.zhejiang;
  } });
  var zilliqa_js_1 = require_zilliqa();
  Object.defineProperty(exports, "zilliqa", { enumerable: true, get: function() {
    return zilliqa_js_1.zilliqa;
  } });
  var zilliqaTestnet_js_1 = require_zilliqaTestnet();
  Object.defineProperty(exports, "zilliqaTestnet", { enumerable: true, get: function() {
    return zilliqaTestnet_js_1.zilliqaTestnet;
  } });
  var zkFair_js_1 = require_zkFair();
  Object.defineProperty(exports, "zkFair", { enumerable: true, get: function() {
    return zkFair_js_1.zkFair;
  } });
  var zkFairTestnet_js_1 = require_zkFairTestnet();
  Object.defineProperty(exports, "zkFairTestnet", { enumerable: true, get: function() {
    return zkFairTestnet_js_1.zkFairTestnet;
  } });
  var zkSync_js_1 = require_zkSync();
  Object.defineProperty(exports, "zkSync", { enumerable: true, get: function() {
    return zkSync_js_1.zkSync;
  } });
  var zkSyncInMemoryNode_js_1 = require_zkSyncInMemoryNode();
  Object.defineProperty(exports, "zkSyncInMemoryNode", { enumerable: true, get: function() {
    return zkSyncInMemoryNode_js_1.zkSyncInMemoryNode;
  } });
  var zkSyncLocalNode_js_1 = require_zkSyncLocalNode();
  Object.defineProperty(exports, "zkSyncLocalNode", { enumerable: true, get: function() {
    return zkSyncLocalNode_js_1.zkSyncLocalNode;
  } });
  var zkSyncSepoliaTestnet_js_1 = require_zkSyncSepoliaTestnet();
  Object.defineProperty(exports, "zkSyncSepoliaTestnet", { enumerable: true, get: function() {
    return zkSyncSepoliaTestnet_js_1.zkSyncSepoliaTestnet;
  } });
  var zkSyncTestnet_js_1 = require_zkSyncTestnet();
  Object.defineProperty(exports, "zkSyncTestnet", { enumerable: true, get: function() {
    return zkSyncTestnet_js_1.zkSyncTestnet;
  } });
  var zora_js_1 = require_zora();
  Object.defineProperty(exports, "zora", { enumerable: true, get: function() {
    return zora_js_1.zora;
  } });
  var zoraSepolia_js_1 = require_zoraSepolia();
  Object.defineProperty(exports, "zoraSepolia", { enumerable: true, get: function() {
    return zoraSepolia_js_1.zoraSepolia;
  } });
  var zoraTestnet_js_1 = require_zoraTestnet();
  Object.defineProperty(exports, "zoraTestnet", { enumerable: true, get: function() {
    return zoraTestnet_js_1.zoraTestnet;
  } });
});

// node_modules/@supercharge/promise-pool/dist/validation-error.js
var require_validation_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidationError = undefined;

  class ValidationError extends Error {
    constructor(message) {
      super(message);
      if (Error.captureStackTrace && typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    static createFrom(message) {
      return new this(message);
    }
  }
  exports.ValidationError = ValidationError;
});

// node_modules/@supercharge/promise-pool/dist/promise-pool-error.js
var require_promise_pool_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PromisePoolError = undefined;

  class PromisePoolError extends Error {
    constructor(error, item) {
      super();
      this.raw = error;
      this.item = item;
      this.name = this.constructor.name;
      this.message = this.messageFrom(error);
      if (Error.captureStackTrace && typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    static createFrom(error, item) {
      return new this(error, item);
    }
    messageFrom(error) {
      if (error instanceof Error) {
        return error.message;
      }
      if (typeof error === "object") {
        return error.message;
      }
      if (typeof error === "string" || typeof error === "number") {
        return error.toString();
      }
      return "";
    }
  }
  exports.PromisePoolError = PromisePoolError;
});

// node_modules/@supercharge/promise-pool/dist/stop-the-promise-pool-error.js
var require_stop_the_promise_pool_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StopThePromisePoolError = undefined;

  class StopThePromisePoolError extends Error {
  }
  exports.StopThePromisePoolError = StopThePromisePoolError;
});

// node_modules/@supercharge/promise-pool/dist/promise-pool-executor.js
var require_promise_pool_executor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PromisePoolExecutor = undefined;
  var promise_pool_1 = require_promise_pool();
  var validation_error_1 = require_validation_error();
  var promise_pool_error_1 = require_promise_pool_error();
  var stop_the_promise_pool_error_1 = require_stop_the_promise_pool_error();

  class PromisePoolExecutor {
    constructor() {
      this.meta = {
        tasks: [],
        items: [],
        errors: [],
        results: [],
        stopped: false,
        concurrency: 10,
        shouldResultsCorrespond: false,
        processedItems: [],
        taskTimeout: 0
      };
      this.handler = (item) => item;
      this.errorHandler = undefined;
      this.onTaskStartedHandlers = [];
      this.onTaskFinishedHandlers = [];
    }
    useConcurrency(concurrency) {
      if (!this.isValidConcurrency(concurrency)) {
        throw validation_error_1.ValidationError.createFrom(`"concurrency" must be a number, 1 or up. Received "${concurrency}" (${typeof concurrency})`);
      }
      this.meta.concurrency = concurrency;
      return this;
    }
    isValidConcurrency(concurrency) {
      return typeof concurrency === "number" && concurrency >= 1;
    }
    withTaskTimeout(timeout) {
      this.meta.taskTimeout = timeout;
      return this;
    }
    concurrency() {
      return this.meta.concurrency;
    }
    useCorrespondingResults(shouldResultsCorrespond) {
      this.meta.shouldResultsCorrespond = shouldResultsCorrespond;
      return this;
    }
    shouldUseCorrespondingResults() {
      return this.meta.shouldResultsCorrespond;
    }
    taskTimeout() {
      return this.meta.taskTimeout;
    }
    for(items) {
      this.meta.items = items;
      return this;
    }
    items() {
      return this.meta.items;
    }
    itemsCount() {
      const items = this.items();
      return Array.isArray(items) ? items.length : NaN;
    }
    tasks() {
      return this.meta.tasks;
    }
    activeTaskCount() {
      return this.activeTasksCount();
    }
    activeTasksCount() {
      return this.tasks().length;
    }
    processedItems() {
      return this.meta.processedItems;
    }
    processedCount() {
      return this.processedItems().length;
    }
    processedPercentage() {
      return this.processedCount() / this.itemsCount() * 100;
    }
    results() {
      return this.meta.results;
    }
    errors() {
      return this.meta.errors;
    }
    withHandler(action) {
      this.handler = action;
      return this;
    }
    hasErrorHandler() {
      return !!this.errorHandler;
    }
    handleError(handler) {
      this.errorHandler = handler;
      return this;
    }
    onTaskStarted(handlers) {
      this.onTaskStartedHandlers = handlers;
      return this;
    }
    onTaskFinished(handlers) {
      this.onTaskFinishedHandlers = handlers;
      return this;
    }
    hasReachedConcurrencyLimit() {
      return this.activeTasksCount() >= this.concurrency();
    }
    stop() {
      this.markAsStopped();
      throw new stop_the_promise_pool_error_1.StopThePromisePoolError;
    }
    markAsStopped() {
      this.meta.stopped = true;
      return this;
    }
    isStopped() {
      return this.meta.stopped;
    }
    async start() {
      return await this.validateInputs().prepareResultsArray().process();
    }
    validateInputs() {
      if (typeof this.handler !== "function") {
        throw validation_error_1.ValidationError.createFrom("The first parameter for the .process(fn) method must be a function");
      }
      const timeout = this.taskTimeout();
      if (!(timeout == null || typeof timeout === "number" && timeout >= 0)) {
        throw validation_error_1.ValidationError.createFrom(`"timeout" must be undefined or a number. A number must be 0 or up. Received "${String(timeout)}" (${typeof timeout})`);
      }
      if (!this.areItemsValid()) {
        throw validation_error_1.ValidationError.createFrom(`"items" must be an array, an iterable or an async iterable. Received "${typeof this.items()}"`);
      }
      if (this.errorHandler && typeof this.errorHandler !== "function") {
        throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received "${typeof this.errorHandler}"`);
      }
      this.onTaskStartedHandlers.forEach((handler) => {
        if (handler && typeof handler !== "function") {
          throw validation_error_1.ValidationError.createFrom(`The onTaskStarted handler must be a function. Received "${typeof handler}"`);
        }
      });
      this.onTaskFinishedHandlers.forEach((handler) => {
        if (handler && typeof handler !== "function") {
          throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received "${typeof handler}"`);
        }
      });
      return this;
    }
    areItemsValid() {
      const items = this.items();
      if (Array.isArray(items))
        return true;
      if (typeof items[Symbol.iterator] === "function")
        return true;
      if (typeof items[Symbol.asyncIterator] === "function")
        return true;
      return false;
    }
    prepareResultsArray() {
      const items = this.items();
      if (!Array.isArray(items))
        return this;
      if (!this.shouldUseCorrespondingResults())
        return this;
      this.meta.results = Array(items.length).fill(promise_pool_1.PromisePool.notRun);
      return this;
    }
    async process() {
      let index = 0;
      for await (const item of this.items()) {
        if (this.isStopped()) {
          break;
        }
        if (this.shouldUseCorrespondingResults()) {
          this.results()[index] = promise_pool_1.PromisePool.notRun;
        }
        this.startProcessing(item, index);
        index += 1;
        await this.waitForProcessingSlot();
      }
      return await this.drained();
    }
    async waitForProcessingSlot() {
      while (this.hasReachedConcurrencyLimit()) {
        await this.waitForActiveTaskToFinish();
      }
    }
    async waitForActiveTaskToFinish() {
      await Promise.race(this.tasks());
    }
    startProcessing(item, index) {
      const task = this.createTaskFor(item, index).then((result) => {
        this.save(result, index).removeActive(task);
      }).catch(async (error) => {
        await this.handleErrorFor(error, item, index);
        this.removeActive(task);
      }).finally(() => {
        this.processedItems().push(item);
        this.runOnTaskFinishedHandlers(item);
      });
      this.tasks().push(task);
      this.runOnTaskStartedHandlers(item);
    }
    async createTaskFor(item, index) {
      if (this.taskTimeout() === undefined) {
        return this.handler(item, index, this);
      }
      const [timer, canceller] = this.createTaskTimeout(item);
      return Promise.race([
        this.handler(item, index, this),
        timer()
      ]).finally(canceller);
    }
    createTaskTimeout(item) {
      let timerId;
      const timer = async () => new Promise((_resolve, reject) => {
        timerId = setTimeout(() => {
          reject(new promise_pool_error_1.PromisePoolError(`Task in promise pool timed out after ${this.taskTimeout()}ms`, item));
        }, this.taskTimeout());
      });
      const canceller = () => clearTimeout(timerId);
      return [timer, canceller];
    }
    save(result, position) {
      this.shouldUseCorrespondingResults() ? this.results()[position] = result : this.results().push(result);
      return this;
    }
    removeActive(task) {
      this.tasks().splice(this.tasks().indexOf(task), 1);
      return this;
    }
    async handleErrorFor(error, item, index) {
      if (this.shouldUseCorrespondingResults()) {
        this.results()[index] = promise_pool_1.PromisePool.failed;
      }
      if (this.isStoppingThePoolError(error)) {
        return;
      }
      if (this.isValidationError(error)) {
        this.markAsStopped();
        throw error;
      }
      this.hasErrorHandler() ? await this.runErrorHandlerFor(error, item) : this.saveErrorFor(error, item);
    }
    isStoppingThePoolError(error) {
      return error instanceof stop_the_promise_pool_error_1.StopThePromisePoolError;
    }
    isValidationError(error) {
      return error instanceof validation_error_1.ValidationError;
    }
    async runErrorHandlerFor(processingError, item) {
      try {
        await this.errorHandler?.(processingError, item, this);
      } catch (error) {
        this.rethrowIfNotStoppingThePool(error);
      }
    }
    runOnTaskStartedHandlers(item) {
      this.onTaskStartedHandlers.forEach((handler) => {
        handler(item, this);
      });
    }
    runOnTaskFinishedHandlers(item) {
      this.onTaskFinishedHandlers.forEach((handler) => {
        handler(item, this);
      });
    }
    rethrowIfNotStoppingThePool(error) {
      if (this.isStoppingThePoolError(error)) {
        return;
      }
      throw error;
    }
    saveErrorFor(error, item) {
      this.errors().push(promise_pool_error_1.PromisePoolError.createFrom(error, item));
    }
    async drained() {
      await this.drainActiveTasks();
      return {
        errors: this.errors(),
        results: this.results()
      };
    }
    async drainActiveTasks() {
      await Promise.all(this.tasks());
    }
  }
  exports.PromisePoolExecutor = PromisePoolExecutor;
});

// node_modules/@supercharge/promise-pool/dist/promise-pool.js
var require_promise_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PromisePool = undefined;
  var promise_pool_executor_1 = require_promise_pool_executor();

  class PromisePool {
    constructor(items) {
      this.timeout = undefined;
      this.concurrency = 10;
      this.items = items ?? [];
      this.errorHandler = undefined;
      this.onTaskStartedHandlers = [];
      this.onTaskFinishedHandlers = [];
      this.shouldResultsCorrespond = false;
    }
    withConcurrency(concurrency) {
      this.concurrency = concurrency;
      return this;
    }
    static withConcurrency(concurrency) {
      return new this().withConcurrency(concurrency);
    }
    withTaskTimeout(timeout) {
      this.timeout = timeout;
      return this;
    }
    static withTaskTimeout(timeout) {
      return new this().withTaskTimeout(timeout);
    }
    for(items) {
      const pool = new PromisePool(items).withConcurrency(this.concurrency);
      if (typeof this.errorHandler === "function") {
        pool.handleError(this.errorHandler);
      }
      return typeof this.timeout === "number" ? pool.withTaskTimeout(this.timeout) : pool;
    }
    static for(items) {
      return new this().for(items);
    }
    handleError(handler) {
      this.errorHandler = handler;
      return this;
    }
    onTaskStarted(handler) {
      this.onTaskStartedHandlers.push(handler);
      return this;
    }
    onTaskFinished(handler) {
      this.onTaskFinishedHandlers.push(handler);
      return this;
    }
    useCorrespondingResults() {
      this.shouldResultsCorrespond = true;
      return this;
    }
    async process(callback) {
      return new promise_pool_executor_1.PromisePoolExecutor().useConcurrency(this.concurrency).useCorrespondingResults(this.shouldResultsCorrespond).withTaskTimeout(this.timeout).withHandler(callback).handleError(this.errorHandler).onTaskStarted(this.onTaskStartedHandlers).onTaskFinished(this.onTaskFinishedHandlers).for(this.items).start();
    }
  }
  exports.PromisePool = PromisePool;
  PromisePool.notRun = Symbol("notRun");
  PromisePool.failed = Symbol("failed");
});

// node_modules/@supercharge/promise-pool/dist/contracts.js
var require_contracts3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@supercharge/promise-pool/dist/return-value.js
var require_return_value = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@supercharge/promise-pool/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var promise_pool_1 = require_promise_pool();
  exports.default = promise_pool_1.PromisePool;
  __exportStar(require_contracts3(), exports);
  __exportStar(require_promise_pool(), exports);
  __exportStar(require_promise_pool_error(), exports);
  __exportStar(require_return_value(), exports);
  __exportStar(require_stop_the_promise_pool_error(), exports);
  __exportStar(require_validation_error(), exports);
});

// node_modules/viem/_cjs/actions/index.js
var require_actions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestAddresses = exports.waitForTransactionReceipt = exports.getProof = exports.getPermissions = exports.getAddresses = exports.readContract = exports.watchPendingTransactions = exports.watchEvent = exports.watchBlockNumber = exports.watchBlocks = exports.multicall = exports.mine = exports.loadState = exports.increaseTime = exports.impersonateAccount = exports.getTransactionReceipt = exports.getTransaction = exports.getTransactionCount = exports.getTransactionConfirmations = exports.getStorageAt = exports.getLogs = exports.getGasPrice = exports.getFilterLogs = exports.getFilterChanges = exports.getFeeHistory = exports.getContractEvents = exports.getChainId = exports.getBytecode = exports.getBlockTransactionCount = exports.getBlockNumber = exports.getBlock = exports.getBlobBaseFee = exports.getBalance = exports.estimateGas = exports.estimateMaxPriorityFeePerGas = exports.estimateFeesPerGas = exports.estimateContractGas = exports.dumpState = exports.createPendingTransactionFilter = exports.createEventFilter = exports.createContractEventFilter = exports.createBlockFilter = exports.call = exports.getEnsText = exports.getEnsResolver = exports.getEnsName = exports.getEnsAvatar = exports.getEnsAddress = exports.deployContract = exports.addChain = undefined;
  exports.writeContract = exports.watchContractEvent = exports.watchAsset = exports.verifyTypedData = exports.verifyMessage = exports.verifyHash = exports.uninstallFilter = exports.switchChain = exports.stopImpersonatingAccount = exports.simulateContract = exports.signTypedData = exports.signMessage = exports.snapshot = exports.setStorageAt = exports.setRpcUrl = exports.setNonce = exports.setNextBlockTimestamp = exports.setNextBlockBaseFeePerGas = exports.setMinGasPrice = exports.setLoggingEnabled = exports.setIntervalMining = exports.setCoinbase = exports.setCode = exports.setBlockTimestampInterval = exports.setBlockGasLimit = exports.setAutomine = exports.setBalance = exports.sendUnsignedTransaction = exports.sendRawTransaction = exports.signTransaction = exports.sendTransaction = exports.defaultPrepareTransactionRequestParameters = exports.prepareTransactionRequest = exports.revert = exports.reset = exports.removeBlockTimestampInterval = exports.inspectTxpool = exports.getTxpoolStatus = exports.getTxpoolContent = exports.getAutomine = exports.dropTransaction = exports.requestPermissions = undefined;
  var addChain_js_1 = require_addChain();
  Object.defineProperty(exports, "addChain", { enumerable: true, get: function() {
    return addChain_js_1.addChain;
  } });
  var deployContract_js_1 = require_deployContract();
  Object.defineProperty(exports, "deployContract", { enumerable: true, get: function() {
    return deployContract_js_1.deployContract;
  } });
  var getEnsAddress_js_1 = require_getEnsAddress();
  Object.defineProperty(exports, "getEnsAddress", { enumerable: true, get: function() {
    return getEnsAddress_js_1.getEnsAddress;
  } });
  var getEnsAvatar_js_1 = require_getEnsAvatar();
  Object.defineProperty(exports, "getEnsAvatar", { enumerable: true, get: function() {
    return getEnsAvatar_js_1.getEnsAvatar;
  } });
  var getEnsName_js_1 = require_getEnsName();
  Object.defineProperty(exports, "getEnsName", { enumerable: true, get: function() {
    return getEnsName_js_1.getEnsName;
  } });
  var getEnsResolver_js_1 = require_getEnsResolver();
  Object.defineProperty(exports, "getEnsResolver", { enumerable: true, get: function() {
    return getEnsResolver_js_1.getEnsResolver;
  } });
  var getEnsText_js_1 = require_getEnsText();
  Object.defineProperty(exports, "getEnsText", { enumerable: true, get: function() {
    return getEnsText_js_1.getEnsText;
  } });
  var call_js_1 = require_call();
  Object.defineProperty(exports, "call", { enumerable: true, get: function() {
    return call_js_1.call;
  } });
  var createBlockFilter_js_1 = require_createBlockFilter();
  Object.defineProperty(exports, "createBlockFilter", { enumerable: true, get: function() {
    return createBlockFilter_js_1.createBlockFilter;
  } });
  var createContractEventFilter_js_1 = require_createContractEventFilter();
  Object.defineProperty(exports, "createContractEventFilter", { enumerable: true, get: function() {
    return createContractEventFilter_js_1.createContractEventFilter;
  } });
  var createEventFilter_js_1 = require_createEventFilter();
  Object.defineProperty(exports, "createEventFilter", { enumerable: true, get: function() {
    return createEventFilter_js_1.createEventFilter;
  } });
  var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
  Object.defineProperty(exports, "createPendingTransactionFilter", { enumerable: true, get: function() {
    return createPendingTransactionFilter_js_1.createPendingTransactionFilter;
  } });
  var dumpState_js_1 = require_dumpState();
  Object.defineProperty(exports, "dumpState", { enumerable: true, get: function() {
    return dumpState_js_1.dumpState;
  } });
  var estimateContractGas_js_1 = require_estimateContractGas();
  Object.defineProperty(exports, "estimateContractGas", { enumerable: true, get: function() {
    return estimateContractGas_js_1.estimateContractGas;
  } });
  var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
  Object.defineProperty(exports, "estimateFeesPerGas", { enumerable: true, get: function() {
    return estimateFeesPerGas_js_1.estimateFeesPerGas;
  } });
  var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
  Object.defineProperty(exports, "estimateMaxPriorityFeePerGas", { enumerable: true, get: function() {
    return estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas;
  } });
  var estimateGas_js_1 = require_estimateGas2();
  Object.defineProperty(exports, "estimateGas", { enumerable: true, get: function() {
    return estimateGas_js_1.estimateGas;
  } });
  var getBalance_js_1 = require_getBalance();
  Object.defineProperty(exports, "getBalance", { enumerable: true, get: function() {
    return getBalance_js_1.getBalance;
  } });
  var getBlobBaseFee_js_1 = require_getBlobBaseFee();
  Object.defineProperty(exports, "getBlobBaseFee", { enumerable: true, get: function() {
    return getBlobBaseFee_js_1.getBlobBaseFee;
  } });
  var getBlock_js_1 = require_getBlock();
  Object.defineProperty(exports, "getBlock", { enumerable: true, get: function() {
    return getBlock_js_1.getBlock;
  } });
  var getBlockNumber_js_1 = require_getBlockNumber();
  Object.defineProperty(exports, "getBlockNumber", { enumerable: true, get: function() {
    return getBlockNumber_js_1.getBlockNumber;
  } });
  var getBlockTransactionCount_js_1 = require_getBlockTransactionCount();
  Object.defineProperty(exports, "getBlockTransactionCount", { enumerable: true, get: function() {
    return getBlockTransactionCount_js_1.getBlockTransactionCount;
  } });
  var getBytecode_js_1 = require_getBytecode();
  Object.defineProperty(exports, "getBytecode", { enumerable: true, get: function() {
    return getBytecode_js_1.getBytecode;
  } });
  var getChainId_js_1 = require_getChainId();
  Object.defineProperty(exports, "getChainId", { enumerable: true, get: function() {
    return getChainId_js_1.getChainId;
  } });
  var getContractEvents_js_1 = require_getContractEvents();
  Object.defineProperty(exports, "getContractEvents", { enumerable: true, get: function() {
    return getContractEvents_js_1.getContractEvents;
  } });
  var getFeeHistory_js_1 = require_getFeeHistory();
  Object.defineProperty(exports, "getFeeHistory", { enumerable: true, get: function() {
    return getFeeHistory_js_1.getFeeHistory;
  } });
  var getFilterChanges_js_1 = require_getFilterChanges();
  Object.defineProperty(exports, "getFilterChanges", { enumerable: true, get: function() {
    return getFilterChanges_js_1.getFilterChanges;
  } });
  var getFilterLogs_js_1 = require_getFilterLogs();
  Object.defineProperty(exports, "getFilterLogs", { enumerable: true, get: function() {
    return getFilterLogs_js_1.getFilterLogs;
  } });
  var getGasPrice_js_1 = require_getGasPrice();
  Object.defineProperty(exports, "getGasPrice", { enumerable: true, get: function() {
    return getGasPrice_js_1.getGasPrice;
  } });
  var getLogs_js_1 = require_getLogs();
  Object.defineProperty(exports, "getLogs", { enumerable: true, get: function() {
    return getLogs_js_1.getLogs;
  } });
  var getStorageAt_js_1 = require_getStorageAt();
  Object.defineProperty(exports, "getStorageAt", { enumerable: true, get: function() {
    return getStorageAt_js_1.getStorageAt;
  } });
  var getTransactionConfirmations_js_1 = require_getTransactionConfirmations();
  Object.defineProperty(exports, "getTransactionConfirmations", { enumerable: true, get: function() {
    return getTransactionConfirmations_js_1.getTransactionConfirmations;
  } });
  var getTransactionCount_js_1 = require_getTransactionCount();
  Object.defineProperty(exports, "getTransactionCount", { enumerable: true, get: function() {
    return getTransactionCount_js_1.getTransactionCount;
  } });
  var getTransaction_js_1 = require_getTransaction();
  Object.defineProperty(exports, "getTransaction", { enumerable: true, get: function() {
    return getTransaction_js_1.getTransaction;
  } });
  var getTransactionReceipt_js_1 = require_getTransactionReceipt();
  Object.defineProperty(exports, "getTransactionReceipt", { enumerable: true, get: function() {
    return getTransactionReceipt_js_1.getTransactionReceipt;
  } });
  var impersonateAccount_js_1 = require_impersonateAccount();
  Object.defineProperty(exports, "impersonateAccount", { enumerable: true, get: function() {
    return impersonateAccount_js_1.impersonateAccount;
  } });
  var increaseTime_js_1 = require_increaseTime();
  Object.defineProperty(exports, "increaseTime", { enumerable: true, get: function() {
    return increaseTime_js_1.increaseTime;
  } });
  var loadState_js_1 = require_loadState();
  Object.defineProperty(exports, "loadState", { enumerable: true, get: function() {
    return loadState_js_1.loadState;
  } });
  var mine_js_1 = require_mine();
  Object.defineProperty(exports, "mine", { enumerable: true, get: function() {
    return mine_js_1.mine;
  } });
  var multicall_js_1 = require_multicall();
  Object.defineProperty(exports, "multicall", { enumerable: true, get: function() {
    return multicall_js_1.multicall;
  } });
  var watchBlocks_js_1 = require_watchBlocks();
  Object.defineProperty(exports, "watchBlocks", { enumerable: true, get: function() {
    return watchBlocks_js_1.watchBlocks;
  } });
  var watchBlockNumber_js_1 = require_watchBlockNumber();
  Object.defineProperty(exports, "watchBlockNumber", { enumerable: true, get: function() {
    return watchBlockNumber_js_1.watchBlockNumber;
  } });
  var watchEvent_js_1 = require_watchEvent();
  Object.defineProperty(exports, "watchEvent", { enumerable: true, get: function() {
    return watchEvent_js_1.watchEvent;
  } });
  var watchPendingTransactions_js_1 = require_watchPendingTransactions();
  Object.defineProperty(exports, "watchPendingTransactions", { enumerable: true, get: function() {
    return watchPendingTransactions_js_1.watchPendingTransactions;
  } });
  var readContract_js_1 = require_readContract();
  Object.defineProperty(exports, "readContract", { enumerable: true, get: function() {
    return readContract_js_1.readContract;
  } });
  var getAddresses_js_1 = require_getAddresses();
  Object.defineProperty(exports, "getAddresses", { enumerable: true, get: function() {
    return getAddresses_js_1.getAddresses;
  } });
  var getPermissions_js_1 = require_getPermissions();
  Object.defineProperty(exports, "getPermissions", { enumerable: true, get: function() {
    return getPermissions_js_1.getPermissions;
  } });
  var getProof_js_1 = require_getProof();
  Object.defineProperty(exports, "getProof", { enumerable: true, get: function() {
    return getProof_js_1.getProof;
  } });
  var waitForTransactionReceipt_js_1 = require_waitForTransactionReceipt();
  Object.defineProperty(exports, "waitForTransactionReceipt", { enumerable: true, get: function() {
    return waitForTransactionReceipt_js_1.waitForTransactionReceipt;
  } });
  var requestAddresses_js_1 = require_requestAddresses();
  Object.defineProperty(exports, "requestAddresses", { enumerable: true, get: function() {
    return requestAddresses_js_1.requestAddresses;
  } });
  var requestPermissions_js_1 = require_requestPermissions();
  Object.defineProperty(exports, "requestPermissions", { enumerable: true, get: function() {
    return requestPermissions_js_1.requestPermissions;
  } });
  var dropTransaction_js_1 = require_dropTransaction();
  Object.defineProperty(exports, "dropTransaction", { enumerable: true, get: function() {
    return dropTransaction_js_1.dropTransaction;
  } });
  var getAutomine_js_1 = require_getAutomine();
  Object.defineProperty(exports, "getAutomine", { enumerable: true, get: function() {
    return getAutomine_js_1.getAutomine;
  } });
  var getTxpoolContent_js_1 = require_getTxpoolContent();
  Object.defineProperty(exports, "getTxpoolContent", { enumerable: true, get: function() {
    return getTxpoolContent_js_1.getTxpoolContent;
  } });
  var getTxpoolStatus_js_1 = require_getTxpoolStatus();
  Object.defineProperty(exports, "getTxpoolStatus", { enumerable: true, get: function() {
    return getTxpoolStatus_js_1.getTxpoolStatus;
  } });
  var inspectTxpool_js_1 = require_inspectTxpool();
  Object.defineProperty(exports, "inspectTxpool", { enumerable: true, get: function() {
    return inspectTxpool_js_1.inspectTxpool;
  } });
  var removeBlockTimestampInterval_js_1 = require_removeBlockTimestampInterval();
  Object.defineProperty(exports, "removeBlockTimestampInterval", { enumerable: true, get: function() {
    return removeBlockTimestampInterval_js_1.removeBlockTimestampInterval;
  } });
  var reset_js_1 = require_reset();
  Object.defineProperty(exports, "reset", { enumerable: true, get: function() {
    return reset_js_1.reset;
  } });
  var revert_js_1 = require_revert();
  Object.defineProperty(exports, "revert", { enumerable: true, get: function() {
    return revert_js_1.revert;
  } });
  var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
  Object.defineProperty(exports, "prepareTransactionRequest", { enumerable: true, get: function() {
    return prepareTransactionRequest_js_1.prepareTransactionRequest;
  } });
  Object.defineProperty(exports, "defaultPrepareTransactionRequestParameters", { enumerable: true, get: function() {
    return prepareTransactionRequest_js_1.defaultParameters;
  } });
  var sendTransaction_js_1 = require_sendTransaction();
  Object.defineProperty(exports, "sendTransaction", { enumerable: true, get: function() {
    return sendTransaction_js_1.sendTransaction;
  } });
  var signTransaction_js_1 = require_signTransaction();
  Object.defineProperty(exports, "signTransaction", { enumerable: true, get: function() {
    return signTransaction_js_1.signTransaction;
  } });
  var sendRawTransaction_js_1 = require_sendRawTransaction();
  Object.defineProperty(exports, "sendRawTransaction", { enumerable: true, get: function() {
    return sendRawTransaction_js_1.sendRawTransaction;
  } });
  var sendUnsignedTransaction_js_1 = require_sendUnsignedTransaction();
  Object.defineProperty(exports, "sendUnsignedTransaction", { enumerable: true, get: function() {
    return sendUnsignedTransaction_js_1.sendUnsignedTransaction;
  } });
  var setBalance_js_1 = require_setBalance();
  Object.defineProperty(exports, "setBalance", { enumerable: true, get: function() {
    return setBalance_js_1.setBalance;
  } });
  var setAutomine_js_1 = require_setAutomine();
  Object.defineProperty(exports, "setAutomine", { enumerable: true, get: function() {
    return setAutomine_js_1.setAutomine;
  } });
  var setBlockGasLimit_js_1 = require_setBlockGasLimit();
  Object.defineProperty(exports, "setBlockGasLimit", { enumerable: true, get: function() {
    return setBlockGasLimit_js_1.setBlockGasLimit;
  } });
  var setBlockTimestampInterval_js_1 = require_setBlockTimestampInterval();
  Object.defineProperty(exports, "setBlockTimestampInterval", { enumerable: true, get: function() {
    return setBlockTimestampInterval_js_1.setBlockTimestampInterval;
  } });
  var setCode_js_1 = require_setCode();
  Object.defineProperty(exports, "setCode", { enumerable: true, get: function() {
    return setCode_js_1.setCode;
  } });
  var setCoinbase_js_1 = require_setCoinbase();
  Object.defineProperty(exports, "setCoinbase", { enumerable: true, get: function() {
    return setCoinbase_js_1.setCoinbase;
  } });
  var setIntervalMining_js_1 = require_setIntervalMining();
  Object.defineProperty(exports, "setIntervalMining", { enumerable: true, get: function() {
    return setIntervalMining_js_1.setIntervalMining;
  } });
  var setLoggingEnabled_js_1 = require_setLoggingEnabled();
  Object.defineProperty(exports, "setLoggingEnabled", { enumerable: true, get: function() {
    return setLoggingEnabled_js_1.setLoggingEnabled;
  } });
  var setMinGasPrice_js_1 = require_setMinGasPrice();
  Object.defineProperty(exports, "setMinGasPrice", { enumerable: true, get: function() {
    return setMinGasPrice_js_1.setMinGasPrice;
  } });
  var setNextBlockBaseFeePerGas_js_1 = require_setNextBlockBaseFeePerGas();
  Object.defineProperty(exports, "setNextBlockBaseFeePerGas", { enumerable: true, get: function() {
    return setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas;
  } });
  var setNextBlockTimestamp_js_1 = require_setNextBlockTimestamp();
  Object.defineProperty(exports, "setNextBlockTimestamp", { enumerable: true, get: function() {
    return setNextBlockTimestamp_js_1.setNextBlockTimestamp;
  } });
  var setNonce_js_1 = require_setNonce();
  Object.defineProperty(exports, "setNonce", { enumerable: true, get: function() {
    return setNonce_js_1.setNonce;
  } });
  var setRpcUrl_js_1 = require_setRpcUrl();
  Object.defineProperty(exports, "setRpcUrl", { enumerable: true, get: function() {
    return setRpcUrl_js_1.setRpcUrl;
  } });
  var setStorageAt_js_1 = require_setStorageAt();
  Object.defineProperty(exports, "setStorageAt", { enumerable: true, get: function() {
    return setStorageAt_js_1.setStorageAt;
  } });
  var snapshot_js_1 = require_snapshot();
  Object.defineProperty(exports, "snapshot", { enumerable: true, get: function() {
    return snapshot_js_1.snapshot;
  } });
  var signMessage_js_1 = require_signMessage();
  Object.defineProperty(exports, "signMessage", { enumerable: true, get: function() {
    return signMessage_js_1.signMessage;
  } });
  var signTypedData_js_1 = require_signTypedData();
  Object.defineProperty(exports, "signTypedData", { enumerable: true, get: function() {
    return signTypedData_js_1.signTypedData;
  } });
  var simulateContract_js_1 = require_simulateContract();
  Object.defineProperty(exports, "simulateContract", { enumerable: true, get: function() {
    return simulateContract_js_1.simulateContract;
  } });
  var stopImpersonatingAccount_js_1 = require_stopImpersonatingAccount();
  Object.defineProperty(exports, "stopImpersonatingAccount", { enumerable: true, get: function() {
    return stopImpersonatingAccount_js_1.stopImpersonatingAccount;
  } });
  var switchChain_js_1 = require_switchChain();
  Object.defineProperty(exports, "switchChain", { enumerable: true, get: function() {
    return switchChain_js_1.switchChain;
  } });
  var uninstallFilter_js_1 = require_uninstallFilter();
  Object.defineProperty(exports, "uninstallFilter", { enumerable: true, get: function() {
    return uninstallFilter_js_1.uninstallFilter;
  } });
  var verifyHash_js_1 = require_verifyHash();
  Object.defineProperty(exports, "verifyHash", { enumerable: true, get: function() {
    return verifyHash_js_1.verifyHash;
  } });
  var verifyMessage_js_1 = require_verifyMessage2();
  Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
    return verifyMessage_js_1.verifyMessage;
  } });
  var verifyTypedData_js_1 = require_verifyTypedData2();
  Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
    return verifyTypedData_js_1.verifyTypedData;
  } });
  var watchAsset_js_1 = require_watchAsset();
  Object.defineProperty(exports, "watchAsset", { enumerable: true, get: function() {
    return watchAsset_js_1.watchAsset;
  } });
  var watchContractEvent_js_1 = require_watchContractEvent();
  Object.defineProperty(exports, "watchContractEvent", { enumerable: true, get: function() {
    return watchContractEvent_js_1.watchContractEvent;
  } });
  var writeContract_js_1 = require_writeContract();
  Object.defineProperty(exports, "writeContract", { enumerable: true, get: function() {
    return writeContract_js_1.writeContract;
  } });
});

// node_modules/base-x/src/index.js
var require_src = __commonJS((exports, module) => {
  function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
      if (source instanceof Uint8Array) {
      } else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size2);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size2 - 1;(carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size2 - length;
      while (it2 !== size2 && b58[it2] === 0) {
        it2++;
      }
      var str2 = LEADER.repeat(zeroes);
      for (;it2 < size2; ++it2) {
        str2 += ALPHABET.charAt(b58[it2]);
      }
      return str2;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size2);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size2 - 1;(carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      var it4 = size2 - length;
      while (it4 !== size2 && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size2 - it4));
      var j2 = zeroes;
      while (it4 !== size2) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode
    };
  }
  module.exports = base;
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS((exports, module) => {
  var basex = require_src();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS((exports, module) => {
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isArray(val) {
    if (Array.isArray)
      return Array.isArray(val);
    return val instanceof Array;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function isRegexp(val) {
    if (val instanceof RegExp)
      return true;
    return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
  }
  function isGeneratorFn(name, val) {
    return ctorName(name) === "GeneratorFunction";
  }
  function isGeneratorObj(val) {
    return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
  }
  function isArguments(val) {
    try {
      if (typeof val.length === "number" && typeof val.callee === "function") {
        return true;
      }
    } catch (err) {
      if (err.message.indexOf("callee") !== -1) {
        return true;
      }
    }
    return false;
  }
  function isBuffer(val) {
    if (val.constructor && typeof val.constructor.isBuffer === "function") {
      return val.constructor.isBuffer(val);
    }
    return false;
  }
  var toString = Object.prototype.toString;
  module.exports = function kindOf(val) {
    if (val === undefined)
      return "undefined";
    if (val === null)
      return "null";
    var type = typeof val;
    if (type === "boolean")
      return "boolean";
    if (type === "string")
      return "string";
    if (type === "number")
      return "number";
    if (type === "symbol")
      return "symbol";
    if (type === "function") {
      return isGeneratorFn(val) ? "generatorfunction" : "function";
    }
    if (isArray(val))
      return "array";
    if (isBuffer(val))
      return "buffer";
    if (isArguments(val))
      return "arguments";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    if (isRegexp(val))
      return "regexp";
    switch (ctorName(val)) {
      case "Symbol":
        return "symbol";
      case "Promise":
        return "promise";
      case "WeakMap":
        return "weakmap";
      case "WeakSet":
        return "weakset";
      case "Map":
        return "map";
      case "Set":
        return "set";
      case "Int8Array":
        return "int8array";
      case "Uint8Array":
        return "uint8array";
      case "Uint8ClampedArray":
        return "uint8clampedarray";
      case "Int16Array":
        return "int16array";
      case "Uint16Array":
        return "uint16array";
      case "Int32Array":
        return "int32array";
      case "Uint32Array":
        return "uint32array";
      case "Float32Array":
        return "float32array";
      case "Float64Array":
        return "float64array";
    }
    if (isGeneratorObj(val)) {
      return "generator";
    }
    type = toString.call(val);
    switch (type) {
      case "[object Object]":
        return "object";
      case "[object Map Iterator]":
        return "mapiterator";
      case "[object Set Iterator]":
        return "setiterator";
      case "[object String Iterator]":
        return "stringiterator";
      case "[object Array Iterator]":
        return "arrayiterator";
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
  };
});

// node_modules/is-extendable/index.js
var require_is_extendable = __commonJS((exports, module) => {
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module.exports = function isExtendable(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
  };
});

// node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS((exports, module) => {
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  var isObject = require_is_extendable();
  module.exports = function extend(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1;i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
});

// node_modules/section-matter/index.js
var require_section_matter = __commonJS((exports, module) => {
  function isDelimiter(line, delim) {
    if (line.slice(0, delim.length) !== delim) {
      return false;
    }
    if (line.charAt(delim.length + 1) === delim.slice(-1)) {
      return false;
    }
    return true;
  }
  function toObject(input) {
    if (typeOf(input) !== "object") {
      input = { content: input };
    }
    if (typeof input.content !== "string" && !isBuffer(input.content)) {
      throw new TypeError("expected a buffer or string");
    }
    input.content = input.content.toString();
    input.sections = [];
    return input;
  }
  function getKey(val, delim) {
    return val ? val.slice(delim.length).trim() : "";
  }
  function createSection() {
    return { key: "", data: "", content: "" };
  }
  function identity(val) {
    return val;
  }
  function isBuffer(val) {
    if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
      return val.constructor.isBuffer(val);
    }
    return false;
  }
  var typeOf = require_kind_of();
  var extend = require_extend_shallow();
  module.exports = function(input, options2) {
    if (typeof options2 === "function") {
      options2 = { parse: options2 };
    }
    var file = toObject(input);
    var defaults = { section_delimiter: "---", parse: identity };
    var opts = extend({}, defaults, options2);
    var delim = opts.section_delimiter;
    var lines = file.content.split(/\r?\n/);
    var sections = null;
    var section = createSection();
    var content = [];
    var stack = [];
    function initSections(val) {
      file.content = val;
      sections = [];
      content = [];
    }
    function closeSection(val) {
      if (stack.length) {
        section.key = getKey(stack[0], delim);
        section.content = val;
        opts.parse(section, sections);
        sections.push(section);
        section = createSection();
        content = [];
        stack = [];
      }
    }
    for (var i = 0;i < lines.length; i++) {
      var line = lines[i];
      var len = stack.length;
      var ln = line.trim();
      if (isDelimiter(ln, delim)) {
        if (ln.length === 3 && i !== 0) {
          if (len === 0 || len === 2) {
            content.push(line);
            continue;
          }
          stack.push(ln);
          section.data = content.join("\n");
          content = [];
          continue;
        }
        if (sections === null) {
          initSections(content.join("\n"));
        }
        if (len === 2) {
          closeSection(content.join("\n"));
        }
        stack.push(ln);
        continue;
      }
      content.push(line);
    }
    if (sections === null) {
      initSections(content.join("\n"));
    } else {
      closeSection(content.join("\n"));
    }
    file.sections = sections;
    return file;
  };
});

// node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS((exports, module) => {
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length;index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0;cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  exports.isNothing = isNothing;
  exports.isObject = isObject;
  exports.toArray = toArray;
  exports.repeat = repeat;
  exports.isNegativeZero = isNegativeZero;
  exports.extend = extend;
});

// node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS((exports, module) => {
  function YAMLException(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) {
      result += " " + this.mark.toString();
    }
    return result;
  };
  module.exports = YAMLException;
});

// node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS((exports, module) => {
  function Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  var common = require_common();
  Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer)
      return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while (start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > maxLength / 2 - 1) {
        head = " ... ";
        start += 5;
        break;
      }
    }
    tail = "";
    end = this.position;
    while (end < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > maxLength / 2 - 1) {
        tail = " ... ";
        end -= 5;
        break;
      }
    }
    snippet = this.buffer.slice(start, end);
    return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
  };
  Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) {
      where += 'in "' + this.name + '" ';
    }
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += ":\n" + snippet;
      }
    }
    return where;
  };
  module.exports = Mark;
});

// node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS((exports, module) => {
  function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
      Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type(tag, options2) {
    options2 = options2 || {};
    Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.tag = tag;
    this.kind = options2["kind"] || null;
    this.resolve = options2["resolve"] || function() {
      return true;
    };
    this.construct = options2["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options2["instanceOf"] || null;
    this.predicate = options2["predicate"] || null;
    this.represent = options2["represent"] || null;
    this.defaultStyle = options2["defaultStyle"] || null;
    this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var YAMLException = require_exception();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  module.exports = Type;
});

// node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS((exports, module) => {
  function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });
      result.push(currentType);
    });
    return result.filter(function(type, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type) {
      result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for (index = 0, length = arguments.length;index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
      if (type.loadKind && type.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
    });
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  var common = require_common();
  var YAMLException = require_exception();
  var Type = require_type();
  Schema.DEFAULT = null;
  Schema.create = function createSchema() {
    var schemas, types;
    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT;
        types = arguments[0];
        break;
      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    schemas = common.toArray(schemas);
    types = common.toArray(types);
    if (!schemas.every(function(schema) {
      return schema instanceof Schema;
    })) {
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    }
    if (!types.every(function(type) {
      return type instanceof Type;
    })) {
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    return new Schema({
      include: schemas,
      explicit: types
    });
  };
  module.exports = Schema;
});

// node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS((exports, module) => {
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS((exports, module) => {
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS((exports, module) => {
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS((exports, module) => {
  var Schema = require_schema();
  module.exports = new Schema({
    explicit: [
      require_str(),
      require_seq(),
      require_map()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS((exports, module) => {
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS((exports, module) => {
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS((exports, module) => {
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max)
      return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max)
        return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (;index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (ch !== "0" && ch !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (;index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      for (;index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "_")
      return false;
    for (;index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (ch === ":")
        break;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_")
      return false;
    if (ch !== ":")
      return true;
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-")
        sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0")
      return 0;
    if (ch === "0") {
      if (value[1] === "b")
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x")
        return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseInt(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  var common = require_common();
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS((exports, module) => {
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    } else if (value.indexOf(":") >= 0) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseFloat(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseFloat(value, 10);
  }
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  var common = require_common();
  var Type = require_type();
  var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + "|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" + "|[-+]?\\.(?:inf|Inf|INF)" + "|\\.(?:nan|NaN|NAN))$");
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  module.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS((exports, module) => {
  var Schema = require_schema();
  module.exports = new Schema({
    include: [
      require_failsafe()
    ],
    implicit: [
      require_null(),
      require_bool(),
      require_int(),
      require_float()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS((exports, module) => {
  var Schema = require_schema();
  module.exports = new Schema({
    include: [
      require_json()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS((exports, module) => {
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000;
      if (match[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var Type = require_type();
  var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9])" + "-([0-9][0-9])$");
  var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9]?)" + "-([0-9][0-9]?)" + "(?:[Tt]|[ \\t]+)" + "([0-9][0-9]?)" + ":([0-9][0-9])" + ":([0-9][0-9])" + "(?:\\.([0-9]*))?" + "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + "(?::([0-9][0-9]))?))?$");
  module.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS((exports, module) => {
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
});

// node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS((exports, module) => {
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    for (idx = 0;idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    for (idx = 0;idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    if (NodeBuffer) {
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    for (idx = 0;idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map[bits >> 18 & 63];
      result += map[bits >> 12 & 63];
      result += map[bits >> 6 & 63];
      result += map[bits & 63];
    } else if (tail === 2) {
      result += map[bits >> 10 & 63];
      result += map[bits >> 4 & 63];
      result += map[bits << 2 & 63];
      result += map[64];
    } else if (tail === 1) {
      result += map[bits >> 2 & 63];
      result += map[bits << 4 & 63];
      result += map[64];
      result += map[64];
    }
    return result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  var NodeBuffer;
  try {
    _require = __require;
    NodeBuffer = _require("buffer").Buffer;
  } catch (__) {
  }
  var _require;
  var Type = require_type();
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  module.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
});

// node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS((exports, module) => {
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length;index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  module.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
});

// node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS((exports, module) => {
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length;index < length; index += 1) {
      pair = object[index];
      if (_toString.call(pair) !== "[object Object]")
        return false;
      keys = Object.keys(pair);
      if (keys.length !== 1)
        return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length;index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  var Type = require_type();
  var _toString = Object.prototype.toString;
  module.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
});

// node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS((exports, module) => {
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS((exports, module) => {
  var Schema = require_schema();
  module.exports = new Schema({
    include: [
      require_core()
    ],
    implicit: [
      require_timestamp(),
      require_merge()
    ],
    explicit: [
      require_binary(),
      require_omap(),
      require_pairs(),
      require_set()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS((exports, module) => {
  function resolveJavascriptUndefined() {
    return true;
  }
  function constructJavascriptUndefined() {
    return;
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object) {
    return typeof object === "undefined";
  }
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS((exports, module) => {
  function resolveJavascriptRegExp(data) {
    if (data === null)
      return false;
    if (data.length === 0)
      return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      if (modifiers.length > 3)
        return false;
      if (regexp[regexp.length - modifiers.length - 1] !== "/")
        return false;
    }
    return true;
  }
  function constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    if (object.global)
      result += "g";
    if (object.multiline)
      result += "m";
    if (object.ignoreCase)
      result += "i";
    return result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS((exports, module) => {
  function resolveJavascriptFunction(data) {
    if (data === null)
      return false;
    try {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  function constructJavascriptFunction(data) {
    var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
      throw new Error("Failed to resolve function");
    }
    ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    if (ast.body[0].expression.body.type === "BlockStatement") {
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    return new Function(params, "return " + source.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  var esprima;
  try {
    _require = __require;
    esprima = _require("esprima");
  } catch (_) {
    if (typeof window !== "undefined")
      esprima = window.esprima;
  }
  var _require;
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS((exports, module) => {
  var Schema = require_schema();
  module.exports = Schema.DEFAULT = new Schema({
    include: [
      require_default_safe()
    ],
    explicit: [
      require_undefined(),
      require_regexp(),
      require_function()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS((exports, module) => {
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "\t" : c === 9 ? "\t" : c === 110 ? `
` : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? `\r` : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
  }
  function State(input, options2) {
    this.input = input;
    this.filename = options2["filename"] || null;
    this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
    this.onWarning = options2["onWarning"] || null;
    this.legacy = options2["legacy"] || false;
    this.json = options2["json"] || false;
    this.listener = options2["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length;_position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length;index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length;index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length;index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (;hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      _pos = state.position;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else {
        break;
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if (state.lineIndent > nodeIndent && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33)
      return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38)
      return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42)
      return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag !== null && state.tag !== "!") {
      if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length;typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type = state.typeMap[state.kind || "fallback"][state.tag];
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0)
        readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options2) {
    input = String(input);
    options2 = options2 || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options2);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options2) {
    if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
      options2 = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options2);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length;index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load(input, options2) {
    var documents = loadDocuments(input, options2);
    if (documents.length === 0) {
      return;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  function safeLoadAll(input, iterator, options2) {
    if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
      options2 = iterator;
      iterator = null;
    }
    return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  function safeLoad(input, options2) {
    return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  var common = require_common();
  var YAMLException = require_exception();
  var Mark = require_mark();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i = 0;i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  var i;
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      state.tagMap[handle] = prefix;
    }
  };
  exports.loadAll = loadAll;
  exports.load = load;
  exports.safeLoadAll = safeLoadAll;
  exports.safeLoad = safeLoad;
});

// node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS((exports, module) => {
  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null)
      return {};
    result = {};
    keys = Object.keys(map);
    for (index = 0, length = keys.length;index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type = schema.compiledTypeMap["fallback"][tag];
      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  function State(options2) {
    this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options2["indent"] || 2);
    this.noArrayIndent = options2["noArrayIndent"] || false;
    this.skipInvalid = options2["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
    this.sortKeys = options2["sortKeys"] || false;
    this.lineWidth = options2["lineWidth"] || 80;
    this.noRefs = options2["noRefs"] || false;
    this.noCompatMode = options2["noCompatMode"] || false;
    this.condenseFlow = options2["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n")
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type;
    for (index = 0, length = state.implicitTypes.length;index < length; index += 1) {
      type = state.implicitTypes[index];
      if (type.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
  }
  function isNsChar(c) {
    return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev) {
    return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) {
      for (i = 0;i < string.length; i++) {
        char = string.charCodeAt(i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
    } else {
      for (i = 0;i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0) {
        return "''";
      }
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string, lineWidth) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for (var i = 0;i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char >= 55296 && char <= 56319) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 56320 && nextChar <= 57343) {
          result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
          i++;
          continue;
        }
      }
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length;index < length; index += 1) {
      if (writeNode(state, level, object[index], false, false)) {
        if (index !== 0)
          _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length;index < length; index += 1) {
      if (writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length;index < length; index += 1) {
      pairBuffer = "";
      if (index !== 0)
        pairBuffer += ", ";
      if (state.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length;index < length; index += 1) {
      pairBuffer = "";
      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length;index < length; index += 1) {
      type = typeList[index];
      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
        state.tag = explicit ? type.tag : "?";
        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;
          if (_toString.call(type.represent) === "[object Function]") {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        if (block && state.dump.length !== 0) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type);
      }
      if (state.tag !== null && state.tag !== "?") {
        state.dump = "!<" + state.tag + "> " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length;index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length;index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length;index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true))
      return state.dump + "\n";
    return "";
  }
  function safeDump(input, options2) {
    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  var common = require_common();
  var YAMLException = require_exception();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  exports.dump = dump;
  exports.safeDump = safeDump;
});

// node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS((exports, module) => {
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  var loader = require_loader();
  var dumper = require_dumper();
  exports.Type = require_type();
  exports.Schema = require_schema();
  exports.FAILSAFE_SCHEMA = require_failsafe();
  exports.JSON_SCHEMA = require_json();
  exports.CORE_SCHEMA = require_core();
  exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
  exports.DEFAULT_FULL_SCHEMA = require_default_full();
  exports.load = loader.load;
  exports.loadAll = loader.loadAll;
  exports.safeLoad = loader.safeLoad;
  exports.safeLoadAll = loader.safeLoadAll;
  exports.dump = dumper.dump;
  exports.safeDump = dumper.safeDump;
  exports.YAMLException = require_exception();
  exports.MINIMAL_SCHEMA = require_failsafe();
  exports.SAFE_SCHEMA = require_default_safe();
  exports.DEFAULT_SCHEMA = require_default_full();
  exports.scan = deprecated("scan");
  exports.parse = deprecated("parse");
  exports.compose = deprecated("compose");
  exports.addConstructor = deprecated("addConstructor");
});

// node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS((exports, module) => {
  var yaml = require_js_yaml();
  module.exports = yaml;
});

// node_modules/gray-matter/lib/engines.js
var require_engines = __commonJS((exports, module) => {
  var yaml = require_js_yaml2();
  var engines = exports = module.exports;
  engines.yaml = {
    parse: yaml.safeLoad.bind(yaml),
    stringify: yaml.safeDump.bind(yaml)
  };
  engines.json = {
    parse: JSON.parse.bind(JSON),
    stringify: function(obj, options2) {
      const opts = Object.assign({ replacer: null, space: 2 }, options2);
      return JSON.stringify(obj, opts.replacer, opts.space);
    }
  };
  engines.javascript = {
    parse: function parse(str, options, wrap) {
      try {
        if (wrap !== false) {
          str = "(function() {\nreturn " + str.trim() + ";\n}());";
        }
        return eval(str) || {};
      } catch (err) {
        if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
          return parse(str, options, false);
        }
        throw new SyntaxError(err);
      }
    },
    stringify: function() {
      throw new Error("stringifying JavaScript is not supported");
    }
  };
});

// node_modules/strip-bom-string/index.js
var require_strip_bom_string = __commonJS((exports, module) => {
  /*!
   * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(str2) {
    if (typeof str2 === "string" && str2.charAt(0) === "\uFEFF") {
      return str2.slice(1);
    }
    return str2;
  };
});

// node_modules/gray-matter/lib/utils.js
var require_utils9 = __commonJS((exports) => {
  var stripBom = require_strip_bom_string();
  var typeOf = require_kind_of();
  exports.define = function(obj, key, val) {
    Reflect.defineProperty(obj, key, {
      enumerable: false,
      configurable: true,
      writable: true,
      value: val
    });
  };
  exports.isBuffer = function(val) {
    return typeOf(val) === "buffer";
  };
  exports.isObject = function(val) {
    return typeOf(val) === "object";
  };
  exports.toBuffer = function(input) {
    return typeof input === "string" ? Buffer.from(input) : input;
  };
  exports.toString = function(input) {
    if (exports.isBuffer(input))
      return stripBom(String(input));
    if (typeof input !== "string") {
      throw new TypeError("expected input to be a string or buffer");
    }
    return stripBom(input);
  };
  exports.arrayify = function(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  };
  exports.startsWith = function(str2, substr, len) {
    if (typeof len !== "number")
      len = substr.length;
    return str2.slice(0, len) === substr;
  };
});

// node_modules/gray-matter/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  var engines = require_engines();
  var utils = require_utils9();
  module.exports = function(options2) {
    const opts = Object.assign({}, options2);
    opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || "---");
    if (opts.delimiters.length === 1) {
      opts.delimiters.push(opts.delimiters[0]);
    }
    opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
    opts.engines = Object.assign({}, engines, opts.parsers, opts.engines);
    return opts;
  };
});

// node_modules/gray-matter/lib/engine.js
var require_engine = __commonJS((exports, module) => {
  function aliase(name) {
    switch (name.toLowerCase()) {
      case "js":
      case "javascript":
        return "javascript";
      case "coffee":
      case "coffeescript":
      case "cson":
        return "coffee";
      case "yaml":
      case "yml":
        return "yaml";
      default: {
        return name;
      }
    }
  }
  module.exports = function(name, options2) {
    let engine = options2.engines[name] || options2.engines[aliase(name)];
    if (typeof engine === "undefined") {
      throw new Error('gray-matter engine "' + name + '" is not registered');
    }
    if (typeof engine === "function") {
      engine = { parse: engine };
    }
    return engine;
  };
});

// node_modules/gray-matter/lib/stringify.js
var require_stringify2 = __commonJS((exports, module) => {
  function newline(str2) {
    return str2.slice(-1) !== "\n" ? str2 + "\n" : str2;
  }
  var typeOf = require_kind_of();
  var getEngine = require_engine();
  var defaults = require_defaults();
  module.exports = function(file, data, options2) {
    if (data == null && options2 == null) {
      switch (typeOf(file)) {
        case "object":
          data = file.data;
          options2 = {};
          break;
        case "string":
          return file;
        default: {
          throw new TypeError("expected file to be a string or object");
        }
      }
    }
    const str2 = file.content;
    const opts = defaults(options2);
    if (data == null) {
      if (!opts.data)
        return file;
      data = opts.data;
    }
    const language = file.language || opts.language;
    const engine = getEngine(language, opts);
    if (typeof engine.stringify !== "function") {
      throw new TypeError('expected "' + language + '.stringify" to be a function');
    }
    data = Object.assign({}, file.data, data);
    const open = opts.delimiters[0];
    const close = opts.delimiters[1];
    const matter = engine.stringify(data, options2).trim();
    let buf = "";
    if (matter !== "{}") {
      buf = newline(open) + newline(matter) + newline(close);
    }
    if (typeof file.excerpt === "string" && file.excerpt !== "") {
      if (str2.indexOf(file.excerpt.trim()) === -1) {
        buf += newline(file.excerpt) + newline(close);
      }
    }
    return buf + newline(str2);
  };
});

// node_modules/gray-matter/lib/excerpt.js
var require_excerpt = __commonJS((exports, module) => {
  var defaults = require_defaults();
  module.exports = function(file, options2) {
    const opts = defaults(options2);
    if (file.data == null) {
      file.data = {};
    }
    if (typeof opts.excerpt === "function") {
      return opts.excerpt(file, opts);
    }
    const sep = file.data.excerpt_separator || opts.excerpt_separator;
    if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
      return file;
    }
    const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];
    const idx = file.content.indexOf(delimiter);
    if (idx !== -1) {
      file.excerpt = file.content.slice(0, idx);
    }
    return file;
  };
});

// node_modules/gray-matter/lib/to-file.js
var require_to_file = __commonJS((exports, module) => {
  var typeOf = require_kind_of();
  var stringify2 = require_stringify2();
  var utils = require_utils9();
  module.exports = function(file) {
    if (typeOf(file) !== "object") {
      file = { content: file };
    }
    if (typeOf(file.data) !== "object") {
      file.data = {};
    }
    if (file.contents && file.content == null) {
      file.content = file.contents;
    }
    utils.define(file, "orig", utils.toBuffer(file.content));
    utils.define(file, "language", file.language || "");
    utils.define(file, "matter", file.matter || "");
    utils.define(file, "stringify", function(data, options2) {
      if (options2 && options2.language) {
        file.language = options2.language;
      }
      return stringify2(file, data, options2);
    });
    file.content = utils.toString(file.content);
    file.isEmpty = false;
    file.excerpt = "";
    return file;
  };
});

// node_modules/gray-matter/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var getEngine = require_engine();
  var defaults = require_defaults();
  module.exports = function(language, str2, options2) {
    const opts = defaults(options2);
    const engine = getEngine(language, opts);
    if (typeof engine.parse !== "function") {
      throw new TypeError('expected "' + language + '.parse" to be a function');
    }
    return engine.parse(str2, opts);
  };
});

// node_modules/gray-matter/index.js
var require_gray_matter = __commonJS((exports, module) => {
  function matter(input, options2) {
    if (input === "") {
      return { data: {}, content: input, excerpt: "", orig: input };
    }
    let file = toFile(input);
    const cached = matter.cache[file.content];
    if (!options2) {
      if (cached) {
        file = Object.assign({}, cached);
        file.orig = cached.orig;
        return file;
      }
      matter.cache[file.content] = file;
    }
    return parseMatter(file, options2);
  }
  function parseMatter(file, options2) {
    const opts = defaults(options2);
    const open = opts.delimiters[0];
    const close = "\n" + opts.delimiters[1];
    let str2 = file.content;
    if (opts.language) {
      file.language = opts.language;
    }
    const openLen = open.length;
    if (!utils.startsWith(str2, open, openLen)) {
      excerpt(file, opts);
      return file;
    }
    if (str2.charAt(openLen) === open.slice(-1)) {
      return file;
    }
    str2 = str2.slice(openLen);
    const len = str2.length;
    const language = matter.language(str2, opts);
    if (language.name) {
      file.language = language.name;
      str2 = str2.slice(language.raw.length);
    }
    let closeIndex = str2.indexOf(close);
    if (closeIndex === -1) {
      closeIndex = len;
    }
    file.matter = str2.slice(0, closeIndex);
    const block = file.matter.replace(/^\s*#[^\n]+/gm, "").trim();
    if (block === "") {
      file.isEmpty = true;
      file.empty = file.content;
      file.data = {};
    } else {
      file.data = parse2(file.language, file.matter, opts);
    }
    if (closeIndex === len) {
      file.content = "";
    } else {
      file.content = str2.slice(closeIndex + close.length);
      if (file.content[0] === "\r") {
        file.content = file.content.slice(1);
      }
      if (file.content[0] === "\n") {
        file.content = file.content.slice(1);
      }
    }
    excerpt(file, opts);
    if (opts.sections === true || typeof opts.section === "function") {
      sections(file, opts.section);
    }
    return file;
  }
  var fs = __require("fs");
  var sections = require_section_matter();
  var defaults = require_defaults();
  var stringify2 = require_stringify2();
  var excerpt = require_excerpt();
  var engines = require_engines();
  var toFile = require_to_file();
  var parse2 = require_parse();
  var utils = require_utils9();
  matter.engines = engines;
  matter.stringify = function(file, data, options2) {
    if (typeof file === "string")
      file = matter(file, options2);
    return stringify2(file, data, options2);
  };
  matter.read = function(filepath, options2) {
    const str2 = fs.readFileSync(filepath, "utf8");
    const file = matter(str2, options2);
    file.path = filepath;
    return file;
  };
  matter.test = function(str2, options2) {
    return utils.startsWith(str2, defaults(options2).delimiters[0]);
  };
  matter.language = function(str2, options2) {
    const opts = defaults(options2);
    const open = opts.delimiters[0];
    if (matter.test(str2)) {
      str2 = str2.slice(open.length);
    }
    const language = str2.slice(0, str2.search(/\r?\n/));
    return {
      raw: language,
      name: language ? language.trim() : ""
    };
  };
  matter.cache = {};
  matter.clearCache = function() {
    matter.cache = {};
  };
  module.exports = matter;
});

// node_modules/@bgd-labs/js-utils/dist/node.cjs
var require_node2 = __commonJS((exports, module) => {
  function compareStorageLayouts(layoutBefore, layoutAfter) {
    const layoutForComparisonBefore = preformatStorageLayout(layoutBefore);
    const layoutForComparisonAfter = preformatStorageLayout(layoutAfter);
    const comparison = compareStorageArrays(layoutForComparisonBefore, layoutForComparisonAfter);
    const md = generateMarkdownOutput(comparison);
    return md;
  }
  function preformatStorageLayout(json) {
    return json.storage.map((item) => ({
      label: item.label,
      offset: item.offset,
      slot: item.slot,
      type: json.types[item.type].label,
      numberOfBytes: json.types[item.type].numberOfBytes
    }));
  }
  function compareStorageArrays(oldArray, newArray) {
    const changes = [];
    const oldMap = new Map(oldArray.map((item) => [item.slot + "-" + item.offset, item]));
    const newMap = new Map(newArray.map((item) => [item.slot + "-" + item.offset, item]));
    oldArray.forEach((oldItem) => {
      const newItem = newMap.get(oldItem.slot + "-" + oldItem.offset);
      if (!newItem) {
        changes.push({ ...oldItem, status: "removed" });
      } else if (isDifferent(oldItem, newItem)) {
        changes.push({ ...oldItem, status: "removed" });
        changes.push({ ...newItem, status: "added" });
      } else {
        changes.push({ ...newItem, status: "unchanged" });
      }
    });
    newArray.forEach((newItem) => {
      if (!oldMap.has(newItem.slot + "-" + newItem.offset)) {
        changes.push({ ...newItem, status: "added" });
      }
    });
    changes.sort((a, b) => {
      if (a.slot === b.slot) {
        return a.offset - b.offset;
      }
      return a.slot.localeCompare(b.slot);
    });
    return changes;
  }
  function isDifferent(item1, item2) {
    return item1.offset !== item2.offset || item1.slot !== item2.slot || item1.type !== item2.type || item1.numberOfBytes !== item2.numberOfBytes;
  }
  function generateMarkdownOutput(items) {
    const columnWidths = {
      name: Math.max(...items.map((item) => item.label.length), "Label".length),
      offset: "Offset".length,
      slot: "Slot".length,
      type: Math.max(...items.map((item) => item.type.length), "Type".length),
      numberOfBytes: "Bytes".length
    };
    let markdownTable = "```diff\n";
    markdownTable += ` | ${"Label".padEnd(columnWidths.name, " ")} | ${"Offset".padEnd(columnWidths.offset, " ")} | ${"Slot".padEnd(columnWidths.slot, " ")} | ${"Type".padEnd(columnWidths.type, " ")} | ${"Bytes".padEnd(columnWidths.numberOfBytes, " ")} |
`;
    markdownTable += ` |${"-".repeat(columnWidths.name + 2)}|${"-".repeat(columnWidths.offset + 2)}|${"-".repeat(columnWidths.slot + 2)}|${"-".repeat(columnWidths.type + 2)}|${"-".repeat(columnWidths.numberOfBytes + 2)}||
`;
    items.forEach((item) => {
      const sign = item.status === "added" ? "+" : item.status === "removed" ? "-" : " ";
      const row = `${sign}| ${item.label.padEnd(columnWidths.name, " ")} | ${item.offset.toString().padEnd(columnWidths.offset, " ")} | ${item.slot.padEnd(columnWidths.slot, " ")} | ${item.type.padEnd(columnWidths.type, " ")} | ${item.numberOfBytes.padEnd(columnWidths.numberOfBytes, " ")} |
`;
      markdownTable += row;
    });
    markdownTable += "```";
    return markdownTable;
  }
  async function getContractDeploymentBlock({
    client,
    contractAddress,
    fromBlock,
    toBlock,
    maxDelta
  }) {
    if (fromBlock == toBlock)
      return fromBlock;
    if (fromBlock < toBlock) {
      const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
      const codeMid = await (0, import_actions.getBytecode)(client, {
        blockNumber: midBlock,
        address: contractAddress
      });
      if (!codeMid) {
        if (toBlock - midBlock > maxDelta) {
          return getContractDeploymentBlock({
            client,
            contractAddress,
            fromBlock: midBlock,
            toBlock,
            maxDelta
          });
        } else {
          return midBlock;
        }
      }
      return getContractDeploymentBlock({
        client,
        contractAddress,
        fromBlock,
        toBlock: midBlock,
        maxDelta
      });
    }
    throw new Error("Could not find contract deployment block");
  }
  async function getBlockAtTimestamp({
    client,
    timestamp,
    fromBlock,
    toBlock,
    maxDelta
  }) {
    if (fromBlock <= toBlock) {
      const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
      const block = await (0, import_actions.getBlock)(client, { blockNumber: midBlock });
      if (block.timestamp > timestamp) {
        return getBlockAtTimestamp({
          client,
          timestamp,
          fromBlock,
          toBlock: midBlock,
          maxDelta
        });
      } else {
        if (timestamp - block.timestamp < maxDelta) {
          return block;
        } else {
          return getBlockAtTimestamp({
            client,
            timestamp,
            fromBlock: midBlock,
            toBlock,
            maxDelta
          });
        }
      }
    }
    throw new Error("Could not find matching block");
  }
  async function strategicGetLogs({
    client,
    events,
    address,
    fromBlock,
    toBlock
  }) {
    if (client.transport.key === "http") {
      const url = client.transport.url;
      let batchSize = 0;
      if (/llamarpc/.test(url))
        batchSize = 1e5;
      if (/quiknode/.test(url))
        batchSize = 1e4;
      if (/alchemy/.test(url)) {
        getLogsRecursive({ client, events, address, fromBlock, toBlock });
      }
      if (batchSize > 0) {
        return getLogsInBatches({
          client,
          events,
          address,
          fromBlock,
          toBlock,
          batchSize
        });
      }
    }
    return getLogsRecursive({ client, events, address, fromBlock, toBlock });
  }
  async function getLogsRecursive({
    client,
    events,
    address,
    fromBlock,
    toBlock
  }) {
    console.log("recursions", fromBlock, toBlock);
    if (fromBlock <= toBlock) {
      try {
        const logs = await (0, import_actions.getLogs)(client, {
          fromBlock,
          toBlock,
          events,
          address
        });
        return logs;
      } catch (error) {
        const rangeMatch = error.details?.match(/.*\[(.*),\s*(.*)\]/);
        if (rangeMatch?.length === 3) {
          const maxBlock = (0, import_viem.fromHex)(rangeMatch[2], "bigint");
          const arr1 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock,
            toBlock: maxBlock
          });
          const midBlock = BigInt(maxBlock + toBlock) >> BigInt(1);
          const arr2 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock: maxBlock + BigInt(1),
            toBlock: midBlock
          });
          const arr3 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock: midBlock + BigInt(1),
            toBlock
          });
          return [...arr1, ...arr2, ...arr3];
        } else {
          const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
          const arr1 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock,
            toBlock: midBlock
          });
          const arr2 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock: midBlock + BigInt(1),
            toBlock
          });
          return [...arr1, ...arr2];
        }
      }
    }
    return [];
  }
  async function getLogsInBatches({
    client,
    events,
    address,
    fromBlock,
    toBlock,
    batchSize
  }) {
    const batches = [];
    for (let i = Number(fromBlock);i < Number(toBlock); i = i + batchSize) {
      batches.push({
        from: BigInt(i),
        to: BigInt(i + batchSize - 1) > toBlock ? toBlock : BigInt(i + batchSize - 1)
      });
    }
    const { results, errors } = await import_promise_pool.PromisePool.for(batches).withConcurrency(5).useCorrespondingResults().process(async ({ from, to }) => {
      return (0, import_actions.getLogs)(client, {
        fromBlock: from,
        toBlock: to,
        events,
        address
      });
    });
    if (errors.length != 0) {
      console.log(errors);
      throw new Error("Error fetching logs");
    }
    return results.flat();
  }
  function baseToCidv0(hash2) {
    return import_bs58.default.encode(Buffer.from(`1220${hash2.slice(2)}`, "hex"));
  }
  async function uploadToPinata(source) {
    const PINATA_KEY = process.env.PINATA_KEY;
    if (!PINATA_KEY)
      throw new Error("PINATA_KEY env must be set");
    const PINATA_SECRET = process.env.PINATA_SECRET;
    if (!PINATA_SECRET)
      throw new Error("PINATA_SECRET env must be set");
    const data = new FormData;
    data.append("file", new Blob([source]));
    const res = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
      method: "POST",
      body: data,
      headers: {
        pinata_api_key: PINATA_KEY,
        pinata_secret_api_key: PINATA_SECRET
      }
    });
    if (!res.ok) {
      throw Error(await res.text());
    }
    const result = await res.json();
    if (result.error)
      throw { message: result.error };
    return result;
  }
  async function uploadToTheGraph(source) {
    const data = new FormData;
    data.append("file", new Blob([source]));
    const res = await fetch("https://api.thegraph.com/ipfs/api/v0/add", {
      method: "POST",
      body: data
    });
    return res.json();
  }
  async function uploadToQuicknode(source, key) {
    const apiKey = process.env.QUICKNODE_API_KEY;
    const headers = new Headers;
    headers.append("x-api-key", apiKey);
    const data = new FormData;
    data.append("Body", new Blob([source]));
    data.append("Key", key || "unknownKey");
    data.append("ContentType", "text/plain");
    const res = await fetch("https://api.quicknode.com/ipfs/rest/v1/s3/put-object", {
      method: "POST",
      headers,
      body: data,
      redirect: "follow"
    });
    return res.text();
  }
  function getLink(hash2, gateway) {
    return `${gateway}/${hash2}`;
  }
  async function getProposalMetadata(hash2, gateway = "https://cloudflare-ipfs.com/ipfs") {
    const ipfsHash = hash2.startsWith("0x") ? baseToCidv0(hash2) : hash2;
    const ipfsPath = getLink(ipfsHash, gateway);
    const ipfsResponse = await fetch(ipfsPath, {
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (!ipfsResponse.ok)
      throw Error(`IPFS: error fetching ${ipfsPath}`);
    const clone = ipfsResponse.clone();
    try {
      const response = await ipfsResponse.json();
      const { content, data } = (0, import_gray_matter.default)(response.description);
      return {
        ...response,
        ipfsHash,
        description: content,
        ...data
      };
    } catch (e) {
      const { content, data } = (0, import_gray_matter.default)(await clone.text());
      return {
        ...ipfsResponse,
        ipfsHash,
        description: content,
        ...data
      };
    }
  }
  function getSolidityStorageSlotBytes(mappingSlot, key) {
    const slot = (0, import_viem3.pad)(mappingSlot, { size: 32 });
    return (0, import_viem3.trim)((0, import_viem3.keccak256)((0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("bytes32, uint256"), [
      key,
      BigInt(slot)
    ])));
  }
  function getSolidityStorageSlotUint(mappingSlot, key) {
    return (0, import_viem3.keccak256)((0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("uint256, uint256"), [
      key,
      mappingSlot
    ]));
  }
  function getSolidityStorageSlotAddress(mappingSlot, key) {
    return (0, import_viem3.keccak256)((0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("address, uint256"), [
      key,
      BigInt(mappingSlot)
    ]));
  }
  function getDynamicArraySlot(baseSlot, arrayIndex, itemSize) {
    return (0, import_viem3.pad)((0, import_viem3.toHex)((0, import_viem3.fromHex)((0, import_viem3.keccak256)((0, import_viem3.encodeAbiParameters)((0, import_viem3.parseAbiParameters)("uint256"), [baseSlot])), "bigint") + BigInt(arrayIndex * itemSize)), { size: 32 });
  }
  function getBytesValue(value) {
    const bytesString = (0, import_viem3.toBytes)(value);
    if (bytesString.length > 31)
      throw new Error("Error: strings > 31 bytes are not implemented");
    return (0, import_viem3.concat)([
      (0, import_viem3.toHex)((0, import_viem3.pad)(bytesString, { size: 31, dir: "right" })),
      (0, import_viem3.toHex)(bytesString.length * 2, { size: 1 })
    ]);
  }
  function getBits(_bigIntValue, startBit, _endBit) {
    let endBit = _endBit;
    const bigIntValue = BigInt(_bigIntValue);
    if (startBit > endBit) {
      throw new Error("Invalid bit range: startBit must be less than or equal to endBit");
    }
    const bitLength = BigInt(bigIntValue.toString(2)).toString().length;
    if (endBit >= bitLength) {
      endBit = BigInt(bitLength - 1);
    }
    const mask = (1n << endBit - startBit + 1n) - 1n;
    const maskedValue = bigIntValue >> startBit & mask;
    return maskedValue.toString();
  }
  function setBits(_bigIntBase, startBit, endBit, _replaceValue) {
    const bigIntBase = BigInt(_bigIntBase);
    const bigIntReplaceValue = BigInt(_replaceValue);
    let mask = BigInt(0);
    for (let i = startBit;i < endBit; i++) {
      mask |= BigInt(1) << BigInt(i);
    }
    const clearedNumber = bigIntBase & ~mask;
    const result = clearedNumber | bigIntReplaceValue << BigInt(startBit);
    return result;
  }
  function decodeReserveConfigV2(data) {
    const ltv = getBits(data, 0n, 15n);
    const liquidationThreshold = getBits(data, 16n, 31n);
    const liquidationBonus = getBits(data, 32n, 47n);
    const decimals = getBits(data, 48n, 55n);
    const active = Number(getBits(data, 56n, 56n));
    const frozen = Number(getBits(data, 57n, 57n));
    const borrowingEnabled = Number(getBits(data, 58n, 58n));
    const stableBorrowingEnabled = Number(getBits(data, 59n, 59n));
    const reserveFactor = getBits(data, 64n, 79n);
    return {
      ltv,
      liquidationThreshold,
      liquidationBonus,
      decimals,
      active: !!active,
      frozen: !!frozen,
      borrowingEnabled: !!borrowingEnabled,
      stableBorrowingEnabled: !!stableBorrowingEnabled,
      reserveFactor
    };
  }
  function decodeReserveConfigV3(data) {
    const ltv = getBits(data, 0n, 15n);
    const liquidationThreshold = getBits(data, 16n, 31n);
    const liquidationBonus = getBits(data, 32n, 47n);
    const decimals = getBits(data, 48n, 55n);
    const active = Number(getBits(data, 56n, 56n));
    const frozen = Number(getBits(data, 57n, 57n));
    const borrowingEnabled = Number(getBits(data, 58n, 58n));
    const stableRateBorrowingEnabled = Number(getBits(data, 59n, 59n));
    const paused = Number(getBits(data, 60n, 60n));
    const borrowingInIsolation = Number(getBits(data, 61n, 61n));
    const siloedBorrowingEnabled = Number(getBits(data, 62n, 62n));
    const flashloaningEnabled = Number(getBits(data, 63n, 63n));
    const reserveFactor = getBits(data, 64n, 79n);
    const borrowCap = getBits(data, 80n, 115n);
    const supplyCap = getBits(data, 116n, 151n);
    const liquidationProtocolFee = getBits(data, 152n, 167n);
    const eModeCategory = getBits(data, 168n, 175n);
    const unbackedMintCap = getBits(data, 176n, 211n);
    const debtCeiling = getBits(data, 212n, 251n);
    return {
      ltv,
      liquidationThreshold,
      liquidationBonus,
      decimals,
      active: !!active,
      frozen: !!frozen,
      borrowingEnabled: !!borrowingEnabled,
      stableRateBorrowingEnabled: !!stableRateBorrowingEnabled,
      paused: !!paused,
      borrowingInIsolation: !!borrowingInIsolation,
      reserveFactor,
      borrowCap,
      supplyCap,
      liquidationProtocolFee,
      eModeCategory,
      unbackedMintCap,
      debtCeiling,
      siloedBorrowingEnabled: !!siloedBorrowingEnabled,
      flashloaningEnabled: !!flashloaningEnabled
    };
  }
  function readJSONCache(filePath, filename) {
    const joinedPath = import_path.default.join(DEFAULT_PATH, filePath, `${filename}.json`);
    if ((0, import_fs.existsSync)(joinedPath)) {
      return JSON.parse((0, import_fs.readFileSync)(joinedPath, "utf8"));
    }
  }
  function writeJSONCache(filePath, filename, json) {
    const joinedFolderPath = import_path.default.join(DEFAULT_PATH, filePath);
    if (!(0, import_fs.existsSync)(joinedFolderPath)) {
      (0, import_fs.mkdirSync)(joinedFolderPath, { recursive: true });
    }
    const joinedFilePath = import_path.default.join(joinedFolderPath, `${filename}.json`);
    (0, import_fs.writeFileSync)(joinedFilePath, JSON.stringify(json, (key, value) => typeof value === "bigint" ? value.toString() : value === undefined ? null : value, 2));
  }
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var node_exports = {};
  __export2(node_exports, {
    CHAIN_ID_CLIENT_MAP: () => CHAIN_ID_CLIENT_MAP,
    ChainId: () => ChainId,
    arbitrumClient: () => arbitrumClient,
    arbitrumGoerliClient: () => arbitrumGoerliClient,
    arbitrumSepoliaClient: () => arbitrumSepoliaClient,
    avalancheClient: () => avalancheClient,
    baseClient: () => baseClient,
    baseSepoliaClient: () => baseSepoliaClient,
    baseToCidv0: () => baseToCidv0,
    bnbClient: () => bnbClient,
    celoClient: () => celoClient,
    compareStorageLayouts: () => compareStorageLayouts,
    decodeReserveConfigV2: () => decodeReserveConfigV2,
    decodeReserveConfigV3: () => decodeReserveConfigV3,
    fantomClient: () => fantomClient,
    fantomTestnetClient: () => fantomTestnetClient,
    fujiClient: () => fujiClient,
    getBits: () => getBits,
    getBlockAtTimestamp: () => getBlockAtTimestamp,
    getBytesValue: () => getBytesValue,
    getContractDeploymentBlock: () => getContractDeploymentBlock,
    getDynamicArraySlot: () => getDynamicArraySlot,
    getLink: () => getLink,
    getLogsRecursive: () => getLogsRecursive,
    getProposalMetadata: () => getProposalMetadata,
    getSolidityStorageSlotAddress: () => getSolidityStorageSlotAddress,
    getSolidityStorageSlotBytes: () => getSolidityStorageSlotBytes,
    getSolidityStorageSlotUint: () => getSolidityStorageSlotUint,
    gnosisClient: () => gnosisClient,
    goerliClient: () => goerliClient,
    harmonyClient: () => harmonyClient,
    mainnetClient: () => mainnetClient,
    metisClient: () => metisClient,
    mumbaiClient: () => mumbaiClient,
    optimismClient: () => optimismClient,
    optimismGoerliClient: () => optimismGoerliClient,
    optimismSepoliaClient: () => optimismSepoliaClient,
    polygonClient: () => polygonClient,
    readJSONCache: () => readJSONCache,
    scrollClient: () => scrollClient,
    scrollSepoliaClient: () => scrollSepoliaClient,
    sepoliaClient: () => sepoliaClient,
    setBits: () => setBits,
    strategicGetLogs: () => strategicGetLogs,
    uploadToPinata: () => uploadToPinata,
    uploadToQuicknode: () => uploadToQuicknode,
    uploadToTheGraph: () => uploadToTheGraph,
    writeJSONCache: () => writeJSONCache,
    zkEVMClient: () => zkEVMClient,
    zkSyncClient: () => zkSyncClient
  });
  module.exports = __toCommonJS(node_exports);
  var import_chains = require_chains();
  var ChainId = {
    mainnet: import_chains.mainnet.id,
    goerli: import_chains.goerli.id,
    polygon: import_chains.polygon.id,
    mumbai: import_chains.polygonMumbai.id,
    avalanche: import_chains.avalanche.id,
    fuji: import_chains.avalancheFuji.id,
    arbitrum_one: import_chains.arbitrum.id,
    arbitrum_goerli: import_chains.arbitrumGoerli.id,
    arbitrum_sepolia: import_chains.arbitrumSepolia.id,
    fantom: import_chains.fantom.id,
    fantom_testnet: import_chains.fantomTestnet.id,
    optimism: import_chains.optimism.id,
    optimism_sepolia: import_chains.optimismSepolia.id,
    optimism_goerli: import_chains.optimismGoerli.id,
    harmony: import_chains.harmonyOne.id,
    sepolia: import_chains.sepolia.id,
    scroll: import_chains.scroll.id,
    scroll_sepolia: import_chains.scrollSepolia.id,
    metis: import_chains.metis.id,
    base: import_chains.base.id,
    base_sepolia: import_chains.baseSepolia.id,
    bnb: import_chains.bsc.id,
    gnosis: import_chains.gnosis.id,
    zkEVM: import_chains.polygonZkEvm.id,
    celo: import_chains.celo.id,
    zkSync: import_chains.zkSync.id
  };
  var import_viem = require__cjs2();
  var import_promise_pool = require_dist();
  var import_actions = require_actions();
  var import_viem2 = require__cjs2();
  var import_chains2 = require_chains();
  var commonConfig = { timeout: 30000 };
  var mainnetClient = (0, import_viem2.createClient)({
    chain: import_chains2.mainnet,
    transport: (0, import_viem2.http)(process.env.RPC_MAINNET, commonConfig)
  });
  var arbitrumClient = (0, import_viem2.createClient)({
    chain: import_chains2.arbitrum,
    transport: (0, import_viem2.http)(process.env.RPC_ARBITRUM, commonConfig)
  });
  var polygonClient = (0, import_viem2.createClient)({
    chain: import_chains2.polygon,
    transport: (0, import_viem2.http)(process.env.RPC_POLYGON, commonConfig)
  });
  var optimismClient = (0, import_viem2.createClient)({
    chain: import_chains2.optimism,
    transport: (0, import_viem2.http)(process.env.RPC_OPTIMISM, commonConfig)
  });
  var metisClient = (0, import_viem2.createClient)({
    chain: import_chains2.metis,
    transport: (0, import_viem2.http)(process.env.RPC_METIS, commonConfig)
  });
  var baseClient = (0, import_viem2.createClient)({
    chain: import_chains2.base,
    transport: (0, import_viem2.http)(process.env.RPC_BASE, commonConfig)
  });
  var fantomClient = (0, import_viem2.createClient)({
    chain: import_chains2.fantom,
    transport: (0, import_viem2.http)(process.env.RPC_FANTOM, commonConfig)
  });
  var bnbClient = (0, import_viem2.createClient)({
    chain: import_chains2.bsc,
    transport: (0, import_viem2.http)(process.env.RPC_BNB, commonConfig)
  });
  var avalancheClient = (0, import_viem2.createClient)({
    chain: import_chains2.avalanche,
    transport: (0, import_viem2.http)(process.env.RPC_AVALANCHE, commonConfig)
  });
  var gnosisClient = (0, import_viem2.createClient)({
    chain: import_chains2.gnosis,
    transport: (0, import_viem2.http)(process.env.RPC_GNOSIS, commonConfig)
  });
  var scrollClient = (0, import_viem2.createClient)({
    chain: import_chains2.scroll,
    transport: (0, import_viem2.http)(process.env.RPC_SCROLL, commonConfig)
  });
  var zkEVMClient = (0, import_viem2.createClient)({
    chain: import_chains2.polygonZkEvm,
    transport: (0, import_viem2.http)(process.env.RPC_ZKEVM, commonConfig)
  });
  var celoClient = (0, import_viem2.createClient)({
    chain: import_chains2.celo,
    transport: (0, import_viem2.http)(process.env.RPC_CELO, commonConfig)
  });
  var zkSyncClient = (0, import_viem2.createClient)({
    chain: import_chains2.zkSync,
    transport: (0, import_viem2.http)(process.env.RPC_ZKSYNC, commonConfig)
  });
  var harmonyClient = (0, import_viem2.createClient)({
    chain: import_chains2.harmonyOne,
    transport: (0, import_viem2.http)(process.env.RPC_HARMONY, commonConfig)
  });
  var fujiClient = (0, import_viem2.createClient)({
    chain: import_chains2.avalancheFuji,
    transport: (0, import_viem2.http)(process.env.RPC_FUJI, commonConfig)
  });
  var mumbaiClient = (0, import_viem2.createClient)({
    chain: import_chains2.polygonMumbai,
    transport: (0, import_viem2.http)(process.env.RPC_MUMBAI, commonConfig)
  });
  var sepoliaClient = (0, import_viem2.createClient)({
    chain: import_chains2.sepolia,
    transport: (0, import_viem2.http)(process.env.RPC_SEPOLIA, commonConfig)
  });
  var goerliClient = (0, import_viem2.createClient)({
    chain: import_chains2.goerli,
    transport: (0, import_viem2.http)(process.env.RPC_GOERLI, commonConfig)
  });
  var arbitrumGoerliClient = (0, import_viem2.createClient)({
    chain: import_chains2.arbitrumGoerli,
    transport: (0, import_viem2.http)(process.env.RPC_ARBITRUM_GOERLI, commonConfig)
  });
  var arbitrumSepoliaClient = (0, import_viem2.createClient)({
    chain: import_chains2.arbitrumSepolia,
    transport: (0, import_viem2.http)(process.env.RPC_ARBITRUM_SEPOLIA, commonConfig)
  });
  var optimismGoerliClient = (0, import_viem2.createClient)({
    chain: import_chains2.optimismGoerli,
    transport: (0, import_viem2.http)(process.env.RPC_OPTIMISM_GOERLI, commonConfig)
  });
  var optimismSepoliaClient = (0, import_viem2.createClient)({
    chain: import_chains2.optimismSepolia,
    transport: (0, import_viem2.http)(process.env.RPC_OPTIMISM_SEPOLIA, commonConfig)
  });
  var scrollSepoliaClient = (0, import_viem2.createClient)({
    chain: import_chains2.scrollSepolia,
    transport: (0, import_viem2.http)(process.env.RPC_SCROLL_SEPOLIA, commonConfig)
  });
  var fantomTestnetClient = (0, import_viem2.createClient)({
    chain: import_chains2.fantomTestnet,
    transport: (0, import_viem2.http)(process.env.RPC_FANTOM_TESTNET, commonConfig)
  });
  var baseSepoliaClient = (0, import_viem2.createClient)({
    chain: import_chains2.baseSepolia,
    transport: (0, import_viem2.http)(process.env.RPC_BASE_SEPOLIA, commonConfig)
  });
  var CHAIN_ID_CLIENT_MAP = {
    [ChainId.mainnet]: mainnetClient,
    [ChainId.arbitrum_one]: arbitrumClient,
    [ChainId.arbitrum_goerli]: arbitrumGoerliClient,
    [ChainId.arbitrum_sepolia]: arbitrumSepoliaClient,
    [ChainId.polygon]: polygonClient,
    [ChainId.optimism]: optimismClient,
    [ChainId.optimism_goerli]: optimismGoerliClient,
    [ChainId.optimism_sepolia]: optimismSepoliaClient,
    [ChainId.metis]: metisClient,
    [ChainId.base]: baseClient,
    [ChainId.base_sepolia]: baseSepoliaClient,
    [ChainId.sepolia]: sepoliaClient,
    [ChainId.goerli]: goerliClient,
    [ChainId.fantom]: fantomClient,
    [ChainId.fantom_testnet]: fantomTestnetClient,
    [ChainId.bnb]: bnbClient,
    [ChainId.avalanche]: avalancheClient,
    [ChainId.gnosis]: gnosisClient,
    [ChainId.scroll]: scrollClient,
    [ChainId.scroll_sepolia]: scrollSepoliaClient,
    [ChainId.zkEVM]: zkEVMClient,
    [ChainId.celo]: celoClient,
    [ChainId.zkSync]: zkSyncClient,
    [ChainId.fuji]: fujiClient,
    [ChainId.mumbai]: mumbaiClient,
    [ChainId.harmony]: harmonyClient
  };
  var import_bs58 = __toESM2(require_bs58(), 1);
  var import_gray_matter = __toESM2(require_gray_matter(), 1);
  var import_viem3 = require__cjs2();
  var import_fs = __require("fs");
  var import_path = __toESM2(__require("path"), 1);
  var DEFAULT_PATH = import_path.default.join(process.cwd(), "cache");
});

// node_modules/viem/_esm/utils/getAction.js
function getAction(client, action, name) {
  return (params) => client[action.name]?.(params) ?? client[name]?.(params) ?? action(client, params);
}

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_abi();

// node_modules/viem/_esm/errors/log.js
init_base();

class FilterTypeNotSupportedError extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
}

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_toBytes();
init_keccak256();
init_toEventSelector();
init_encodeAbiParameters();
init_formatAbiItem2();
init_getAbiItem();
function encodeEventTopics(parameters) {
  const { abi, eventName, args } = parameters;
  let abiItem = abi[0];
  if (eventName) {
    const item = getAbiItem({ abi, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(undefined, { docsPath });
  const definition = formatAbiItem2(abiItem);
  const signature = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => ("indexed" in param) && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}
var docsPath = "/docs/contract/encodeEventTopics";

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
init_toHex();

// node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : undefined;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    type: "event"
  };
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
init_encodeFunctionData();

// node_modules/viem/_esm/utils/errors/getContractError.js
init_abi();
init_base();
init_contract();
init_rpc();
function getContractError(err, { abi, address, args, docsPath: docsPath3, functionName, sender }) {
  const { code, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => ("data" in err2)) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}
var EXECUTION_REVERTED_ERROR_CODE = 3;

// node_modules/viem/_esm/actions/public/estimateGas.js
init_toHex();

// node_modules/viem/_esm/errors/estimateGas.js
init_formatEther();
init_formatGwei();
init_base();
init_transaction();

class EstimateGasExecutionError extends BaseError {
  constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath3,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
}

// node_modules/viem/_esm/utils/errors/getEstimateGasError.js
init_node();
init_getNodeError();
function getEstimateGasError(err, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// node_modules/viem/_esm/actions/public/estimateGas.js
init_transactionRequest();
init_assertRequest();
// node_modules/viem/_esm/errors/fee.js
init_formatGwei();
init_base();

class BaseFeeScalarError extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
}

class Eip1559FeesNotSupportedError extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}

class MaxFeePerGasTooLowError extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
init_fromHex();

// node_modules/viem/_esm/errors/block.js
init_base();

class BlockNotFoundError extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
}

// node_modules/viem/_esm/actions/public/getBlock.js
init_toHex();

// node_modules/viem/_esm/utils/formatters/transaction.js
init_fromHex();
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,
    gas: transaction.gas ? BigInt(transaction.gas) : undefined,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : undefined,
    typeHex: transaction.type ? transaction.type : undefined,
    value: transaction.value ? BigInt(transaction.value) : undefined,
    v: transaction.v ? BigInt(transaction.v) : undefined
  };
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};

// node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = block.transactions?.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : undefined,
    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}

// node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}

// node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const { block: block_, chain = client.chain, request } = args || {};
  if (typeof chain?.fees?.defaultPriorityFee === "function") {
    const block = block_ || await getAction(client, getBlock, "getBlock")({});
    return chain.fees.defaultPriorityFee({
      block,
      client,
      request
    });
  }
  if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
    return chain?.fees?.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function internal_estimateFeesPerGas(client, args) {
  const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError;
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// node_modules/viem/_esm/actions/public/getTransactionCount.js
init_fromHex();
init_toHex();
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber(count);
}

// node_modules/viem/_esm/errors/account.js
init_base();

class AccountNotFoundError extends BaseError {
  constructor({ docsPath: docsPath3 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join("\n"), {
      docsPath: docsPath3,
      docsSlug: "account"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountNotFoundError"
    });
  }
}

// node_modules/viem/_esm/utils/blob/blobsToCommitments.js
init_toBytes();
init_toHex();
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x) => bytesToHex(x));
}

// node_modules/viem/_esm/utils/blob/blobsToProofs.js
init_toBytes();
init_toHex();
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0;i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x) => bytesToHex(x));
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
init_toHex();

// node_modules/viem/_esm/utils/hash/sha256.js
init_sha256();
init_toBytes();
init_toHex();
function sha2562(value, to_) {
  const to = to_ || "hex";
  const bytes2 = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes2;
  return toHex(bytes2);
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version2 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2562(commitment, "bytes");
  versionedHash.set([version2], 0);
  return to === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version2 } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version2
    }));
  }
  return hashes;
}

// node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - 1 - 1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/viem/_esm/errors/blob.js
init_base();

class BlobSizeTooLargeError extends BaseError {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlobSizeTooLargeError"
    });
  }
}

class EmptyBlobError extends BaseError {
  constructor() {
    super("Blob data must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EmptyBlobError"
    });
  }
}

// node_modules/viem/_esm/utils/blob/toBlobs.js
init_cursor2();
init_size();
init_toBytes();
init_toHex();
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError;
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes2 = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes2);
      if (bytes2.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));
}

// node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i = 0;i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_assertRequest();

// node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_transaction();
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/viem/_esm/actions/public/getChainId.js
init_fromHex();
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  });
  return hexToNumber(chainIdHex);
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, blobs, chain, chainId, gas, kzg, nonce, parameters = defaultParameters, type } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  const request = { ...args, ...account ? { from: account?.address } : {} };
  let block;
  async function getBlock2() {
    if (block)
      return block;
    block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId")) {
    if (chain)
      request.chainId = chain.id;
    else if (typeof chainId !== "undefined")
      request.chainId = chainId;
    else
      request.chainId = await getAction(client, getChainId, "getChainId")({});
  }
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account)
    request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
      address: account.address,
      blockTag: "pending"
    });
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      const block2 = await getBlock2();
      request.type = typeof block2?.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type === "eip1559" || request.type === "eip4844") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock2();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError;
      const block2 = await getBlock2();
      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
        block: block2,
        chain,
        request,
        type: "legacy"
      });
      request.gasPrice = gasPrice_;
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : undefined
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}
var defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];

// node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  const account_ = args.account ?? client.account;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    const { accessList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = await prepareTransactionRequest(client, {
      ...args,
      parameters: account?.type === "local" ? undefined : ["blobVersionedHashes"]
    });
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client.request({
      method: "eth_estimateGas",
      params: block ? [request, block] : [request]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : undefined;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
init_getAbiItem();

// node_modules/viem/_esm/utils/abi/decodeEventLog.js
init_abi();
init_size();
init_toEventSelector();
init_cursor();
init_decodeAbiParameters();
init_formatAbiItem2();
function decodeEventLog(parameters) {
  const { abi, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath3 });
  const abiItem = abi.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem2(x)));
  if (!(abiItem && ("name" in abiItem)) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath3 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !(("name" in x) && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => ("indexed" in x) && x.indexed);
  for (let i = 0;i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !(("indexed" in x) && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0;i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : undefined
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}
var docsPath3 = "/docs/contract/decodeEventLog";

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs({ abi, eventName, logs, strict = true }) {
  return logs.map((log) => {
    try {
      const event = decodeEventLog({
        ...log,
        abi,
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      return { ...event, ...log };
    } catch (err) {
      let eventName2;
      let isUnnamed;
      if (err instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}

// node_modules/viem/_esm/actions/public/getLogs.js
init_toHex();

// node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : undefined);
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi, name: eventName }) : undefined;
  const events = !event ? abi.filter((x) => x.type === "event") : undefined;
  return getAction(client, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}

// node_modules/viem/_esm/actions/public/readContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function readContract(client, parameters) {
  const { abi, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// node_modules/viem/_esm/actions/public/simulateContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function simulateContract(client, parameters) {
  const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi, args, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi.filter((abiItem) => ("name" in abiItem) && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
init_abi();
init_rpc();

// node_modules/viem/_esm/utils/observe.js
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key]?.(...args);
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
var listenersCache = /* @__PURE__ */ new Map;
var cleanupCache = /* @__PURE__ */ new Map;
var callbackCount = 0;

// node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = undefined;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}
// node_modules/viem/_esm/utils/promise/withCache.js
function getCache(cacheKey) {
  const buildCache = (cacheKey2, cache) => ({
    clear: () => cache.delete(cacheKey2),
    get: () => cache.get(cacheKey2),
    set: (data) => cache.set(cacheKey2, data)
  });
  const promise = buildCache(cacheKey, promiseCache);
  const response = buildCache(cacheKey, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey, cacheTime = Infinity }) {
  const cache = getCache(cacheKey);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date, data });
    return data;
  } finally {
    cache.promise.clear();
  }
}
var promiseCache = /* @__PURE__ */ new Map;
var responseCache = /* @__PURE__ */ new Map;

// node_modules/viem/_esm/actions/public/getBlockNumber.js
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}
var cacheKey = (id) => `blockNumber.${id}`;

// node_modules/viem/_esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter) || !filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket" || typeof fromBlock === "number";
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== undefined)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      (async () => {
        try {
          const topics = eventName ? encodeEventTopics({
            abi,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (err) {
                let eventName2;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// node_modules/viem/_esm/actions/wallet/writeContract.js
init_encodeFunctionData();
// node_modules/viem/_esm/utils/chain/assertCurrentChain.js
init_chain();
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError;
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}

// node_modules/viem/_esm/utils/errors/getTransactionError.js
init_node();
init_transaction();
init_getNodeError();
function getTransactionError(err, { docsPath: docsPath5, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath5,
    ...args
  });
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_transactionRequest();
init_assertRequest();

// node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
async function sendTransaction(client, parameters) {
  const { account: account_ = client.account, chain = client.chain, accessList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = parseAccount(account_);
  try {
    assertRequest(parameters);
    let chainId;
    if (chain !== null) {
      chainId = await getAction(client, getChainId, "getChainId")({});
      assertCurrentChain({
        currentChainId: chainId,
        chain
      });
    }
    if (account.type === "local") {
      const request2 = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
        account,
        accessList,
        blobs,
        chain,
        chainId,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        parameters: [...defaultParameters, "sidecars"],
        to,
        value,
        ...rest
      });
      const serializer = chain?.serializers?.transaction;
      const serializedTransaction = await account.signTransaction(request2, {
        serializer
      });
      return await getAction(client, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      accessList,
      blobs,
      data,
      from: account.address,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client.request({
      method: "eth_sendTransaction",
      params: [request]
    }, { retryCount: 0 });
  } catch (err) {
    throw getTransactionError(err, {
      ...parameters,
      account,
      chain: parameters.chain || undefined
    });
  }
}

// node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, parameters) {
  const { abi, address, args, dataSuffix, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  return getAction(client, sendTransaction, "sendTransaction")({
    data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address,
    ...request
  });
}

// node_modules/viem/_esm/actions/getContract.js
function getContract({ abi, address, client: client_ }) {
  const client = client_;
  const [publicClient, walletClient] = (() => {
    if (!client)
      return [undefined, undefined];
    if ("public" in client && "wallet" in client)
      return [client.public, client.wallet];
    if ("public" in client)
      return [client.public, undefined];
    if ("wallet" in client)
      return [undefined, client.wallet];
    return [client, client];
  })();
  const hasPublicClient = publicClient !== undefined && publicClient !== null;
  const hasWalletClient = walletClient !== undefined && walletClient !== null;
  const contract = {};
  let hasReadFunction = false;
  let hasWriteFunction = false;
  let hasEvent = false;
  for (const item of abi) {
    if (item.type === "function")
      if (item.stateMutability === "view" || item.stateMutability === "pure")
        hasReadFunction = true;
      else
        hasWriteFunction = true;
    else if (item.type === "event")
      hasEvent = true;
    if (hasReadFunction && hasWriteFunction && hasEvent)
      break;
  }
  if (hasPublicClient) {
    if (hasReadFunction)
      contract.read = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options: options2 } = getFunctionParameters(parameters);
            return getAction(publicClient, readContract, "readContract")({
              abi,
              address,
              functionName,
              args,
              ...options2
            });
          };
        }
      });
    if (hasWriteFunction)
      contract.simulate = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options: options2 } = getFunctionParameters(parameters);
            return getAction(publicClient, simulateContract, "simulateContract")({
              abi,
              address,
              functionName,
              args,
              ...options2
            });
          };
        }
      });
    if (hasEvent) {
      contract.createEventFilter = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options: options2 } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              eventName,
              args,
              ...options2
            });
          };
        }
      });
      contract.getEvents = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options: options2 } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, getContractEvents, "getContractEvents")({
              abi,
              address,
              eventName,
              args,
              ...options2
            });
          };
        }
      });
      contract.watchEvent = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options: options2 } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, watchContractEvent, "watchContractEvent")({
              abi,
              address,
              eventName,
              args,
              ...options2
            });
          };
        }
      });
    }
  }
  if (hasWalletClient) {
    if (hasWriteFunction)
      contract.write = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options: options2 } = getFunctionParameters(parameters);
            return getAction(walletClient, writeContract, "writeContract")({
              abi,
              address,
              functionName,
              args,
              ...options2
            });
          };
        }
      });
  }
  if (hasPublicClient || hasWalletClient) {
    if (hasWriteFunction)
      contract.estimateGas = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options: options2 } = getFunctionParameters(parameters);
            const client2 = publicClient ?? walletClient;
            return getAction(client2, estimateContractGas, "estimateContractGas")({
              abi,
              address,
              functionName,
              args,
              ...options2,
              account: options2.account ?? walletClient.account
            });
          };
        }
      });
  }
  contract.address = address;
  contract.abi = abi;
  return contract;
}
function getFunctionParameters(values) {
  const hasArgs = values.length && Array.isArray(values[0]);
  const args = hasArgs ? values[0] : [];
  const options2 = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options: options2 };
}
function getEventParameters(values, abiEvent) {
  let hasArgs = false;
  if (Array.isArray(values[0]))
    hasArgs = true;
  else if (values.length === 1) {
    hasArgs = abiEvent.inputs.some((x) => x.indexed);
  } else if (values.length === 2) {
    hasArgs = true;
  }
  const args = hasArgs ? values[0] : undefined;
  const options2 = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options: options2 };
}
// node_modules/viem/_esm/index.js
init_abi();
init_getAbiItem();
// src/common/payloadsController.ts
var import_js_utils = __toESM(require_node2(), 1);

// node_modules/@bgd-labs/aave-address-book/dist/abis/IPayloadsControllerCore.mjs
var IPayloadsControllerCore_ABI = [
  {
    type: "function",
    name: "EXPIRATION_DELAY",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "GRACE_PERIOD",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MAX_EXECUTION_DELAY",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MIN_EXECUTION_DELAY",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "cancelPayload",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "createPayload",
    inputs: [
      {
        name: "actions",
        type: "tuple[]",
        internalType: "struct IPayloadsControllerCore.ExecutionAction[]",
        components: [
          {
            name: "target",
            type: "address",
            internalType: "address"
          },
          {
            name: "withDelegateCall",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "accessLevel",
            type: "uint8",
            internalType: "enum PayloadsControllerUtils.AccessControl"
          },
          {
            name: "value",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "signature",
            type: "string",
            internalType: "string"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "executePayload",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "getExecutorSettingsByAccessControl",
    inputs: [
      {
        name: "accessControl",
        type: "uint8",
        internalType: "enum PayloadsControllerUtils.AccessControl"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct IPayloadsControllerCore.ExecutorConfig",
        components: [
          {
            name: "executor",
            type: "address",
            internalType: "address"
          },
          {
            name: "delay",
            type: "uint40",
            internalType: "uint40"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPayloadById",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct IPayloadsControllerCore.Payload",
        components: [
          {
            name: "creator",
            type: "address",
            internalType: "address"
          },
          {
            name: "maximumAccessLevelRequired",
            type: "uint8",
            internalType: "enum PayloadsControllerUtils.AccessControl"
          },
          {
            name: "state",
            type: "uint8",
            internalType: "enum IPayloadsControllerCore.PayloadState"
          },
          {
            name: "createdAt",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "queuedAt",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "executedAt",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "cancelledAt",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "expirationTime",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "delay",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "gracePeriod",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "actions",
            type: "tuple[]",
            internalType: "struct IPayloadsControllerCore.ExecutionAction[]",
            components: [
              {
                name: "target",
                type: "address",
                internalType: "address"
              },
              {
                name: "withDelegateCall",
                type: "bool",
                internalType: "bool"
              },
              {
                name: "accessLevel",
                type: "uint8",
                internalType: "enum PayloadsControllerUtils.AccessControl"
              },
              {
                name: "value",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "signature",
                type: "string",
                internalType: "string"
              },
              {
                name: "callData",
                type: "bytes",
                internalType: "bytes"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPayloadState",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint8",
        internalType: "enum IPayloadsControllerCore.PayloadState"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPayloadsCount",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint40",
        internalType: "uint40"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "updateExecutors",
    inputs: [
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct IPayloadsControllerCore.UpdateExecutorInput[]",
        components: [
          {
            name: "accessLevel",
            type: "uint8",
            internalType: "enum PayloadsControllerUtils.AccessControl"
          },
          {
            name: "executorConfig",
            type: "tuple",
            internalType: "struct IPayloadsControllerCore.ExecutorConfig",
            components: [
              {
                name: "executor",
                type: "address",
                internalType: "address"
              },
              {
                name: "delay",
                type: "uint40",
                internalType: "uint40"
              }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "ExecutorSet",
    inputs: [
      {
        name: "accessLevel",
        type: "uint8",
        indexed: true,
        internalType: "enum PayloadsControllerUtils.AccessControl"
      },
      {
        name: "executor",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "delay",
        type: "uint40",
        indexed: false,
        internalType: "uint40"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PayloadCancelled",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        indexed: false,
        internalType: "uint40"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PayloadCreated",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        indexed: true,
        internalType: "uint40"
      },
      {
        name: "creator",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "actions",
        type: "tuple[]",
        indexed: false,
        internalType: "struct IPayloadsControllerCore.ExecutionAction[]",
        components: [
          {
            name: "target",
            type: "address",
            internalType: "address"
          },
          {
            name: "withDelegateCall",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "accessLevel",
            type: "uint8",
            internalType: "enum PayloadsControllerUtils.AccessControl"
          },
          {
            name: "value",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "signature",
            type: "string",
            internalType: "string"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "maximumAccessLevelRequired",
        type: "uint8",
        indexed: true,
        internalType: "enum PayloadsControllerUtils.AccessControl"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PayloadExecuted",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        indexed: false,
        internalType: "uint40"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PayloadExecutionMessageReceived",
    inputs: [
      {
        name: "originSender",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "originChainId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "delivered",
        type: "bool",
        indexed: true,
        internalType: "bool"
      },
      {
        name: "message",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      },
      {
        name: "reason",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PayloadQueued",
    inputs: [
      {
        name: "payloadId",
        type: "uint40",
        indexed: false,
        internalType: "uint40"
      }
    ],
    anonymous: false
  }
];

// node_modules/@bgd-labs/aave-address-book/dist/abis/IGovernanceCore.mjs
var IGovernanceCore_ABI = [
  {
    type: "function",
    name: "ACHIEVABLE_VOTING_PARTICIPATION",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "CANCELLATION_FEE_COLLECTOR",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "COOLDOWN_PERIOD",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MIN_VOTING_DURATION",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "NAME",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string",
        internalType: "string"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "PRECISION_DIVIDER",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "PROPOSAL_EXPIRATION_TIME",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "VOTING_TOKENS_CAP",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "activateVoting",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "addVotingPortals",
    inputs: [
      {
        name: "votingPortals",
        type: "address[]",
        internalType: "address[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "cancelProposal",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "createProposal",
    inputs: [
      {
        name: "payloads",
        type: "tuple[]",
        internalType: "struct PayloadsControllerUtils.Payload[]",
        components: [
          {
            name: "chain",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "accessLevel",
            type: "uint8",
            internalType: "enum PayloadsControllerUtils.AccessControl"
          },
          {
            name: "payloadsController",
            type: "address",
            internalType: "address"
          },
          {
            name: "payloadId",
            type: "uint40",
            internalType: "uint40"
          }
        ]
      },
      {
        name: "votingPortal",
        type: "address",
        internalType: "address"
      },
      {
        name: "ipfsHash",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "executeProposal",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getCancellationFee",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPowerStrategy",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IGovernancePowerStrategy"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getProposal",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct IGovernanceCore.Proposal",
        components: [
          {
            name: "state",
            type: "uint8",
            internalType: "enum IGovernanceCore.State"
          },
          {
            name: "accessLevel",
            type: "uint8",
            internalType: "enum PayloadsControllerUtils.AccessControl"
          },
          {
            name: "creationTime",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "votingDuration",
            type: "uint24",
            internalType: "uint24"
          },
          {
            name: "votingActivationTime",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "queuingTime",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "cancelTimestamp",
            type: "uint40",
            internalType: "uint40"
          },
          {
            name: "creator",
            type: "address",
            internalType: "address"
          },
          {
            name: "votingPortal",
            type: "address",
            internalType: "address"
          },
          {
            name: "snapshotBlockHash",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "ipfsHash",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "forVotes",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "againstVotes",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "cancellationFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "payloads",
            type: "tuple[]",
            internalType: "struct PayloadsControllerUtils.Payload[]",
            components: [
              {
                name: "chain",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "accessLevel",
                type: "uint8",
                internalType: "enum PayloadsControllerUtils.AccessControl"
              },
              {
                name: "payloadsController",
                type: "address",
                internalType: "address"
              },
              {
                name: "payloadId",
                type: "uint40",
                internalType: "uint40"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getProposalState",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint8",
        internalType: "enum IGovernanceCore.State"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getProposalsCount",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRepresentativeByChain",
    inputs: [
      {
        name: "voter",
        type: "address",
        internalType: "address"
      },
      {
        name: "chainId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRepresentedVotersByChain",
    inputs: [
      {
        name: "representative",
        type: "address",
        internalType: "address"
      },
      {
        name: "chainId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address[]",
        internalType: "address[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVotingConfig",
    inputs: [
      {
        name: "accessLevel",
        type: "uint8",
        internalType: "enum PayloadsControllerUtils.AccessControl"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct IGovernanceCore.VotingConfig",
        components: [
          {
            name: "coolDownBeforeVotingStart",
            type: "uint24",
            internalType: "uint24"
          },
          {
            name: "votingDuration",
            type: "uint24",
            internalType: "uint24"
          },
          {
            name: "yesThreshold",
            type: "uint56",
            internalType: "uint56"
          },
          {
            name: "yesNoDifferential",
            type: "uint56",
            internalType: "uint56"
          },
          {
            name: "minPropositionPower",
            type: "uint56",
            internalType: "uint56"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVotingPortalsCount",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isVotingPortalApproved",
    inputs: [
      {
        name: "votingPortal",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "queueProposal",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "forVotes",
        type: "uint128",
        internalType: "uint128"
      },
      {
        name: "againstVotes",
        type: "uint128",
        internalType: "uint128"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "redeemCancellationFee",
    inputs: [
      {
        name: "proposalIds",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "removeVotingPortals",
    inputs: [
      {
        name: "votingPortals",
        type: "address[]",
        internalType: "address[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "rescueVotingPortal",
    inputs: [
      {
        name: "votingPortal",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setPowerStrategy",
    inputs: [
      {
        name: "newPowerStrategy",
        type: "address",
        internalType: "contract IGovernancePowerStrategy"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setVotingConfigs",
    inputs: [
      {
        name: "votingConfigs",
        type: "tuple[]",
        internalType: "struct IGovernanceCore.SetVotingConfigInput[]",
        components: [
          {
            name: "accessLevel",
            type: "uint8",
            internalType: "enum PayloadsControllerUtils.AccessControl"
          },
          {
            name: "coolDownBeforeVotingStart",
            type: "uint24",
            internalType: "uint24"
          },
          {
            name: "votingDuration",
            type: "uint24",
            internalType: "uint24"
          },
          {
            name: "yesThreshold",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "yesNoDifferential",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minPropositionPower",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateCancellationFee",
    inputs: [
      {
        name: "cancellationFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateRepresentativesForChain",
    inputs: [
      {
        name: "representatives",
        type: "tuple[]",
        internalType: "struct IGovernanceCore.RepresentativeInput[]",
        components: [
          {
            name: "representative",
            type: "address",
            internalType: "address"
          },
          {
            name: "chainId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "CancellationFeeRedeemed",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "to",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "cancellationFee",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "success",
        type: "bool",
        indexed: true,
        internalType: "bool"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "CancellationFeeUpdated",
    inputs: [
      {
        name: "cancellationFee",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PayloadSent",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "payloadId",
        type: "uint40",
        indexed: false,
        internalType: "uint40"
      },
      {
        name: "payloadsController",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "chainId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "payloadNumberOnProposal",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "numberOfPayloadsOnProposal",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PowerStrategyUpdated",
    inputs: [
      {
        name: "newPowerStrategy",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalCanceled",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalCreated",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "creator",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "accessLevel",
        type: "uint8",
        indexed: true,
        internalType: "enum PayloadsControllerUtils.AccessControl"
      },
      {
        name: "ipfsHash",
        type: "bytes32",
        indexed: false,
        internalType: "bytes32"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalExecuted",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalFailed",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "votesFor",
        type: "uint128",
        indexed: false,
        internalType: "uint128"
      },
      {
        name: "votesAgainst",
        type: "uint128",
        indexed: false,
        internalType: "uint128"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalQueued",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "votesFor",
        type: "uint128",
        indexed: false,
        internalType: "uint128"
      },
      {
        name: "votesAgainst",
        type: "uint128",
        indexed: false,
        internalType: "uint128"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RepresentativeUpdated",
    inputs: [
      {
        name: "voter",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "representative",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "chainId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VoteForwarded",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "voter",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "support",
        type: "bool",
        indexed: true,
        internalType: "bool"
      },
      {
        name: "votingAssetsWithSlot",
        type: "tuple[]",
        indexed: false,
        internalType: "struct IVotingMachineWithProofs.VotingAssetWithSlot[]",
        components: [
          {
            name: "underlyingAsset",
            type: "address",
            internalType: "address"
          },
          {
            name: "slot",
            type: "uint128",
            internalType: "uint128"
          }
        ]
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VotingActivated",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      },
      {
        name: "snapshotBlockHash",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "votingDuration",
        type: "uint24",
        indexed: false,
        internalType: "uint24"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VotingConfigUpdated",
    inputs: [
      {
        name: "accessLevel",
        type: "uint8",
        indexed: true,
        internalType: "enum PayloadsControllerUtils.AccessControl"
      },
      {
        name: "votingDuration",
        type: "uint24",
        indexed: false,
        internalType: "uint24"
      },
      {
        name: "coolDownBeforeVotingStart",
        type: "uint24",
        indexed: false,
        internalType: "uint24"
      },
      {
        name: "yesThreshold",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "yesNoDifferential",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "minPropositionPower",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VotingPortalUpdated",
    inputs: [
      {
        name: "votingPortal",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "approved",
        type: "bool",
        indexed: true,
        internalType: "bool"
      }
    ],
    anonymous: false
  }
];

// src/common/payloadsController.ts
async function getPayloadsControllerEvents({
  payloadsController,
  client,
  fromBlockNumber,
  toBlockNumber
}) {
  const logs = await import_js_utils.strategicGetLogs({
    client,
    events: [
      getAbiItem({ abi: IPayloadsControllerCore_ABI, name: "PayloadCreated" }),
      getAbiItem({ abi: IPayloadsControllerCore_ABI, name: "PayloadQueued" }),
      getAbiItem({ abi: IPayloadsControllerCore_ABI, name: "PayloadExecuted" })
    ],
    address: payloadsController,
    fromBlock: fromBlockNumber,
    toBlock: toBlockNumber
  });
  return await Promise.all(logs.map(async (l) => ({
    ...l,
    timestamp: Number((await getBlock(client, { blockNumber: l.blockNumber })).timestamp)
  })));
}
async function syncPayloadsControllerEvents({
  client,
  payloadsController,
  lastSeenBlock = 0n
}) {
  const currentBlock = await getBlockNumber(client);
  const contract = getContract({
    abi: IPayloadsControllerCore_ABI,
    client,
    address: payloadsController
  });
  const payloadsCount = await contract.read.getPayloadsCount();
  if (payloadsCount === 0) {
    return { lastSeenBlock: currentBlock, events: [] };
  }
  if (lastSeenBlock === 0n) {
    const firstPayload = await contract.read.getPayloadById([0]);
    const firstRelevantBlock = await import_js_utils.getBlockAtTimestamp({
      client,
      timestamp: BigInt(firstPayload.createdAt),
      fromBlock: BigInt(0),
      toBlock: currentBlock,
      maxDelta: BigInt(60 * 60 * 12)
    });
    lastSeenBlock = firstRelevantBlock.number;
  }
  return {
    lastSeenBlock: currentBlock,
    events: await getPayloadsControllerEvents({
      client,
      payloadsController,
      fromBlockNumber: lastSeenBlock,
      toBlockNumber: currentBlock
    })
  };
}
function formatPayloadLogs(logs) {
  return {
    createdLog: logs.find((log) => log.eventName === "PayloadCreated"),
    queuedLog: logs.find((log) => log.eventName === "PayloadQueued"),
    executedLog: logs.find((log) => log.eventName === "PayloadExecuted")
  };
}
function getPayload({
  client,
  payloadsController,
  payloadId
}) {
  const contract = getContract({
    abi: IPayloadsControllerCore_ABI,
    client,
    address: payloadsController
  });
  return contract.read.getPayloadById([payloadId]);
}

// src/common/governance.ts
var import_js_utils2 = __toESM(require_node2(), 1);
async function getGovernanceEvents({
  governance,
  client,
  fromBlockNumber,
  toBlockNumber
}) {
  const logs = await import_js_utils2.strategicGetLogs({
    client,
    events: [
      getAbiItem({ abi: IGovernanceCore_ABI, name: "ProposalCreated" }),
      getAbiItem({ abi: IGovernanceCore_ABI, name: "ProposalQueued" }),
      getAbiItem({ abi: IGovernanceCore_ABI, name: "ProposalExecuted" }),
      getAbiItem({ abi: IGovernanceCore_ABI, name: "PayloadSent" }),
      getAbiItem({ abi: IGovernanceCore_ABI, name: "VotingActivated" }),
      getAbiItem({ abi: IGovernanceCore_ABI, name: "ProposalCanceled" })
    ],
    address: governance,
    fromBlock: fromBlockNumber,
    toBlock: toBlockNumber
  });
  return await Promise.all(logs.map(async (l) => ({
    ...l,
    timestamp: Number((await getBlock(client, { blockNumber: l.blockNumber })).timestamp)
  })));
}
async function syncGovernanceEvents({
  client,
  governance,
  lastSeenBlock = 0n
}) {
  const currentBlock = await getBlockNumber(client);
  const contract = getContract({
    abi: IGovernanceCore_ABI,
    address: governance,
    client
  });
  const proposalsCount = await contract.read.getProposalsCount();
  if (proposalsCount === 0n) {
    return { lastSeenBlock: currentBlock, events: [] };
  }
  if (lastSeenBlock === 0n) {
    const firstProposal = await contract.read.getProposal([0n]);
    const firstRelevantBlock = await import_js_utils2.getBlockAtTimestamp({
      client,
      timestamp: BigInt(firstProposal.creationTime),
      fromBlock: BigInt(0),
      toBlock: currentBlock,
      maxDelta: BigInt(60 * 60 * 12)
    });
    lastSeenBlock = firstRelevantBlock.number;
  }
  return {
    lastSeenBlock: currentBlock,
    events: await getGovernanceEvents({
      governance,
      client,
      fromBlockNumber: lastSeenBlock,
      toBlockNumber: currentBlock
    })
  };
}
function formatProposalLogs(logs) {
  return {
    createdLog: logs.find((log) => log.eventName === "ProposalCreated"),
    votingActivatedLog: logs.find((log) => log.eventName === "VotingActivated"),
    queuedLog: logs.find((log) => log.eventName === "ProposalQueued"),
    executedLog: logs.find((log) => log.eventName === "ProposalExecuted"),
    payloadSentLog: logs.filter((log) => log.eventName === "PayloadSent"),
    canceledLog: logs.find((log) => log.eventName === "ProposalCanceled")
  };
}
function getProposal({
  client,
  governance,
  proposalId
}) {
  const contract = getContract({
    abi: IGovernanceCore_ABI,
    address: governance,
    client
  });
  return contract.read.getProposal([proposalId]);
}

// src/providers/githubPagesProvider.ts
function getPath() {
  return "https://bgd-labs.github.io/v3-governance-cache/cache/";
}
var githubPagesProvider = {
  async getPayload({ chainId, payloadsController, payloadId }) {
    const path = `${chainId.toString()}/${payloadsController}/payloads/${payloadId}.json`;
    const cache = await (await fetch(getPath() + path)).json();
    return { payload: cache.payload, logs: formatPayloadLogs(cache.events) };
  },
  async getProposal({ chainId, governance, proposalId }) {
    const path = `${chainId.toString()}/${governance}/proposals/${proposalId}.json`;
    console.log(path);
    const cache = await (await fetch(getPath() + path)).json();
    return { proposal: cache.proposal, logs: formatProposalLogs(cache.events), ipfs: cache.ipfs };
  }
};
export {
  githubPagesProvider
};

//# debugId=8ACDA0C9D6AFBF2E64756E2164756E21
