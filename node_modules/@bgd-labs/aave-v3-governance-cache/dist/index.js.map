{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "import {\n  type AbiStateMutability,\n  type Address,\n  type ContractFunctionReturnType,\n  type GetLogsReturnType,\n} from 'viem';\nimport type {AbiEvent} from 'abitype';\nimport type {ProposalMetadata} from '@bgd-labs/js-utils';\nimport type {\n  IGovernanceCore_ABI,\n  IPayloadsControllerCore_ABI,\n} from '@bgd-labs/aave-address-book/abis';\nimport type {ExtractAbiEvent} from 'abitype';\n\ntype ArrayElement<ArrayType extends readonly unknown[]> =\n  ArrayType extends readonly (infer ElementType)[] ? ElementType : never;\n\nexport type LogWithTimestamp<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n> = ArrayElement<GetLogsReturnType<TAbiEvent, TAbiEvents>> & {\n  timestamp: number;\n};\n\nexport type ProposalCacheRaw = {\n  events: ProposalEvent[];\n  ipfs?: ProposalMetadata;\n  proposal?: Proposal;\n};\n\nexport type PayloadCacheRaw = {\n  events: PayloadEvent[];\n  payload?: Payload;\n};\n\nexport interface GetPayloadReturnType {\n  logs: PayloadLogs;\n  payload: Payload;\n}\n\nexport interface GetProposalReturnType {\n  logs: ProposalLogs;\n  proposal: Proposal;\n  // it's optional as there#s a chance the ipfs file is not reachable\n  ipfs?: ProposalMetadata;\n}\n\nexport interface GovernanceCacheAdapter {\n  getPayload: (args: {\n    chainId: number;\n    payloadsController: Address;\n    payloadId: number;\n  }) => GetPayloadReturnType | Promise<GetPayloadReturnType>;\n  getProposal: (args: {\n    chainId: number;\n    governance: Address;\n    proposalId: bigint;\n  }) => GetProposalReturnType | Promise<GetProposalReturnType>;\n}\n\nexport interface GovernanceCacheAdapterWithSync extends GovernanceCacheAdapter {\n  syncPayloadsCache: (args: {chainId: number; payloadsController: Address}) => any;\n  syncProposalCache: (args: {chainId: number; governance: Address}) => any;\n}\n\n/**\n * Proposal types\n */\nexport type ProposalCreatedEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IGovernanceCore_ABI, 'ProposalCreated'>\n>;\nexport type ProposalQueuedEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IGovernanceCore_ABI, 'ProposalQueued'>\n>;\nexport type ProposalCanceledEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IGovernanceCore_ABI, 'ProposalCanceled'>\n>;\nexport type ProposalExecutedEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IGovernanceCore_ABI, 'ProposalExecuted'>\n>;\nexport type ProposalPayloadSentEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IGovernanceCore_ABI, 'PayloadSent'>\n>;\nexport type ProposalVotingActivatedEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IGovernanceCore_ABI, 'VotingActivated'>\n>;\nexport type ProposalEvent =\n  | ProposalCreatedEvent\n  | ProposalQueuedEvent\n  | ProposalCanceledEvent\n  | ProposalExecutedEvent\n  | ProposalPayloadSentEvent\n  | ProposalVotingActivatedEvent;\n\nexport type Proposal = ContractFunctionReturnType<\n  typeof IGovernanceCore_ABI,\n  AbiStateMutability,\n  'getProposal'\n>;\n\nexport interface ProposalLogs {\n  createdLog: ProposalCreatedEvent;\n  queuedLog?: ProposalQueuedEvent;\n  executedLog?: ProposalExecutedEvent;\n  votingActivatedLog?: ProposalVotingActivatedEvent;\n  canceledLog?: ProposalCanceledEvent;\n  payloadSentLog: ProposalPayloadSentEvent[];\n}\n\nexport enum ProposalState {\n  Null = 0, // proposal does not exists\n  Created = 1, // created, waiting for a cooldown to initiate the balances snapshot\n  Active = 2, // balances snapshot set, voting in progress\n  Queued = 3, // voting results submitted, but proposal is under grace period when guardian can cancel it\n  Executed = 4, // results sent to the execution chain(s)\n  Failed = 5, // voting was not successful\n  Cancelled = 6, // got cancelled by guardian, or because proposition power of creator dropped below allowed minimum\n  Expired = 7,\n}\n\nexport const FINAL_PROPOSAL_STATES = [\n  ProposalState.Executed,\n  ProposalState.Failed,\n  ProposalState.Cancelled,\n  ProposalState.Expired,\n];\n\nexport function isProposalFinal(state: ProposalState) {\n  return FINAL_PROPOSAL_STATES.includes(state);\n}\n\n/**\n * Payload types\n */\nexport enum PayloadState {\n  None = 0,\n  Created = 1,\n  Queued = 2,\n  Executed = 3,\n  Cancelled = 4,\n  Expired = 5,\n}\n\nexport type PayloadCreatedEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IPayloadsControllerCore_ABI, 'PayloadCreated'>\n>;\nexport type PayloadQueuedEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IPayloadsControllerCore_ABI, 'PayloadQueued'>\n>;\nexport type PayloadExecutedEvent = LogWithTimestamp<\n  ExtractAbiEvent<typeof IPayloadsControllerCore_ABI, 'PayloadExecuted'>\n>;\nexport type PayloadEvent = PayloadCreatedEvent | PayloadQueuedEvent | PayloadExecutedEvent;\n\nexport interface PayloadLogs {\n  createdLog: PayloadCreatedEvent;\n  queuedLog?: PayloadQueuedEvent;\n  executedLog?: PayloadExecutedEvent;\n}\n\nexport type Payload = ContractFunctionReturnType<\n  typeof IPayloadsControllerCore_ABI,\n  AbiStateMutability,\n  'getPayloadById'\n>;\n\nexport const FINAL_PAYLOAD_STATES = [\n  PayloadState.Cancelled,\n  PayloadState.Executed,\n  PayloadState.Expired,\n  // -1, // error\n];\n\nexport function isPayloadFinal(state: number) {\n  return FINAL_PAYLOAD_STATES.includes(state);\n}\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkIO,SAAS,eAAe,CAAC,OAAsB;AACpD,SAAO,sBAAsB,SAAS,KAAK;AAAA;AA6CtC,SAAS,cAAc,CAAC,OAAe;AAC5C,SAAO,qBAAqB,SAAS,KAAK;AAAA;AAjErC,IAAK;AAAL,EAAK,mBAAL;AACL,0CAAO,KAAP;AACA,6CAAU,KAAV;AACA,4CAAS,KAAT;AACA,4CAAS,KAAT;AACA,8CAAW,KAAX;AACA,4CAAS,KAAT;AACA,+CAAY,KAAZ;AACA,6CAAU,KAAV;AAAA,GARU;AAWL,IAAM,wBAAwB;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AASO,IAAK;AAAL,EAAK,kBAAL;AACL,wCAAO,KAAP;AACA,2CAAU,KAAV;AACA,0CAAS,KAAT;AACA,4CAAW,KAAX;AACA,6CAAY,KAAZ;AACA,2CAAU,KAAV;AAAA,GANU;AAgCL,IAAM,uBAAuB;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAEF;",
  "debugId": "7044DF7B6C28321064756E2164756E21",
  "names": []
}